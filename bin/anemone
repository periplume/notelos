#!/usr/bin/env bash
# file: anemone
# source: https://github.com/periplume/notelos.git
# author: jason@bloom.us
# description: flashcard memory app

# STRICT SHELL
set -o errexit 
set -o nounset
set -o pipefail
IFS=$'\n\t'

###########################
# DEPENDENCIES
###########################
 
# required external commands
_requiredCommands=(git tig)

###########################
# LIBRARY
###########################

# source library commands and set up log/console
# use the library file from the same directory if possible
# otherwise use the one in the standard path search method
[[ -e "$(dirname $0)/notelos-lib.sh" ]] \
	&& source "$(dirname $0)/notelos-lib.sh" \
	|| source notelos-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

# default initial debugging and logging settings
# note: command line parameters can modify these
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=true

# instantiate the log/mesg functions with defaults (these will be re-initialized
# after reading positional parameters)
_fLOG

####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF
usage: anemone [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit
 -x      force standalone mode

alternate env settings:
 -a <name>  set the anemone dir name to <name>
 -p <path>  set alternate base path

commands:
EOF
_printCommands
}

_printCommands() {
	cat <<  EOF
 new                 create new cards manually
 group               create new group
 import              import cards from csv files
 create              create a new anemone git database
 inspect             run tig on the anemone git bare repo
EOF
}

_printInfo () {
  cat << EOF
anemone manages flashcards in a spaced-repetition manner
EOF
}

####################################
# PARAMETER PROCESSING
####################################

_getOpts () {
	# preserve the initial positional parameters
	export _fullCommand="${@}"
	_debug "full command is '${_fullCommand}'"
	local OPTIND
	# do not allow names for notelos or self to be names of commands
	_isCommand() {
		local _allowed=true
		local _commandList
		_commandList=$(_printCommands | cut -f2 -d' ')
		for _command in ${_commandList}; do
      [[ "${_command}" = "${1}" ]] && _allowed=false 
    done
    [[ ${_allowed} = "true" ]] || return 1
  }
	while getopts ":hsdlxva:p:" flag ; do
		case ${flag} in 
			h)
				_printInfo; _printUsage; exit 0
				;;
			a)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_isCommand "${OPTARG}" || { _error "'${OPTARG}' is not allowed (it is a command)"; exit 1; }
				_NAME=${OPTARG}
				_warn "using alt name '${_NAME}'"
				;;
			p)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_BASE=${OPTARG}
				_warn "using alt path '${_BASE}'"
				;;
 	    s)
				_debug "${FUNCNAME[0]}: enabling silent mode with flag -$flag"
 	      _SILENT=true
				;;
			d)
				_debug "${FUNCNAME[0]}: enabled debug mode with flag -$flag"
				_DEBUG=true
				;;
			l)
				_debug "${FUNCNAME[0]}: enabled log mode with flag -$flag"
				_LOG=true
				;;
			x)
        _debug "${FUNCNAME[0]}: running in standalone mode with -$flag"
        _MODE=standalone
        ;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -${OPTARG}"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1)); OPTIND=1
	# preserve the full subcommand with its parameters
	export _subCommandParams="${@}"
	# look for the subcommand and check for its options
	while ((${#})); do
		case ${1} in
			help)
				_printInfo; _printUsage; exit 0
				;;
			new)
				_subCommand=$1; shift
				return
				;;
			import)
				_subCommand=$1; shift
				return
				;;
			create)
				_subCommand=$1; shift
				return
				;;
			inspect)
				_subCommand=$1; shift
				return
				;;
			search)
				_subCommand=$1
				return
				;;
			browse)
				_subCommand=$1
				return
				;;
			*)
				_error "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
  # get the name and absolute path of the calling script
  _selfNAME=$(basename "${BASH_SOURCE[0]}")
  _selfABSOLUTE=$(readlink -f "${BASH_SOURCE[0]}")
  _selfBASE=$(dirname "${_selfABSOLUTE}")
  _selfCALL=${0}
  _selfPWD=$(pwd)
	# determine mode (notelos-integrated or standalone)
	[[ -n "${_notelosHOME+x}" && ${_MODE:-} != "standalone" ]] && _MODE=integrated || _MODE=standalone
	# note: the -x switch overrides the global _notelosHOME var 
	# integrated mode only happens when global var _notelosHOME is available
	# set up the working environment
	if [[ ${_MODE} = "integrated" ]]; then
		# set up integrated mode
		_MASTER="${_notelosNAME}"
		_BASE="${_notelosHOME}"
		_NAME="${_NAME:-${_selfNAME}}"
		_HOME="${_BASE}/${_NAME}"
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/.log/${_NAME}.log"
		# inherit these (from notelos)
		_DEBUG=${_notelosDEBUG}
		_LOG=${_notelosLOG}
		_SILENT=${_notelosSILENT}
		_USERNAME=${_notelosUSERNAME}
		_USEREMAIL=${_notelosUSEREMAIL}
		_EDITOR=_notelosEdit
	else
		# set up standalone mode
		_MASTER=self
		_BASE="${_BASE:-$HOME}"
		_NAME="${_NAME:-${_selfNAME}}"
		_HOME=${_BASE}/${_NAME}
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/${_NAME}.log"
		# inherit these
		_DEBUG=${_DEBUG:-false}
		_LOG=${_LOG:-false}
		_SILENT=${_SILENT:-false}
		_USERNAME=$(whoami)
		_USEREMAIL="unknown"
		_EDITOR=${EDITOR:-nano}
	fi
  [[ -f "${_LOGFILE:-}" ]] && _LOGGING=true || _LOGGING=false
	_debug "$(declare -p _MODE)"
	_debug "$(declare -p _MASTER)"
	_debug "$(declare -p _NAME)"
	_debug "$(declare -p _BASE)"
	_debug "$(declare -p _HOME)"
	_debug "$(declare -p _USERNAME)"
	_debug "$(declare -p _USEREMAIL)"
	_debug "$(declare -p _GITDIR)"
	_debug "$(declare -p _LOGFILE)"
	_debug "$(declare -p _DEBUG)"
	_debug "$(declare -p _SILENT)"
	_debug "$(declare -p _LOG)"
	_debug "$(declare -p _LOGGING)"
	# export these only
	export _HOME
	export _EDITOR
}

_checkExternalTools() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			: #_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}

_checkHome() {
  # check if the home dir exists
  # check if it is a notelos-created git
  # return 1 if missing or not git
  # mind condition: if subcommand is create
	# TODO add git integrity check and other health related tests (and means to
	# record the results for historical data)
	[[ ! -d "${_BASE}" && ${_MODE} = "notelos" ]] && { _error "notelos base not found"; exit 1; }
	[[ -d "${_BASE}" ]] || { _error "base '${_BASE}' does not exist"; exit 1; }
	local _base="${_BASE}"
	local _dirName="${_NAME}"
	local _dirPath="${_HOME}"
	local _git_desc="${_dirPath}/.git/description"
  if [ -d "${_dirPath}" ]; then
    if [ -f "${_git_desc}" ]; then
      # the git description file exists, lets check it for our marker
      read -r _desc < "${_git_desc}"
      if [[ ${_desc} == ${_MASTER}:${_NAME}:${_USERNAME}* ]]; then
        # if repo does exist, return 0
        _debug "${_git_desc} = ${_desc}"
				return
      else
        # if repo does not exist, warn and exit
        _error "${_dirPath} exists and is NOT a notelos-created repo"
        return 1
      fi
    else
      _error "${_dirPath} exists and is NOT a git repo"
      _error "move existing ${_dirPath} before proceeding"
      return 1
    fi
  else
    # dir does not exist
    _warn "'${_dirPath}' does not exist"
    read -rsn1 -p "$(_ask 'create repo now? [y/n]')" _yn
    echo
    [[ ${_yn} != "y" ]] && { _warn "cannot run without a repo"; return 1;  }
    _create || { _error "could not create ${_dirName} repo"; return 1; }
    return
  fi
}

############################
# CREATE
############################

# TODO create a version format number...test for this individually
# so we know what the expected things are we can test for and measure

_create() {
	# do not overwrite an existing anything
	[[ -d "${_HOME}" ]] && { _error "'${_HOME}' exists"; return 1; }
	[ ! -d "${_HOME}" ] && mkdir "${_HOME}"
	git init -q -b main "${_HOME}"
  git -C "${_HOME}" config user.name "${_USERNAME}"
  git -C "${_HOME}" config user.email "${_USEREMAIL}"
	# make the anemone skeleton workflow dirs
	mkdir "${_HOME}/groups"				# main group category state
	mkdir "${_HOME}/sessions"			# session workflow ie the boxes
	mkdir "${_HOME}/cards"				# collection of active cards
	mkdir "${_HOME}/import"				# import directory for csv files
	mkdir "${_HOME}/state"				# where state is maintained
	mkdir "${_HOME}/log"					# where logs go
	# ignore logs
	echo "log/" > "${_HOME}/.gitignore"
	# add gitignore and make first commit
  git -C "${_HOME}" add .gitignore
  git -C "${_HOME}" commit -q -m "[genesis] ${_NAME} created by ${_USERNAME}"
	# put the installed signature in git description file
  _gitInitial=$(git -C "${_HOME}" rev-parse --short --verify main)
  _time=$(date +%s)
  printf "${_MASTER}:${_NAME}:${_USERNAME}:${_time}:${_gitInitial}\n" > "${_HOME}/.git/description"
}

##################################
# INSPECT
##################################

_inspect() {
	tig -C${_HOME}
}

# run the dictate window
_shell() {
	local _micSTATE
	local _ffmpegSTATE
	local _ffmpegPID
	local _whisperSTATE
	local _whisperPID
	local _importSTATE
	local _importPID
	local _recordingState
	local _recording_pid=""
	local _transcriptionState="waiting"
	local _transcription_pid=""
	# colorize states: waiting, recording, paused
	_cStat() {
		# TODO remove tput usage here
		[[ "${1}" =~ ^(recording) ]] && { tput blink; tput setaf 7; tput setab 1; }
		[[ "${1}" =~ ^(waiting) ]] && tput setaf 3
		[[ "${1}" =~ ^(failed) ]] && tput setaf 1
		[[ "${1}" =~ ^(idle) ]] && tput setaf 3
		[[ "${1}" =~ ^(paused) ]] && { tput blink; tput setaf 7; tput setab 1; }
		[[ "${1}" =~ ^(unknown) ]] && { tput blink; tput setaf 2; }
		[[ "${1}" =~ ^(importing) ]] && { tput blink; tput setaf 3; }
		[[ "${1}" =~ ^(transcribing) ]] && { tput blink; tput setaf 4; }
		# iphone green attached; yellow detached
		[[ "${1}" =~ ^(attached) ]] && { tput setaf 2; }
		[[ "${1}" =~ ^(detached) ]] && { tput setaf 3; }
		# iphone mount state
		[[ "${1}" =~ ^(mounted) ]] && { tput setaf 2; }
		[[ "${1}" =~ ^(unmounted) ]] && { tput setaf 3; }
		echo -n "${1}"
		tput sgr0
	}
	_getKey() {
		# generate unique unix-time key and record (mkdir) in catalog
		local _key=$(date +%s)
		# don't give out the same key twice
		if [ -e "${_HOME}/catalog/${_key}" ]; then
			sleep 1
			# try again after a sleep (recursive)
			_getKey
		else
			# enter key into catalog
			mkdir "${_HOME}/catalog/${_key}"
			# print the key
			echo ${_key}
		fi
	}
	_catalogNew() {
		# add $1 to catalog unless it exists, otherwise return 1
		local _entry=$1
		[[ -d "${_HOME}/catalog/${_entry}" ]] && { _warn "catalog entry '${_entry}' exists"; return 1; }
		mkdir "${_HOME}/catalog/${_entry}"
	}
	_catalogAdd() {
		local _key=$1
		local _type=$2
		local _value=${3:-}
		[[ -d "${_HOME}/catalog/${_key}" ]] || { _warn "no such key '${_key}' in catalog"; return 1; }
		echo "${_value}" > "${_HOME}/catalog/${_key}/${_type}"
	}
	_record() {
		# do not record if recording is active
		[[ -e "${_HOME}/state/mic/recording" ]] && { _warn "recording in progress"; return; }
		# change mic state from idle to transitioning
		[[ -d "${_HOME}/state/mic/idle" ]] && rmdir "${_HOME}/state/mic/idle"
		mkdir -p "${_HOME}/state/mic/transitioning"
		# set output format to wav (cpu vs space)
		local oFmt="wav"
		# get key and define file name
		local _key=$(_getKey)
		local _file="${_key}.${oFmt}"
		# start ffmpeg recording
		ffmpeg -loglevel warning \
			-progress "${_HOME}/log/${_key}-ffmpeg.progress" \
			-hide_banner \
			-f alsa \
			-i default \
			-sample_rate 44100 \
			"${_HOME}/mic/${_file}" \
		 	>"${_HOME}/log/${_key}-ffmpeg.log" 2>&1 &
		# get the pid of the ffmpeg process (so we can signal it later)
		_ffmpegPID=$!
		# make sure this process is running
		if [ -d "/proc/${_ffmpegPID}" ]; then
			# system reports this is so, so change state
			mv "${_HOME}/state/mic/transitioning" "${_HOME}/state/mic/recording" 
			mkdir -p "${_HOME}/state/mic/pid/${_ffmpegPID}"
			mkdir -p "${_HOME}/state/mic/file/${_file}"
			mkdir -p "${_HOME}/state/mic/progressfile/${_key}-ffmpeg.progress"
			mkdir -p "${_HOME}/state/mic/logfile/${_key}-ffmpeg.log"
		else
			# some problem with ffmpeg occurred...change state to unknown
			mv "${_HOME}/state/mic/transitioning" "${_HOME}/state/mic/unknown"
			_debug "ffmpeg process for ${_key} did not start successfully; pid=${_ffmpegPID}"
		fi
	}
	_abort() {
		# check for recording in progress
		[[ -e "${_HOME}/state/mic/recording" ]] || { _warn "nothing to abort"; return; }
		# check for the pid dir in which the pid is stored as a dir
		[[ -e "${_HOME}/state/mic/pid" ]] || { _warn "no pid found; problem"; return; }
		# get the ffmpeg pid and filename from state dir
		ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
		# get the key
		key=${ffmpegFILE%%.*}
		# send INT signal to ffmpeg
		kill -SIGINT ${ffmpegPID}
		# remove pid info from state dir
		rm -rf "${_HOME}/state/mic/pid/"
		# change mic state
		mv "${_HOME}/state/mic/recording" "${_HOME}/state/mic/idle"
		# remove state file info
		rm -rf "${_HOME}/state/mic/file"
		# remove media file
		rm "${_HOME}/mic/${ffmpegFILE}"
		# remove logs
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/logfile"/*)"
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/progressfile"/*)"
		# remove log pointers
		rm -rf "${_HOME}/state/mic/progressfile"
		rm -rf "${_HOME}/state/mic/logfile"
		# update catalog
		rmdir "${_HOME}/catalog/${key}"
	}
	_save() {
		# check for recording in progress
		[[ -e "${_HOME}/state/mic/recording" ]] || { _warn "not recording"; return; }
		# check for the pid dir in which the pid is stored as a dir
		[[ -e "${_HOME}/state/mic/pid" ]] || { _warn "no pid found; problem"; return; }
		# get the ffmpeg pid and filename from state dir
		ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
		# get the key
		key=${ffmpegFILE%%.*}
		# send INT signal to ffmpeg
		kill -SIGINT ${ffmpegPID}
		# remove pid info from state dir
		rm -rf "${_HOME}/state/mic/pid/"
		# change mic state
		mv "${_HOME}/state/mic/recording" "${_HOME}/state/mic/idle"
		# remove state file info
		rm -rf "${_HOME}/state/mic/file"
		# move media file to queue
		mv "${_HOME}/mic/${ffmpegFILE}" "${_HOME}/queue/${ffmpegFILE}"
		# remove logs
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/logfile"/*)"
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/progressfile"/*)"
		# remove log pointers
		rm -rf "${_HOME}/state/mic/progressfile"
		rm -rf "${_HOME}/state/mic/logfile"
	}

	_name() {
		# a funky function...sadly
		# name transcript groups and manage keys in the named group
		[[ -d "${_HOME}/names" ]] || mkdir "${_HOME}/names"
		# use _namePicker to select name conforming to naming convention
		_namePicker _chosen "ls ${_HOME}/names" _validateName "names" "? for help"
		[[ ${_chosen} = ":" ]] && { _warn "nothing to do"; return; }
		_selection=${_chosen#*:}
		_query=${_chosen%%:*}
		_info "got query='${_query}' and selection='${_selection}' from '${_chosen}'"
		# if query is empty then we only have selection
		if [[ -z ${_query} ]]; then
		 	_nameSelected=${_selection}
			_debug "using selection because query is empty"
		# if query and selection are the same, easy
		elif [[ ${_query} == ${_selection} ]]; then
		 	_nameSelected=${_query}
			_debug "using query because selection is the same"
		# if query and selection are not the same...use query
		elif [[ ${_query} != ${_selection} ]]; then
			_nameSelected=${_query}
			_debug "using query because selection is not the same"
		fi
		# check if new or existing
		if _doesNameExist "${_nameSelected}"; then
			# existing
			true
		else
			# validate name with _isNameValid
			if _isNameValid "${_nameSelected}"; then
				mkdir "${_HOME}/names/${_nameSelected}"
			else
				_warn "invalid name '${_nameSelected}'"
				return
			fi
		fi
		# now use namepicker again to add/remove keys to/from the selected name
		# fzf uses ctrl-a and ctrl-r to add and remove the selected key
		#_namePicker _chosen "ls ${_HOME}/catalog" _showName "${_nameSelected}" "? for help"
		_namePicker _chosen "ls ${_HOME}/catalog" _previewEntry "${_nameSelected}" "? for help"
		#TODO commit
		#TODO this should be one function with one fzf call...all the operations can be
		# functionized, and use can stay in fzf...more work...but it works now
	}
	

	_push() {
		# use _namePicker to select name conforming to naming convention
		_namePicker _chosen "ls ${_HOME}/names" _validateName "select group" "? for help"
		[[ ${_chosen} = ":" ]] && { _warn "nothing to do"; return; }
		_selection=${_chosen#*:}
		_query=${_chosen%%:*}
		_info "got query='${_query}' and selection='${_selection}' from '${_chosen}'"
		# if query is empty then we only have selection
		if [[ -z ${_query} ]]; then
		 	_nameSelected=${_selection}
			_debug "using selection because query is empty"
		# if query and selection are the same, easy
		elif [[ ${_query} == ${_selection} ]]; then
		 	_nameSelected=${_query}
			_debug "using query because selection is the same"
		# if query and selection are not the same...use query
		elif [[ ${_query} != ${_selection} ]]; then
			_nameSelected=${_query}
			_debug "using query because selection is not the same"
		fi
		# check if new or existing
		if ! _doesNameExist "${_nameSelected}"; then
			_warn "cannot push invalid name '${_nameSelected}'"
			return 1
		fi
		# existing
		_debug "push '${_nameSelected}'"
		read -r -p "$(_ask 'push to what? ')" _pushDestination
		if [[ ${_pushDestination} = "epistle" ]]; then
			read -r -p "$(_ask 'epistle to whom? ')" _epistleRecipient
			for key in $(ls "${_HOME}/names/${_nameSelected}"); do
				if [[ -e "${_HOME}/proofs/${key}.txt" ]]; then
					printf "\n"
					cat "${_HOME}/proofs/${key}.txt" | tr '\n' ' ' | fold -s -w 66
					printf "\n"
				else
					printf "\n"
					cat "${_HOME}/transcripts/${key}/${key}.txt" | tr '\n' ' ' | fold -s -w 66
					printf "\n"
				fi
			#done | _notelosHOME="${_BASE}" "${_BASE}/.bin/epistle" -d -a epistle -p "${_BASE}" new -i -t "${_epistleRecipient}"
			# pipe it all into one document
			done | "${_BASE}/.bin/epistle" new -i -t "${_epistleRecipient}"
			# TODO
			# this is exposing a major problem
			# when we call epistle from mnemon, all the standard _notelosHOME etc are
			# mucked up...thus all the hoops to get epistle to run
			# however the above -hardcoded- solution actually works
			# this thing is a mess
			# this is fixed now...export only _HOME, which is never set based on
			# existing _HOME
		# for germ, we pipe each one as a new germ into designated source
		elif [[ ${_pushDestination} = "germ" ]]; then
			read -r -p "$(_ask 'which germ source? ')" _germSource
			for key in $(ls "${_HOME}/names/${_nameSelected}"); do
				if [[ -e "${_HOME}/proofs/${key}.txt" ]]; then
					# TODO the problem with reformatting here is I lose the
					# paragraphs...need to fix this...probably need to remove the 'tr'
					cat "${_HOME}/proofs/${key}.txt" | tr '\n' ' ' | fold -s -w 66 | "${_BASE}/.bin/germ" add -i -s "${_germSource}"
				else
					cat "${_HOME}/transcripts/${key}/${key}.txt" | tr '\n' ' ' | fold -s -w 66 | "${_BASE}/.bin/germ" add -i -s "${_germSource}"
				fi
			done
		else
			echo "no solution for that yet"
		fi
		#TODO think through the push process more
	}

	_browse() {
		# the main browser
		# browse the transcripts
		# if there aren't any, don't bother
		[[ $(ls -A ${_HOME}/transcripts/) ]] || { _warn "no transcripts available"; return; }
		# create state
		[[ ! -d "${_HOME}/state/browser" ]] && mkdir "${_HOME}/state/browser"
		# clean up state first
		if [ -n "$(find "${_HOME}/state/browser/group" -mindepth 1 -maxdepth 1)" ]; then
			# not empty
			rmdir "${_HOME}/state/browser/group/$(_getCurrentGroup)"
		fi
		# set initial group to all
		mkdir -p "${_HOME}/state/browser/group/all"
		# call the fzf browser wrapper function
		_fzfBrowse _chosen "ls ${_HOME}/catalog" _previewEntry all "? for help"
		# the selected key is $_chosen (nameref passed to _fzfBrowse and assigned
		# within that function)
		if [[ -z "${_chosen}" ]]; then
			# nothing selected...carry on
			true
		elif
			[[ "${_chosen}" = ":" ]]; then
			# also nothing selected...carry on
			true
		else
			_debug "TODO offer menu on action on selection list that is: $_chosen"
		fi
		# clean up state
		[ -e $"{_HOME}/state/browser/group/*" ] && rmdir "${_HOME}/state/browser/group/*"
	}

	_findPhone() {
		# depends on libimobiledevice
		if ! hash idevice_id 2>/dev/null; then
			_error "${FUNCNAME}: idevice_id not found"
			_warn "install the libimobiledevice tools for iphone direct access"
			return 1
		fi
		if [ -d "${_HOME}/state/iphone/attached" ]; then
			_info "ATTACHED DEVICE"
		else
			_info "no attached device"
		fi
		_info "looking for iphone now"
		_ideviceList=$(idevice_id -l 2>&1)
		_ideviceListExitCode=$?
		if [ $_ideviceListExitCode != 0 ]; then
			# no phone visible, evidently
			_debug "'idevice_id -l' returned error: ${_ideviceList} ($_ideviceListExitCode)"
			_error "no iphone visible"
			[ -d "${_HOME}/state/iphone/attached" ] && rmdir "${_HOME}/state/iphone/attached"
			mkdir -p "${_HOME}/state/iphone/missing"
			return 1
		else
			_info "we may have a device to attach"
			_info "found device '$_ideviceList'"
			mkdir -p "${_HOME}/state/iphone/attached"
			mkdir -p "${_HOME}/state/iphone/id/${_ideviceList}"
			mkdir -p "${_HOME}/state/iphone/name/$(idevicename)"
			_deviceClass=$(ideviceinfo | grep ^DeviceClass | cut -f2 -d' ')
			mkdir -p "${_HOME}/state/iphone/class/${_deviceClass}"
			_deviceNumber=$(ideviceinfo | grep ^PhoneNumber)
			_deviceNumber="${_deviceNumber#*: }"
			mkdir -p "${_HOME}/state/iphone/number/${_deviceNumber}"
			mkdir -p "${_HOME}/state/iphone/mount"
			# now mount ONLY the "mnemon" folder in Firefox
			# a hacky little way of moving voice memos from the app to an accessible
			# dir
			ifuse --documents org.mozilla.ios.Firefox "${_HOME}/state/iphone/mount"
			if [ $? = 0 ]; then
				_info "mounted $(idevicename)"
				mkdir -p "${_HOME}/state/iphone/mounted"
			else
				_warn "ifuse mount of $(idevicename) failed"
			fi
			return 0
		fi
	}
	_unmountPhone() {
		fusermount -u "${_HOME}/state/iphone/mount"
		rmdir "${_HOME}/state/iphone/mounted"
	}	
	_import() {
		# user identifies the directory from which to import
		# only import wav, mp3, or m4a files
		# do not recurse the directory (if subdirectories exist)
		#
		#TODO use the iphone name as part of the import process
		#
		# use this to indicate the import is from mounted iphone
		local _mountedImport
		# this is the directory from which the import pulls ALL files
		# (in truth, we only use wav, mp3, and m4a files)
		local _dir
		# prompt user...import from mounted iphone...or from arbitrary directory
		# arbitrary directory can be selected using the _finder
		# check if phone is mounted...and ask whether to pull from it
		# assumes the audio files have already been moved into the Downloads folder
		# in Firefox on the iphone (the ugly hack)
		# TODO this could be improved to prompt the user to mount first, instead of
		# checking whether phone is already mounted
		#if [[ -d "${_HOME}/state/iphone/mounted" ]]; then
		#	read -rsn1 -p $(_ask "import from mounted iphone'? [y/n] ") _yn
		#	echo
		#	if [[ ${_yn} = "y" ]]; then
		#		# phone is mounted and user wants to import from it
		#		_mountedImport=true
		#		# set the import dir
		#		_dir="${_HOME}/state/iphone/mount/Downloads"
		#	fi
		#else
		#	# use _finder (from library) to identify directory with media files
		#	_dir=$(_finder)
		#fi
		# TODO problem is that if the phone is mounted, we aren't given the chance
		# to locate manually...since the ios 17 broke Files this is a problem
		_dir=$(_finder)

		# check for an empty directory, warn and abort if true
		[[ -z "${_dir}" ]] && { _warn "fzf returned empty string from _finder"; return; }
		# count files
		_count=0
		for file in "${_dir}"/*; do
			if [ -f "${file}" ]; then
				# ignore everything but mp3, m4a, wav
				[[ ( "${file}" == *.mp3 || "${file}" == *.m4a || "${file}" == *.wav ) ]] || break
				((_count++))
			fi
		done
		[[ ${_count} = 0 ]] && { _warn "no valid media files found"; return; }
		_goAhead=false
		# wait until user explicitly says go
		until $_goAhead; do
			read -rsn1 -p $(_ask "import ${_count} files from '${_dir}'? [y/n/?] ") _yn
			echo
			[[ ${_yn} = "n" ]] && { _warn "import aborted"; return; }
			[[ ${_yn} = "?" ]] && { _info "list of proposed import follows"; \
				_filecount=0
				printf "o=============================================================o\n"
				printf "%-4s %-30s %-10s %-6s\n" "index" "name" "size" "duration"
				printf "o-------------------------------------------------------------o\n"
				for file in "${_dir}"/*; do
					if [ -d "${file}" ]; then
						#_warn "ignoring directory ${file}"
						printf " %-4s %-30s %-10s\n" '-' "${file}" "ignoring nested directory"
					elif [ -f "${file}" ]; then
						# ignore everything but mp3, m4a, wav
						[[ ( "${file}" == *.mp3 || "${file}" == *.m4a || "${file}" == *.wav ) ]] || break
						((_filecount++))
						_name=$(basename ${file})
						_size=$(du -h "${file}" | awk '{print $1}')
						_duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${file}")
						if [[ ${_duration%%.*} -lt 60 ]]; then
						 	_duration="${_duration%%.*} seconds"
						else
							seconds=${_duration%%.*}
							minutes=$((seconds / 60))
							remaining_seconds=$((seconds % 60))
							_duration="${minutes}:${remaining_seconds}"
						fi
						printf " %-4s %-30s %-10s %-10s\n" ${_filecount} ${_name} ${_size} ${_duration}
					else
						_warn "'${file}' is neither file nor directory"
					fi
				done
				printf "o=============================================================o\n"
			}
			[[ ${_yn} = "y" ]] && _goAhead=true
		done
		for _file in ${_dir}/*; do
			# only process files
			[[ -f "${_file}" ]] || continue
			# ignore files that are not known media files (mp3,m4a,wav)
			[[ ( "${_file}" == *.mp3 || "${_file}" == *.m4a || "${_file}" == *.wav ) ]] || _warn "$_file not allowed"
			# get the unixtime from the "creation_time" 
			c_time=$(ffprobe -v error -show_entries stream_tags=creation_time -of default=noprint_wrappers=1:nokey=1 "${_file}")
			c_unix=$(date -d "${c_time}" +%s)
			suffix=${_file##*.}
			# get a key and enter into catalog
			_getKeyImport() {
				# custom _getkey function exclusive to _import
				# why? ... because we want to ideally create a key faithful to the
				# actual create time...which we extract from the audiofile with ffprobe
				# note: the whatsapp produced audio NEEDS to be handled
				# differently...its create time is encoded in the file name (while the
				# ffprobe info (I think) is the time the file was exported from
				# whatsapp)
				# pass desired key as $1 (what ffprobe extracted)
				# prints that key (if no conflict)
				# otherwise prints the next free key in time (close enough)
				local _key=$1
				# don't give out the same key twice
				if [ -e "${_HOME}/catalog/${_key}" ]; then
					# increment and try again
					((_key++))
					# try again after a sleep (recursive)
					_getKeyImport ${_key}
				else
					# print the key
					echo ${_key}
				fi
			}
			_key=$(_getKeyImport ${c_unix})
			# update the catalog with metadata and add the file to the queue
			if [[ ${_key} = ${c_unix} ]]; then
			 	_debug "got new matching key '${_key}' from '${c_unix}'"
				_debug "adding new key '${_key}' to catalog"
				_catalogNew "${_key}"
				_catalogAdd "${_key}" "import"
				_catalogAdd "${_key}" "original_name" "$(basename ${_file})" || { _error "great failure"; return 1; }
				_catalogAdd "${_key}" "audio_file" "${_key}.${suffix}"
				# extract metadata from each media file into catalog
				ffprobe -v error -print_format flat -show_format -show_streams "${_file}" > "${_HOME}/catalog/${_key}/file_metadata.txt"
				cp "${_file}" "${_HOME}/queue/${_key}.${suffix}"
			else
				_warn "'${c_unix}' conflict, got incremented '${_key}'"
				_import_filename=$(basename "${_file}")
				_catalog_filename=$(cat "${_HOME}/catalog/${c_unix}/original_name" || echo "")
				if [[ ${_import_filename} = ${_catalog_filename} ]]; then
					_warn "duplicate file detected...ignoring"
				else
					# the above isn't very robust, but import the file anyway
					_catalogNew "${_key}"
					_catalogAdd "${_key}" "import"
					_catalogAdd "${_key}" "original_name" "$(basename ${_file})" || { _error "great failure"; return 1; }
					_catalogAdd "${_key}" "audio_file" "${_key}.${suffix}"
					# extract metadata from each media file into catalog
					ffprobe -v error -print_format flat -show_format -show_streams "${_file}" > "${_HOME}/catalog/${_key}/file_metadata.txt"
					cp "${_file}" "${_HOME}/queue/${_key}.${suffix}"
				fi
			fi
		done
	}

	_showFileSize() {
			ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
			if [[ -e "${_HOME}/mic/${ffmpegFILE}" ]]; then
				echo "$(ls -l "${_HOME}/mic/${ffmpegFILE}" | awk '{print $5}')"
			else
				echo "n/a"
			fi
	}
	_showFileName() {
			ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
			if [[ -e "${_HOME}/mic/${ffmpegFILE}" ]]; then
				echo "${ffmpegFILE}"
			else
				echo "none"
			fi
	}

	# iphone state change
	# states:
	# attached (true/false)
	# mounted (true/false)
	# 
	_checkPhone() {
		# using idevice_id, probe for the presence of iphone
		# record the phone ID number
		# update state dir
		local _phoneID
		local _found
		if idevice_id -l 1>/dev/null 2>/dev/null; then
			# something attached
			_ideviceList=$(idevice_id -l 2>&1)
			_found=true
			# get the phone id (could there be 2?)
			_phoneID=${_ideviceList}
			# check state, change if necessary
			[[ -d "${_HOME}/state/iphone/attached" ]] || mkdir -p "${_HOME}/state/iphone/attached"
		else
			# nothing attached
			_found=false
			# check state, change if inconsistent
			[[ ! -d "${_HOME}/state/iphone/attached" ]] || rmdir "${_HOME}/state/iphone/attached"
		fi
	}

	_checkQueue() {
		# the main function that reads files in the queue and kicks off whisper
		# transcription jobs one at a time
		#
		# cleanup function to run if/when whisper fails (many reasons)
		_cleanup() {
			# remove state/whisper/transcribing
			rmdir "${_HOME}/state/whisper/transcribing"
			# add state/whisper/failed
			mkdir "${_HOME}/state/whisper/failed"
			# remove coproc info
		 	rm -rf "${_HOME}/state/whisper/coproc"
			# remove instance stats
		 	rm -rf "${_HOME}/state/whisper/inst"
		}
		# first check in state if whisper is already working
		# if so, just return 0 (ie don't do anything)
		[[ -e "${_HOME}/state/whisper/transcribing" ]] && return
		# check if whisper crashed (failed state)
		[[ -e "${_HOME}/state/whisper/failed" ]] && { _debug "whisper failed"; return; }
		# if file exists in queue, process it
		if [ -n "$(ls ${_HOME}/queue 2>/dev/null)" ]; then
			# change the state dir to reflect the job
			mkdir -p "${_HOME}/state/whisper/transcribing"
			# get the oldest file
			_file=$(ls "${_HOME}/queue/" | head -1)
			# set its full path
			_path="${_HOME}/queue/${_file}"
			# get the key
			_key=${_file%%.*}
			# get the start time
			_starttime=$(date +%s)
			# get the file type
			_filetype="${_file##*.}"
			# get the file size (in bytes)
			_filesize=$(stat -c %s "${_path}")
			# record the stats into coproc state
			mkdir -p "${_HOME}/state/whisper/inst/start/${_starttime}"
			mkdir -p "${_HOME}/state/whisper/inst/type/${_filetype}"
			mkdir -p "${_HOME}/state/whisper/inst/size/${_filesize}"
			mkdir -p "${_HOME}/state/whisper/inst/key/${_key}"
			#
			# TODO
			# update the state dir with data
			# start time
			# file type
			# source
			# file size
			#
			# run whisper as a coprocess
			# suppress_tokens expects a comma separated list of token ids
			# eg 0=!  ,=11  .=13  ?=30
			# the default is -1, setting this to '' or 0 seems to work best with
			# punctuation and catching the "hash Oh See dash put" to render #OC-put
			# someone noted on github that 0 renders "open quote" and "close quote"
			# into quotation marks...need to test this
			coproc WHISPER { whisper "${_path}" \
				--verbose False \
				--task transcribe \
				--language en \
				--model medium.en \
				--suppress_tokens '' \
				--output_dir "${_HOME}/transcripts/${_key}/." \
				--output_format all \
				--word_timestamps True \
				--max_line_width 60 \
				> "${_HOME}/log/whisper.log" 2>&1 || _cleanup
				# log whisper results...and if whisper fails, run _cleanup function
				# this means whisper has completed the transcription
				# move the audio file from the queue to audio/
				mv "${_path}" "${_HOME}/audio/${_file}"
				# change the state from transcribing
				rmdir "${_HOME}/state/whisper/transcribing"
				# remove the coproc pid info
		 		rm -rf "${_HOME}/state/whisper/coproc"
				# remove the instance stats
		 		rm -rf "${_HOME}/state/whisper/inst"
				# commit the resulting transcripts to git
  			git -C "${_HOME}" add "${_HOME}/transcripts/${_key}/*"
  			git -C "${_HOME}" commit -q -m "[whisper] transcripts for ${_key} saved"
				# make recursive to empty the queue (serially)
				_checkQueue
			}
			# note the coprocess pid in state _after_ the coproc job has started
			mkdir -p "${_HOME}/state/whisper/coproc/${WHISPER_PID}"
		else
			#_debug "no files in queue"
			true
		fi
	}
	# TODO when whisper does not have enough memory it just dies
	# prints to stderr (or out?) Killed
	# exits with 137
	# must catch this and right the boat...currently its a hot mess of failure
	# this is bash or the kernel sending SIGINT (kill -9) to the whisper process
	# due to OOM (out of memory) ie linux overcommit coming due
	# to catch this we might need trap...
	_getState() {
		if [[ -e "${_HOME}/state/mic/recording" ]]; then
			_recordingState="recording"
			_recording_ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		elif [[ -e "${_HOME}/state/mic/idle" ]]; then
			_recordingState="idle"
			_recording_ffmpegPID=''
		else
			_recordingState="idle"
			_recording_ffmpegPID=''
		fi
		if [[ -e "${_HOME}/state/whisper/transcribing" ]]; then
			_transcribingState="transcribing"
			_transcribing_coprocPID=$(basename "${_HOME}/state/whisper/coproc"/*)
			_transcribing_key=$(basename "${_HOME}/state/whisper/inst/key"/*)
		elif [[ -e "${_HOME}/state/whisper/failed" ]]; then
			_transcribingState="failed"
			_transcribing_coprocPID='n/a'
		else
			_transcribingState="idle"
			_transcribing_coprocPID=''
		fi
		if [[ -e "${_HOME}/state/iphone/attached" ]]; then
			_phoneState="attached"
		else
			_phoneState="detached"
		fi
		if [[ -e "${_HOME}/state/iphone/mounted" ]]; then
			_mountState="mounted"
		else
			_mountState="unmounted"
		fi
	}
	_printScreen() {
		quenum=$(ls "${_HOME}/queue" | wc -l)
		transnum=$(ls "${_HOME}/transcripts" | wc -l)
		proofnum=$(ls "${_HOME}/proofs" | wc -l)
		audnum=$(ls "${_HOME}/audio" | wc -l)
		micstate=$(_cStat ${_recordingState})
		whispstate=$(_cStat ${_transcribingState})
		mountstate=$(_cStat ${_mountState})
		iphonestate=$(_cStat ${_phoneState})
		# iphone may have been unplugged...check if so
		if [ -z "${iphonestate}" ]; then
			iphonename=null
		else
			if [ -d "${_HOME}/state/iphone/name" ]; then
				iphonename=$(basename $(find "${_HOME}/state/iphone/name" -mindepth 1 -maxdepth 1 -type d))
			else
				iphonename=nono
			fi
		fi
		ffmpegpid=${_recording_ffmpegPID:-none}
		transpid=${_transcribing_coprocPID:-none}
		whisppid=${_transcribing_whisperPID:-none}
		whispkey=${_transcribing_key:-n/a}
		# grab the last line of the whisper log...which is a funky CR-separated line
		# that refreshes itself strangely...thus the awk acrobatics below
		whisperlog_stat=$(tail -1 "${_HOME}/log/whisper.log")
		# first extract the last of the CR-separated segments in the line
		whisperlog_last=$(echo "${whisperlog_stat}" | awk 'BEGIN { RS="\r" } { segment = $0 } END { print segment }')
		# next just take the percent (integer)
		whisperlog_percent=$(echo "${whisperlog_last}" | awk -F'[%]' '{print $1}')
		# TODO the above will not work while whisper is initializing, before it
		# prints the status line (which we are parsing for the value)
		# don't display 100...which means it finished
		[[ ${whisperlog_percent} = "100" ]] && whisperlog_percent="n/a"
		# show the disk usage of the whole mnemon dir
		space=$(du -sh "${_HOME}" | awk '{print $1}')
		if [[ ! ${_DEBUG} = "true" ]]; then
			# don't use clear so we can scroll back for _debug etc output
			clear
		fi
		printf "=====\033[1mDICTATE MACHINE\033[0m--------Μνήμων--(%s)-------pid:%10d==============o\n" $_NAME $$
		printf "\n"
		printf " %-4s %-20s %18s %-23s %16s %s\n" 'mic:' $micstate 'whisper:' $whispstate 'iphone:' $iphonestate
		printf "  %-10s %-12s %7s %-18s %s\n" "ffmpeg pid:" $ffmpegpid "coproc pid:" $transpid $iphonename
		printf "  %-6s %-13s %8s %-25s %s\n" "media:" $(_showFileName) "key:" $whispkey $mountstate
		printf "  %-6s %-17s %6s %s\n" "size:" $(_showFileSize) "percent:" ${whisperlog_percent}
		#printf "  size: %s %s\n" $(_showFileSize) ${whisperlog_percent}
		#printf " %s\n" ${whisperlog_last}
		printf "\no==============================================================================o\n"
		printf "  %s(%s)     queue: %s     transcripts: %s    proofed: %s\n" $audnum $space $quenum $transnum $proofnum
		printf "o------------------------------------------------------------------------------o\n"  
		printf '
 r) record                          [begins recording from mic]
 a) abort recording                 [aborts and deletes current recording]
 s) stop and transcribe             [saves current recording and transcribes]
 b) browse                          [browse transcripts for proofing]
 n) name proofs                     [create names and assign proofs into]
 p) push                            [push group to germ or epistle]
 i) import                          [import audio files from local filesystem]
 m) mount  u) unmount               [mount and unmount attached iphone]
 t) tig                             [inspect repo with tig]
 q) quit

  token words recognized: quote, unquote, hash, underscore, dash
	metadata commands, eg, "hash g dash 1"     =>  #g-1
	                   eg, "hash oc dash put"  =>  #oc-put

'
	}
	# main loop for menu screen
	_getState
	_checkPhone
	_printScreen
	while read -r -s -n1 -p"$(_ask 'enter selection') " _selection; do
		echo
		case ${_selection} in
			t)
				_inspect || :
				;;
			n)
				_name || :
				;;
			m)
				_findPhone || :
				;;
			u)
				_unmountPhone || :
				;;
			r)
				# disable screen locking during recording and keep the screen from going
				# blank from inactivity
				_idledelay=$(gsettings get org.gnome.desktop.session idle-delay | cut -d' ' -f2)
				_lockenabled=$(gsettings get org.gnome.desktop.screensaver lock-enabled)
				gsettings set org.gnome.desktop.screensaver lock-enabled false
				gsettings set org.gnome.desktop.session idle-delay 0
				_record || :
				;;
			a)
				# restore desktop locking and screen blanking
				gsettings set org.gnome.desktop.screensaver lock-enabled ${_lockenabled:-false}
				gsettings set org.gnome.desktop.session idle-delay ${_idledelay:-600}
				_abort || :
				;;
			s)
				# restore desktop locking and screen blanking
				gsettings set org.gnome.desktop.screensaver lock-enabled ${_lockenabled:-false}
				gsettings set org.gnome.desktop.session idle-delay ${_idledelay:-600}
				_save || :
				;;
			b)
				_browse || :
				;;
			p)
				_push || :
				;;
			i)
				_import || :
				;;
			q)
				if [[ ${_recordingState} = "recording" ]]; then
					_warn "recording live now"
					read -rsn1 -p "$(_ask 'really quit now? [yn] ')" _yn
					echo
					if [[ ${_yn} = "y" ]]; then
						# restore desktop locking and screen blanking
						gsettings set org.gnome.desktop.screensaver lock-enabled ${_lockenabled:-false}
						gsettings set org.gnome.desktop.session idle-delay ${_idledelay:-600}
					 	return
						# note this does not terminate the record session...it remains live
						# and will "reconnect" by restarting mnemon
					else
						continue
					fi
				else
					return 0
				fi
				;;
		esac
		_checkPhone
		_checkQueue
		_getState
		_printScreen
	done
}

main() {
	# read all the positional parameters
  _getOpts "${@}"
  # setup the environment after processing all command line parameters
  _setEnv
  # validate the environment (external tools required)
  _checkExternalTools || { _error "cannot run until these problems are resolved"; return 1; }
  # check for the working directory
  _checkHome || { _error "cannot run without a working environment"; return 1;  }
  # enter custom shell if no arguments
  [ -z "${_subCommand:-}" ] && _shell
  # otherwise, pass the commands to the called "command"
  [[ -n "${_subCommand:-}" ]] && _debug "now calling the eval to run '${_subCommand:-}'"
  [[ -n "${_subCommand:-}" ]] && eval _"${_subCommand}" || :
}
main "${@}"
