#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/notelos.git
# author: jason@bloom.us
# description: note taking tool

# STRICT SHELL
set -o errexit 
set -o nounset
set -o pipefail
IFS=$'\n\t'

###########################
# PREREQUISITES
###########################
 
# required external commands
_requiredCommands=(git tig fzf)

###########################
# LIBRARY
###########################

# source library commands and set up log/console
# use the library file from the same directory if possible
# otherwise, source it from the path
[[ -e "$(dirname $0)/notelos-lib.sh" ]] \
	&& source "$(dirname $0)/notelos-lib.sh" \
	|| source notelos-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

# default initial debugging and logging settings
# note: command line parameters can modify these
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=false

# instantiate the log/mesg functions with defaults (these will be re-initialized
# after reading positional parameters)
_fLOG

####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF
usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit
 -x      force standalone mode
 -t      tui (experimental)

alternate env settings:
 -a <name>  set the germ dir name to <name>
 -p <path>  set alternate base path

commands:
EOF
_printCommands
}

_printCommands() {
	cat <<  EOF
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database
 inspect             run tig on the germ git bare repo
 search              interactive search
 browse              read through the current source entities
 source              add and manipulate source
 pdf                 produce a pdf from notebook
EOF
}

_printInfo () {
  cat << EOF
germ takes simple notes and adds them to a git repo
EOF
}

####################################
# PARAMETER PROCESSING
####################################

_getOpts () {
	# preserve the initial positional parameters
	export _fullCommand="${@}"
	_debug "full command is '${_fullCommand}'"
	local OPTIND
	# do not allow names for notelos or self to be names of germ commands
	_isCommand() {
		local _allowed=true
		local _commandList
		_commandList=$(_printCommands | cut -f2 -d' ')
		for _command in ${_commandList}; do
      [[ "${_command}" = "${1}" ]] && _allowed=false 
    done
    [[ ${_allowed} = "true" ]] || return 1
  }
	while getopts ":hsdlxtva:p:" flag ; do
		case ${flag} in 
			h)
				_printInfo; _printUsage; exit 0
				;;
			a)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is    NOT a flag ($OPTARG)"; exit 1; }
				_isCommand "${OPTARG}" || { _error "'${OPTARG}' is not allowed (it is a command)"; exit 1; }
				_NAME=${OPTARG}
				_warn "using alt name '${_NAME}'"
				;;
			p)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_BASE=${OPTARG}
				_warn "using alt path '${_BASE}'"
				;;
 	    s)
				_debug "${FUNCNAME[0]}: enabling silent mode with flag -$flag"
 	      _SILENT=true
				;;
			d)
				_debug "${FUNCNAME[0]}: enabled debug mode with flag -$flag"
				_DEBUG=true
				;;
			l)
				_debug "${FUNCNAME[0]}: enabled log mode with flag -$flag"
				_LOG=true
				;;
			x)
        _debug "${FUNCNAME[0]}: running in standalone mode with -$flag"
        _MODE=standalone
        ;;
			t)
				_debug "${FUNCNAME[0]}: running experimental TUI mode"
				_TUI=true
				;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -${OPTARG}"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1)); OPTIND=1
	# preserve the full subcommand with its parameters
	export _subCommandParams="${@}"
	# look for the subcommand and check for its options
	while ((${#})); do
		case ${1} in
			help)
				_printInfo; _printUsage; exit 0
				;;
			add)
				_subCommand=$1; shift
				while getopts ":ibs:" flag; do
					case ${flag} in
						i)
							# inline add (no editor invoked)
							_debug "enabled inline mode"
							_inline=true
							_inlineString="${_subCommandParams#*add -i*}"
							_debug "inline string: '${_inlineString}'"
							;;
						b)
							# bulk add disables commit...this is a hack to allow bulk input
							# without commiting each one...behavior is not correct imo
							_debug "bulk add operation"
							_bulk=true
							;;
						s)
							# specify the source notebook for the add
							_debug "source specified '${OPTARG}'"
							_addTO="${OPTARG}"
							;;
						?)
				 			_error "${FUNCNAME}: unknown flag -${OPTARG}"; exit 1
							;;
					esac
				done
				return
				;;
			edit)
				_subCommand=$1; shift
				return
				;;
			create)
				_subCommand=$1; shift
				return
				;;
			inspect)
				_subCommand=$1; shift
				return
				;;
			status)
				_subCommand=$1
				return
				;;
			source)
				_subCommand=$1
				return
				;;
			pdf)
				_subCommand=$1
				return
				;;
			*)
				_error "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
  # get the name and absolute path of the calling script
  _selfNAME=$(basename "${BASH_SOURCE[0]}")
  _selfABSOLUTE=$(readlink -f "${BASH_SOURCE[0]}")
  _selfBASE=$(dirname "${_selfABSOLUTE}")
  _selfCALL=${0}
  _selfPWD=$(pwd)
	# determine mode (notelos-integrated or standalone)
	[[ -n "${_notelosHOME+x}" && ${_MODE:-} != "standalone" ]] && _MODE=integrated || _MODE=standalone
	# note: the -x switch overrides the global _notelosHOME var 
	# set up the working environment
	if [[ ${_MODE} = "integrated" ]]; then
		# set up integrated mode
		_MASTER="${_notelosNAME}"
		_BASE="${_notelosHOME}"
		_NAME="${_NAME:-germ}"
		_HOME="${_BASE}/${_NAME}"
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/.log/${_NAME}.log"
		# inherit these (from notelos)
		_DEBUG=${_notelosDEBUG}
		_LOG=${_notelosLOG}
		_SILENT=${_notelosSILENT}
		_USERNAME=${_notelosUSERNAME}
		_USERFULLNAME=${_notelosUSERFULLNAME}
		_USEREMAIL=${_notelosUSEREMAIL}
		_EDITOR=_notelosEdit
	else
		# set up standalone mode
		_MASTER=self
		_BASE="${_BASE:-$HOME}"
		_NAME="${_NAME:-germ}"
		_HOME=${_BASE}/${_NAME}
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/${_NAME}.log"
		# inherit these
		_DEBUG=${_DEBUG:-false}
		_LOG=${_LOG:-false}
		_SILENT=${_SILENT:-false}
		_USERNAME=$(whoami)
		_USERFULLNAME="unknown"
		_USEREMAIL="unknown"
		_EDITOR=${EDITOR:-nano}
	fi
  [[ -f "${_LOGFILE:-}" ]] && _LOGGING=true || _LOGGING=false
	_debug "$(declare -p _MODE)"
	_debug "$(declare -p _MASTER)"
	_debug "$(declare -p _NAME)"
	_debug "$(declare -p _BASE)"
	_debug "$(declare -p _HOME)"
	_debug "$(declare -p _USERNAME)"
	_debug "$(declare -p _USERFULLNAME)"
	_debug "$(declare -p _USEREMAIL)"
	_debug "$(declare -p _GITDIR)"
	_debug "$(declare -p _LOGFILE)"
	_debug "$(declare -p _DEBUG)"
	_debug "$(declare -p _SILENT)"
	_debug "$(declare -p _LOG)"
	_debug "$(declare -p _LOGGING)"
	export _HOME
	export _GITDIR
	export _DEBUG
	export _LOG
	export _SILENT
}

_checkExternalTools() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			: #_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}

_checkHome() {
  # check if the home dir exists
  # check if it is a germ-created git
  # return 1 if missing or not git
  # mind condition: if subcommand is create
	[[ ! -d "${_BASE}" && ${_MODE} = "notelos" ]] && { _error "notelos base not found"; exit 1; }
	[[ -d "${_BASE}" ]] || { _error "base '${_BASE}' does not exist"; exit 1; }
	local _base="${_BASE}"
	local _dirName="${_NAME}"
	local _dirPath="${_HOME}"
	local _git_desc="${_dirPath}/.git/description"
  if [ -d "${_dirPath}" ]; then
    if [ -f "${_git_desc}" ]; then
      # the git description file exists, lets check it for our marker
      read -r _desc < "${_git_desc}"
			if [[ ${_desc} == ${_MASTER}:${_NAME}:${_USERNAME}* ]]; then
        # if repo does exist, return 0
        _debug "${_git_desc} = ${_desc}"
				# check and create sets directory if it doesn't exist
        if [[ ! -d "${_HOME}/.sets" ]]; then
          mkdir "${_HOME}/.sets"
          git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/.sets"
          git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[sets] initialize notebook sets directory"
          _debug "created sets directory at ${_HOME}/.sets"
        fi
				return
      else
        # if repo does not exist, warn and exit
        _error "${_dirPath} exists and is NOT a studio-created repo"
        return 1
      fi
    else
      _error "${_dirPath} exists and is NOT a git repo"
      _error "move existing ${_dirPath} before proceeding"
      return 1
    fi
  else
    # dir does not exist
    _warn "'${_dirPath}' does not exist"
    read -rsn1 -p "$(_ask 'create repo now? [y/n]')" _yn
    echo
    [[ ${_yn} != "y" ]] && { _warn "cannot run without a repo"; return 1;  }
    _create || { _error "could not create ${_dirName} repo"; return 1; }
    return
  fi
}

############################
# CREATE
############################

_create() {
	# do not overwrite an existing anything
	[[ -d "${_HOME}" ]] && { _error "'${_HOME}' exists"; return 1; }
	[ ! -d "${_HOME}" ] && mkdir "${_HOME}"
	git init -q -b main "${_HOME}"
  git -C "${_HOME}" config user.name "${_USERNAME}"
  git -C "${_HOME}" config user.email "${_USEREMAIL}"
	# create sets directory
  mkdir "${_HOME}/.sets"
	# make the default notebook (aka "source")
	mkdir "${_HOME}/default"
	echo "default source (notebook, project, etc)" > "${_HOME}/default/.description"
	git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/.sets"
	echo "default" > "${_HOME}/.current"
	echo ".current" > "${_HOME}/.gitignore"
	echo ".${_NAME}_history" >> "${_HOME}/.gitignore"
  git -C "${_HOME}" --git-dir="${_GITDIR}" add .gitignore
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/default/.description" 
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[genesis] ${_NAME} created by ${_USERNAME}"
	# put the installed signature in git description file
  _gitInitial=$(git -C "${_HOME}" rev-parse --short --verify main)
  _time=$(date +%s)
  printf "${_MASTER}:${_NAME}:${_USERNAME}:${_time}:${_gitInitial}\n" >      "${_HOME}/.git/description"
}

##################################
# INSPECT
##################################

_inspect() {
	tig -C ${_GITDIR}
}

##################################
# ADD
##################################

_add() {
	# add a new entry
	local _currentSource=$(_getSource)
	local _commitMsg
	# determine if the source notebook has been declared in positional parameters
	if [[ -z ${_addTO:-} ]]; then
		# it was not specified, therefore use "current"
		_useSource=${_currentSource}
	else
		_useSource=${_addTO}
	fi
	# determine the destination for the file to write
	local _dir="${_HOME}/${_useSource}"
	local _key=$(_getNewKey)
	local _file="${_dir}/${_key}"
	# check for piped standard input
	if [ ${_inline:-null} = "true" ]; then
		# note that pipe input takes priority over message appended to 'add -i'
		if [ -p /dev/stdin ]; then
			cat < /dev/stdin > "${_file}"
		else
			[ -z "${_inlineString}" ] && { _error "${FUNCNAME}: 'add -i' cannot contain an empty message"; return 1; }
			echo "$(_trimString ${_inlineString})" > "${_file}"
		fi
	else
		# catch pipe in without -i
		[ -p /dev/stdin ] && { _error "use 'add -i' for pipe input"; return 1; }
		# maybe we don't need the -i?
		# now just use the editor as usual
		${_EDITOR} "${_file}"
	fi
	[[ -e "${_file}" ]] || return
	_commitMsg=$(_buildCommitMsg "$(cat "${_file}")")
	_doCommit "${_useSource}/${_key}" "[add to ${_useSource}] ${_commitMsg}"
}

_trimString() {
	# Usage: trim_string "   example   string    "
	# source https://github.com/dylanaraps/pure-bash-bible
	: "${1#"${1%%[![:space:]]*}"}"
	: "${_%"${_##*[![:space:]]}"}"
	printf '%s\n' "$_"
}

_getNewKey() {
	# print the key (unixseconds.nano)
	echo "$(date +%s.%N)"
}

_buildCommitMsg() {
	# arg 1 = string [required]
	# read string (the whole blob) line by line
	# construct git commit message string (combining lines until max exceeded)
	# truncate if necessary and append with "..."
	# total character count <=75
	# print string or return 1
	local _maxLength=60
	local _commitMsgString=
	local _lines
	# empty string not allowed
	[ -z "${1:-}" ] && return 1
	# count lines
	l="${1//[!$'\n']/}"
	_lines=$((${#l} + 1))
	# process multi-line entries
	while read -r line; do
		# single line entry, set and break
		if [ ${_lines} = 1 ]; then
			_commitMsgString="${1}"
			break
		fi
		words=($line)
		# one word lines
		if [[ ${#words[@]} = 1 ]]; then
			# if the commit message string is empty
			if [[ -z "${_commitMsgString}" ]]; then
				_commitMsgString+="${line%% *}:"
			elif [[ ${_commitMsgString:(-1)} = ":" ]]; then
				_commitMsgString+=" ${line%% *}"
			else
				_commitMsgString+="; ${line%% *}"
			fi
		# empty lines
		elif [[ ${#words[@]} = 0 ]]; then
			true
		# multi-word lines
		else
			if [[ ${_commitMsgString:(-1)} = ":" ]]; then
				# first line after first-word+colon
				_commitMsgString+=" ${line}"
			elif [[ -z "${_commitMsgString}" ]]; then
				# first slot in empty commit message string
				_commitMsgString+="${line}:"
			else
				# insert semi-colon to designate new line
				_commitMsgString+="; ${line}"
			fi	
		fi
		# once we have exceeded the maxLength...stop processing
		if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
			break
		fi
	done < <(printf '%s\n' "${1}")
	# truncate if necessary, appending elipsis to indicate truncation
	if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
		_commitMsgString="${_commitMsgString:0:${_maxLength}}..."
	fi
	# this should never occur...
	[ -z "${_commitMsgString}" ] && return 1
	# return the final string...with echo (should be using the indirect variable
	# here
	echo "${_commitMsgString}"
}

_doCommit() {
	_newFile="${1}"
	_commitMsg="${2}"
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_newFile}"  
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "${_commitMsg}"
}	

_isIndexClean() {
	git -C "${_HOME}" --git-dir="${_GITDIR}" diff-index --quiet --cached main 2>&1 >/dev/null || return 1
}

################
# SOURCE
################

_getSource() {
	# print the current SOURCE
	! _isSourceSet && { echo "default"; return; }
	cat "${_HOME}/.current"
}
export -f _getSource

_isSourceSet() {
	# return 0 if true
	# return 1 if false
	[[ -e "${_HOME}/.current" ]]
}
export -f _isSourceSet

_doesSourceExist() {
	# return 0 if true (yes)
	# return 1 if false (no)
	[[ -d "${_HOME}/${1}" ]]
}
export -f _doesSourceExist

_doesNameExist () {
    # Check if the name exists by type (source, index, set)
    # $1 = name type (source, index, set)
    # $2 = name to check
    # Return 0 if true (exists), 1 if false (does not exist)

    local _nameType=${1}
    local _name=${2}

    case "${_nameType}" in
        source)
            # Check if the source directory exists
            [[ -d "${_HOME}/${_name}" ]] && return 0 || return 1
            ;;
        index)
            # Check if the index directory exists for the current source
            local _currentSource=$(_getSource)
            local _indexDir="${_HOME}/${_currentSource}/.index/${_name}"
            [[ -d "${_indexDir}" ]] && return 0 || return 1
            ;;
        set)
            # Check if the set directory exists in .sets
            local _setDir="${_HOME}/.sets/${_name}"
            [[ -d "${_setDir}" ]] && return 0 || return 1
            ;;
        *)
            # Invalid name type
            _error "Invalid name type: '${_nameType}'"
            return 1
            ;;
    esac
}
export -f _doesNameExist

_setSource() {
	# arg 1 = new source
	# check if source is set, if so, remove
	# then set to new
	[ -z "${1:-}" ] && return 1
	_isSourceSet && echo "${1}" > "${_HOME}/.current"
	export _currentSource=${1}
}
export -f _setSource

_saveSource() {
	# arg 1 = source name
	# arg 2 = source description
	mkdir "${_HOME}/$1"
	echo "${2}" > "${_HOME}/$1/.description"
}
export -f _saveSource

_listSetMembers() {
  # List all members of a given set
  # $1 = set name
  local _setName="${1:-}"
  local _setDir="${_HOME}/.sets/${_setName}"

  # Validate the set name
  if [[ -z "${_setName}" || ! -d "${_setDir}" ]]; then
    _warn "set '${_setName}' does not exist."
    return 1
  fi

  # Find all symbolic links in the set directory and resolve them
  local _setMembers=()
  while IFS= read -r -d '' link; do
    local _resolvedPath
    _resolvedPath=$(readlink -f "${link}")
    _setMembers+=("$(basename "${_resolvedPath}")")
  done < <(find "${_setDir}" -mindepth 1 -maxdepth 1 -type l -print0)

  # Sort the set members based on the current order
  if _isSearchReversed; then
    printf "%s\n" "${_setMembers[@]}" | sort -r
  else
    printf "%s\n" "${_setMembers[@]}" | sort
  fi
}
export -f _listSetMembers

_getSourceList() {
  # Determine the current view (all, sources, sets, smart)
  # optional $1 sets _view
  local _view=${1:-$(_getSourceView)}
  local _notebooksDir="${_HOME}"
  local _setsDir="${_HOME}/.sets"
  local _sources=()
  local _sets=()
  local _setItems=()

  # Collect sources if the view is "sources", "all", or "smart"
  if [[ "${_view}" == "sources" || "${_view}" == "all" || "${_view}" == "smart" ]]; then
    if [[ -d "${_notebooksDir}" ]]; then
      while IFS= read -r -d '' notebook; do
        _sources+=("$(basename "${notebook}")")
      done < <(find "${_notebooksDir}" -mindepth 1 -maxdepth 1 -type d -not -name ".*" -not -name ".sets" -print0)
    fi
  fi

  # Collect sets and their members if the view is "sets", "all", or "smart"
  if [[ "${_view}" == "sets" || "${_view}" == "all" || "${_view}" == "smart" ]]; then
    if [[ -d "${_setsDir}" ]]; then
      while IFS= read -r -d '' set; do
        local setName
        setName=$(basename "${set}")
        local setItems=()
        while IFS= read -r -d '' link; do
          setItems+=("$(basename "$(readlink -f "${link}")")")
        done < <(find "${set}" -mindepth 1 -maxdepth 1 -type l -print0)
        _setItems+=("${setItems[@]}") # Accumulate all set members
        _sets+=("${setName}[${#setItems[@]}]") # Add plain set name for sorting
      done < <(find "${_setsDir}" -mindepth 1 -maxdepth 1 -type d -print0)
    fi
  fi

  # Handle "smart" view
  if [[ "${_view}" == "smart" ]]; then
    local _filteredSources=()
    for source in "${_sources[@]}"; do
      if [[ ! " ${_setItems[*]} " =~ " ${source} " ]]; then
        _filteredSources+=("${source}")
      fi
    done

    # Combine filtered sources and sets
    local _combined=("${_filteredSources[@]}" "${_sets[@]}")
    local _sortedCombined
    _sortedCombined=$(printf "%s\n" "${_combined[@]}" | sort)
    if _isSearchReversed; then
      _sortedCombined=$(echo "${_sortedCombined}" | tac)
    fi

    # Reapply colorization to sets
    while IFS= read -r item; do
      if [[ "${item}" =~ \[.*\]$ ]]; then
        # Colorize sets
	      echo -e "\e[38;2;33;162;105m${item}\e[0m" # Apply ASCII color #21a269
      else
        # Print sources without color
        echo "${item}"
      fi
    done <<< "${_sortedCombined}"
    return
  fi

  # Handle "sources" view
  if [[ "${_view}" == "sources" ]]; then
    local _sortedSources
    _sortedSources=$(printf "%s\n" "${_sources[@]}" | sort)
    if _isSearchReversed; then
      _sortedSources=$(echo "${_sortedSources}" | tac)
    fi
    printf "%s\n" "${_sortedSources}"
    return
  fi

  # Handle "sets" view
  if [[ "${_view}" == "sets" ]]; then
    local _sortedSets
    _sortedSets=$(printf "%s\n" "${_sets[@]}" | sort)
    if _isSearchReversed; then
      _sortedSets=$(echo "${_sortedSets}" | tac)
    fi
    while IFS= read -r set; do
      echo -e "\e[92m${set}\e[0m"
    done <<< "${_sortedSets}"
    return
  fi

  # Handle "all" view
  if [[ "${_view}" == "all" ]]; then
    local _combined=("${_sources[@]}" "${_sets[@]}")
    local _sortedCombined
    _sortedCombined=$(printf "%s\n" "${_combined[@]}" | sort)
    if _isSearchReversed; then
      _sortedCombined=$(echo "${_sortedCombined}" | tac)
    fi
    while IFS= read -r item; do
      if [[ "${item}" =~ \[.*\]$ ]]; then
        # Colorize sets
	      echo -e "\e[38;2;33;162;105m${item}\e[0m" # Apply ASCII color #21a269
      else
        # Print sources without color
        echo "${item}"
      fi
    done <<< "${_sortedCombined}"
    return
  fi
}
export -f _getSourceList

_printSourceEntities() {
	# arg 1 = source
	ls "${_HOME}/${1}"
}
export -f _printSourceEntities

_getSourceCount() {
	# arg 1 = source
	local _count=0
	_count=$(_printSourceEntities ${1} | wc -l)
	echo "$_count"
}
export -f _getSourceCount

_browseSources () {
  # use _fzfBrowser to browse sources
  _fzfBrowser _sourcename _getSourceList _validateName source
	_debug "${FUNCNAME[0]}: selected source name: ${_sourcename}"
}

_cycleSourceView() {
  # File to store the current state
  local _stateFile="${_HOME}/.source_view_state"

  # Check if the state file exists; if not, create it with the default state "all"
  if [[ ! -f "${_stateFile}" ]]; then
    echo "all" > "${_stateFile}"
  fi

  # Read the current state from the file
  local _currentState
  _currentState=$(cat "${_stateFile}")

  # Determine the next state
  local _nextState
  case "${_currentState}" in
    all)
      _nextState="sources"
      ;;
    sources)
      _nextState="smart"
      ;;
		smart)
		_nextState="sets"
		;;
    sets)
      _nextState="all"
      ;;
    *)
      # Default to "all" if the state is invalid
      _nextState="all"
      ;;
  esac

  # Update the state file with the next state
  echo "${_nextState}" > "${_stateFile}"

}
export -f _cycleSourceView

_getSourceView() {
  # Prints the current source view (all, sources, smart, sets)
  local _stateFile="${_HOME}/.source_view_state"

  # Check if the state file exists; if not, create it with the default state "all"
  if [[ ! -f "${_stateFile}" ]]; then
    echo "all" > "${_stateFile}"
  fi

  # Read and return the current state
  cat "${_stateFile}"
}
export -f _getSourceView

_validateName(){
	# function used within fzf preview window to assist in the selection of names
	# used by fzf preview window during name selection of source, index, or set
	# $1 = query
	# $2 = selection
	# currently, all three have the same rules, but the display differs
	# read the FZF_PROMPT variable to determine the name type (source, index, set)
	# notice the prompt ends in ^> during reverse search view
	local _nameType=${FZF_PROMPT%%[>^]*}
	local _maxLength=25
	local _minLength=1
	local lengthStatus
	local avail
	local allowedChars="n/a"
	local lead="n/a"
	local last="n/a"
	local repeat="n/a"
	local acceptable="NO"

  # Dynamically adjust _nameType based on the input
  if [[ "${2}" =~ \[[0-9]+\]$ ]]; then
  	_nameType="set" # If the name ends with brackets, it's a SET
  fi

	_debug "FZF_PROMPT: ${FZF_PROMPT}"
	_debug "_nameType=${_nameType}"
	_debug "arg1=$1"
	_debug "arg2=$2"

	_cStat() {
		# arg 1 = key word
		# print the key word in a set color
		[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
		[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
		[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
		echo -n "${1}"
		tput sgr0 
	}
	export -f _cStat

	# validate the name first
	if [[ ${#1} -lt ${_minLength} ]]; then
		lengthStatus="TOO SHORT"
		avail="n/a"
	elif [[ ${#1} -gt ${_maxLength} ]]; then
		lengthStatus="TOO LONG"
		avail="n/a"
	else
		lengthStatus="OK"
		# check for name uniqueness (by type)
		_doesNameExist ${_nameType} "${1}" && { avail="NO"; acceptable="NO"; } || { avail="YES"; acceptable="YES"; }
	fi
	[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
	[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }

	_activeNameFeedback () {
		# print the validation info into the fzf preview window	
		echo "----VALID NAME?  $(_cStat ${acceptable}) --------------"
		[[ -z "${1}" ]] && echo "waiting for input..." || echo "name: '${1}'"
		printf "length [%.2d]: %31s\n" ${#1} "$(_cStat "${lengthStatus}")"
		printf "unique: %36s\n" "$(_cStat "${avail}")"
		printf "character set allowed: %21s\n" "$(_cStat "${allowedChars}")"
		printf "first ['%s'] allowed: %23s\n" "${1:0:1}" "$(_cStat "${lead}")"
		printf "last ['%s'] allowed: %24s\n" "${1:(-1)}" "$(_cStat "${last}")"
		printf "no non-alpha/num repeats: %18s\n" "$(_cStat "${repeat}")"
		echo
		echo "-----------RULES------------------"
		# print these in grey
		echo -e "\e[2m  the name must be unique"
		echo "  max length is ${_maxLength}, min is ${_minLength}"
		echo "  lower case and numbers only"
		echo "  non alpha-numeric characters allowed:"
		echo "   - dash (-)"
		echo "   - underscore (_)"
		echo "   - dot (.)"
		echo "   ^ these cannot be first or last"
		echo -e "   ^ cannot be repeated (eg --)\e[0m]" #reset the color
		echo
	}
	export -f _activeNameFeedback

	[[ -z "${1}" ]] && echo -e "\e[5;33mwaiting for input...\e[0m\n"

	# ONLY show this when there is input (typing)
	[[ ! -z "${1}" ]] && _activeNameFeedback "${1}"

	# show this always
	if [[ "${_nameType}" == "source" ]]; then
		echo "------SELECTED SOURCE CONTENTS-----------"
		[[ -z "${2}" ]] && echo "free" || tree -Ca "${_HOME}/${2}"
	elif [[ "${_nameType}" == "index" ]]; then
		echo "------SELECTED INDEX CONTENTS-----------"
		[[ -z "${2}" ]] && echo "free" || tree -C "${_HOME}/${_currentSource}/.index/${2}"
	elif [[ "${_nameType}" == "set" ]]; then
	_setName="${2%\[*\]}"
		echo "------SELECTED SET CONTENTS-----------"
		[[ -z "${_setName}" ]] && echo "free" || tree -C "${_HOME}/.sets/${_setName}"
	fi
}
export -f _validateName

_previewSets () {
  # preview function for fzf to show set contents
  # extract the set name from $FZF_PROMPT
  local _setName
	# remove everything up to and including the first colon
  local after_colon="${FZF_PROMPT#*:}"
	# remove '>' or '^>' from the end
  if [[ "$after_colon" == *"^>" ]]; then
    _setName="${after_colon%^>}"
  else
    _setName="${after_colon%>}"
  fi

	_debug "${FUNCNAME[0]}: selected set name: ${_setName}"
  local _setDir="${_HOME}/.sets/${_setName}"
  if [[ -d "${_setDir}" ]]; then
  	echo "------SELECTED SET CONTENTS-----------"
    echo
    if [[ -z "$(find "${_setDir}" -mindepth 1 -maxdepth 1 -print -quit)" ]]; then
    	echo -e "\e[5;31mempty set!\e[0m"
  	else
    	# Print the tree contents (and highlight the selected file)
  		tree -C "${_setDir}" | sed "s|\(${1}\)|\x1b[1;31m\1\x1b[0m|"
    fi
  else
    echo "Set '${_setName}' does not exist."
  fi
}
export -f _previewSets



############################
# SET MANAGEMENT
############################

# source set functions
_createSet() {
  # Create a new set or select an existing one
  local _setName
  _fzfBrowser _setName _listSets _validateName set "1:create or select set"

  # abort if fzf returns null
  [[ ${_setName} = ":" ]] && { _warn "set creation aborted"; return; }
 
  # fzfBrowser returns "query:selection", so trim to selection only
  _setName=${_setName#*:}
  
  # Validate the selected or entered set name
  #if ! _isSourceNameValid "${_setName}"; then
  if ! _isNameValid set "${_setName}"; then
    _warn "invalid set name: '${_setName}'"
    return 1
  fi
  
  # Create the new set directory if it doesn't exist
  local _setPath="${_HOME}/.sets/${_setName}"
  if [[ ! -d "${_setPath}" ]]; then
    mkdir -p "${_setPath}"
    _info "set '${_setName}' created successfully"
		# these failed because _GITDIR isn't exported
    #git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_setPath}"
    #git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[sets] created set '${_setName}'"
  else
    _warn "set '${_setName}' already exists"
  fi
    
  # Set the current set
  export _currentSet="${_setName}"
  export _setViewMode=true
}
export -f _createSet

_deleteSet() {
  # Delete a set
  local _setName="${1:-}"
	# remove the bracketed count
	_setName="${_setName%\[*\]}"
  
  # Check if the set name is valid
  if [[ -z "${_setName}" || ! -d "${_HOME}/.sets/${_setName}" ]]; then
    _warn "'${_setName}' is not a set"
    return 1
  fi

  # Check if the set is empty
  local _setPath="${_HOME}/.sets/${_setName}"
  if [[ -z "$(find "${_setPath}" -mindepth 1 -maxdepth 1 -type l)" ]]; then
    # Set is empty, delete without confirmation
    rm -r "${_setPath}"
    _info "Set '${_setName}' deleted successfully"
    return 0
  fi

  # Set has members, prompt for confirmation
  _warn "set '${_setName}' is not empty:"
  find "${_setPath}" -mindepth 1 -maxdepth 1 -type l -exec basename {} \;
  read -r -p "$(_ask "delete the set anyway? [y/N] ")" _confirm
  if [[ "${_confirm}" =~ ^[Yy]$ ]]; then
    rm -r "${_setPath}"
    _info "set '${_setName}' deleted successfully"
  else
    _warn "deletion of set '${_setName}' aborted"
  fi
}
export -f _deleteSet

_listSets() {
  # List all sets
  if [[ -d "${_HOME}/.sets" ]]; then
    find "${_HOME}/.sets" -mindepth 1 -maxdepth 1 -type d -exec basename {} \;
  fi
}
export -f _listSets

_addToSet() {
  # Check if FZF_PROMPT indicates a set context
  if [[ ! "${FZF_PROMPT}" =~ ^set:.*\[[0-9]+\]\>$ ]]; then
    _warn "Not in a set context. Ignoring."
    return
  fi

  # Extract the set name from FZF_PROMPT
  local _set
  _set=$(echo "${FZF_PROMPT}" | sed -n 's/^set:\(.*\)\[[0-9]\+\]>$/\1/p')

  # Validate the set name
  if [[ -z "${_set}" || ! -d "${_HOME}/.sets/${_set}" ]]; then
    _warn "Set '${_set}' does not exist. Ignoring."
    return
  fi

  # Create a symbolic link in the set directory
  local _sourceFile="${_HOME}/${1}"
  local _linkPath="${_HOME}/.sets/${_set}/$(basename "${_sourceFile}")"

  # Check if the source file exists
  if [[ ! -e "${_sourceFile}" ]]; then
    _warn "Source file '${_sourceFile}' does not exist. Ignoring."
    return
  fi

  # Check if the symbolic link already exists
  if [[ -L "${_linkPath}" ]]; then
    _warn "File '${1}' is already in the set '${_set}'."
    return
  fi

  # Create the symbolic link as a relative path
  ln -s "$(realpath --relative-to="${_HOME}/.sets/${_set}" "${_sourceFile}")" "${_linkPath}"
  _info "Added '${1}' to set '${_set}'."
}
export -f _addToSet

_removeFromSet() {
  # Check if FZF_PROMPT indicates a set context
  if [[ ! "${FZF_PROMPT}" =~ ^set:.*\[[0-9]+\]\>$ ]]; then
    _warn "Not in a set context. Ignoring."
    return
  fi

  # Extract the set name from FZF_PROMPT
  local _set
  _set=$(echo "${FZF_PROMPT}" | sed -n 's/^set:\(.*\)\[[0-9]\+\]>$/\1/p')

  # Validate the set name
  if [[ -z "${_set}" || ! -d "${_HOME}/.sets/${_set}" ]]; then
    _warn "Set '${_set}' does not exist. Ignoring."
    return
  fi

  # Determine the symbolic link path
  local _linkPath="${_HOME}/.sets/${_set}/$(basename "${1}")"

  # Check if the symbolic link exists
  if [[ ! -L "${_linkPath}" ]]; then
    _warn "File '${1}' is not in the set '${_set}'."
    return
  fi

  # Remove the symbolic link
  rm "${_linkPath}"
  _info "Removed '${1}' from set '${_set}'."
}
export -f _removeFromSet


# new unified fzf browser function for individual notebooks
_fzfBrowser () {
	# all germ notebook functions call this function
	# the following arguments set the initial context
	# $1 = nameref for return value
	# $2 = input function (prints the list of existing whatever)
	# $3 = validation function for fzf preview window (in which $1=query $2=selection)
	# $4 = initial prompt string or function
	# $5 = optional special instructions
	local -n _return=$1
	local _input=$2
	local _preview=$3
	export _prompt=$4
	export _instructions="${5:-1:select source,2:? for help}"
	# we need to use unique ID to avoid state conflicts
	local _uniqueID=$$
	export _fzfHeaderState="${_HOME}/.fzfHeaderState.${_uniqueID}"

  # define a cleanup function for extensibility
	# NOTE to run for example a trap limited to the fzf process, we would need to run
	# fzf within a subshell; currently the scope is global
	# this way, however, makes the state file persistent
	_cleanup() {
		# Log the call stack using FUNCNAME
		local call_stack=""
		for ((i = 0; i < ${#FUNCNAME[@]}; i++)); do
			call_stack+="[${i}] ${FUNCNAME[$i]} -> "
		done
		call_stack+="END"
	
		# Log or debug the call stack
		_debug "${FUNCNAME[0]}: cleanup called by ${call_stack}"
	
		# Remove the .source_view_state file if it exists
		[[ -f "${_HOME}/.source_view_state" ]] && rm -f "${_HOME}/.source_view_state"
		_debug "${FUNCNAME[0]}: cleanup removed .source_view_state file"

		# remove the header state file if it exists
    [[ -f "${_fzfHeaderState}" ]] && rm -f "${_fzfHeaderState}"
    _debug "${FUNCNAME[0]}: cleanup removed ${_fzfHeaderState}"
   
	}

  # set a trap to call the cleanup function when germ exits
  trap _cleanup RETURN

	_toggleShowAll() {
		# Toggle the _showAll state
		if [[ "${_showAll:-false}" == "true" ]]; then
			_showAll=false
			_debug "showAll is false"
		else
			_showAll=true
			_debug "showAll is true"
		fi
		export _showAll
	}
	export -f _toggleShowAll

	_toggleSearchOrder() {
	  # Check the FZF_PROMPT string
	  # SOURCE^> indicates reverse order
	  # SOURCE> indicates normal order
	  # Print the opposite of what is found in FZF_PROMPT

	  if [[ "${FZF_PROMPT}" =~ ^(source:|set:)?[[:alnum:]._-]+(\[[[:alnum:]._-]+\])?\^\>(\ ?)$ ]]; then
	    # Reverse order
	    echo "${FZF_PROMPT//\^>/}>"
	  else
	    # Normal order
	    echo "${FZF_PROMPT//>/^>}"
	  fi
	}
	export -f _toggleSearchOrder

	_isSearchReversed() {
	  # Function to determine search order
	  # Check the FZF_PROMPT string
	  # SOURCE^> indicates reverse order
	  # SOURCE> indicates normal order

	  if [[ "${FZF_PROMPT}" =~ ^(source:|set:)?[[:alnum:]._-]+(\[[[:alnum:]._-]+\])?\^\>$ ]]; then
	    return 0 # Reverse order
	  else
	    return 1 # Normal order
	  fi
	}
	export -f _isSearchReversed


	_setPrompt() {
  	# Set the FZF prompt dynamically based on the current source and index
  	local _currentSource=$(_getSource) # Get the current source
  	local _indexFile="${_HOME}/${_currentSource}/.current" # Path to the .current file
		local _existingPrompt="${FZF_PROMPT}"
  	local _newPrompt

		# check if the prompt is already set
		if [[ "${_existingPrompt:-}" =~ ^.*\>\ ?$ ]]; then
			# FZF_PROMPT is not set, use the provided string or function
			# check if $_prompt is a function name
 	 		if ! declare -F "$_prompt" >/dev/null; then
				# if not, use the string provided, and return
				_newPrompt="${_prompt}"
				echo "${_newPrompt}>"
				return
			else
				# prompt is already set, set the base from it
				_newPrompt="${_currentSource}"
			fi
		fi

  	# Append the current index to the prompt if it exists
  	if [[ -f "${_indexFile}" ]]; then
    	local _currentIndex
    	_currentIndex=$(cat "${_indexFile}")
    	_newPrompt="${_newPrompt}[${_currentIndex}]"
  	else
    	_newPrompt="${_newPrompt}"
  	fi

		echo "${_newPrompt}>" # Output the prompt string with a space
	}
	export -f _setPrompt

# update the header in _fzfBrowser
# create an associative array called _headerLines
# check for state file _fzfHeaderState
# if it exists, read the lines into _headerLines, the line number in
# the file determines the index in the _headerLines array
# otherwise, read $1
# the arg is one string with comma separated fields
# each field contains the prefix number followed by colon followed by the message
# example field: "1:line one"
# example $1 string: "1:line one,2:line two,4:line four,5:""
# this line should update lines 1, 2, and 4, preserve 3, and remove 5
# if there are no args, update _fzfHeaderState with default values
# local _lineOne="context"
# local _lineTwo="? for help"
# if there is an arg, read and process it into an indexed list
# (_headerLines), with the prefix number as the index and the string
# as the value.
# when _transHeader runs, it will look for the _fzfHeaderState file first
# and populate the index list, then it will up update that list with
# the fields used in the arg
# if line 2 is removed with "2:" the header text shall only be 2 lines, ie
# no blank line will be left between 1 and 3.
# once the lines are worked out, the _fzfHeaderState should be updated
# then the function needs to colorize and print the lines.
# line 1: context (plain text)
# line 2: help (yellow text)
# line 3: response to keys (magenta italic text)
# line 4: status from last action (green) 
# line 5: fzf debug (cyan) [only prints when "5:message" is added to arg string]
# line 6: is special, it prints $FZF_KEY:FZF_ACTION (cyan) [always prints in _DEBUG]
# line 5 and 6 should only be printed if _DEBUG=true
# color for lines 5 and 6, use \033[38;2;42;161;179

_transHeader() {
    # Path to the state file
    #local _fzfHeaderState="${_HOME}/.fzfHeaderState"

    # Declare an associative array to store the header lines
    declare -A lines

    # Read the current header from the state file or initialize it with passed values
    if [[ -f "${_fzfHeaderState}" ]]; then
        # Read the state file into the associative array `lines`
        while IFS=: read -r key value; do
            lines["$key"]="$value"
        done < "${_fzfHeaderState}"
    else
			# or read them from _instructions (passed to _fzfBrowser or defaults)
			IFS=',' read -r -a fields <<< "${_instructions}"
			# Initialize the header lines with default values
			for field in "${fields[@]}"; do
				if [[ "$field" =~ ^([0-9]+):(.*)$ ]]; then
					local line_number="${BASH_REMATCH[1]}" # Line number (1-based)
					local line_content="${BASH_REMATCH[2]}" # Line content
					# Update the corresponding line in the associative array
					lines["$line_number"]="$line_content"
				fi
			done
    fi

    # Process the function input arguments (e.g., "1:content,2:content")
    local input="${1:-}"
    IFS=',' read -r -a fields <<< "$input"
    for field in "${fields[@]}"; do
        if [[ "$field" =~ ^([0-9]+):(.*)$ ]]; then
            local line_number="${BASH_REMATCH[1]}" # Line number (1-based)
            local line_content="${BASH_REMATCH[2]}" # Line content
            # Update the corresponding line in the associative array
            lines["$line_number"]="$line_content"
        fi
    done

    # Remove empty lines (e.g., if "2:" was passed)
    for key in "${!lines[@]}"; do
        if [[ -z "${lines[$key]}" ]]; then
            unset lines["$key"]
        fi
    done

    # Write the updated header back to the state file
    {
        for key in $(seq 1 6); do
            [[ -n "${lines[$key]:-}" ]] && printf "%s:%s\n" "$key" "${lines[$key]}"
        done
    } > "${_fzfHeaderState}"

    # Apply formatting and print the updated header for fzf
    {
        for key in $(seq 1 5); do
            if [[ -n "${lines[$key]:-}" ]]; then
                case "$key" in
                    1) printf "%s\n" "${lines[$key]}" ;;
                    2) printf "\033[38;5;11m%s\033[0m\n" "${lines[$key]}" ;;
                    3) printf "\033[3;38;5;13m%s\033[0m\n" "${lines[$key]}" ;;
                    4) printf "\033[38;5;10m%s\033[0m\n" "${lines[$key]}" ;;
                    5) [[ "${_DEBUG}" == "true" ]] && printf "\033[38;2;42;161;179m%s\033[0m\n" "${lines[$key]}" ;;
                esac
            fi
        done
        [[ "${_DEBUG}" == "true" ]] && printf "\033[38;2;42;161;179m%s:%s\033[0m\n" "$FZF_KEY" "$FZF_ACTION"
    }
}
export -f _transHeader

#_transHeader() {
#    # Path to the state file
#    local _fzfHeaderState="${_HOME}/.fzfHeaderState"
#
#    # Declare an associative array to store the header lines
#    declare -A lines
#
#    # Read the current header from the state file if it exists
#    if [[ -f "${_fzfHeaderState}" ]]; then
#        # Populate the `lines` array from the state file
#        while IFS=: read -r key value; do
#            lines["$key"]="$value"
#        done < "${_fzfHeaderState}"
#    else
#        # If no state file exists, initialize from `_instructions`
#        IFS=',' read -r -a fields <<< "${_instructions}"
#        for field in "${fields[@]}"; do
#            if [[ "$field" =~ ^([0-9]+):(.*)$ ]]; then
#                local line_number="${BASH_REMATCH[1]}" # Line number (1-based)
#                local line_content="${BASH_REMATCH[2]}" # Line content
#                # Populate the `lines` array
#                lines["$line_number"]="$line_content"
#            fi
#        done
#    fi
#
#    # Process the function input arguments (e.g., "1:content,2:content")
#    local input="${1:-}"
#    IFS=',' read -r -a fields <<< "$input"
#    for field in "${fields[@]}"; do
#        if [[ "$field" =~ ^([0-9]+):(.*)$ ]]; then
#            local line_number="${BASH_REMATCH[1]}" # Line number (1-based)
#            local line_content="${BASH_REMATCH[2]}" # Line content
#            # Update the corresponding line in the associative array
#            lines["$line_number"]="$line_content"
#        fi
#    done
#
#    # Remove empty lines (e.g., if "2:" was passed)
#    for key in "${!lines[@]}"; do
#        if [[ -z "${lines[$key]}" ]]; then
#            unset lines["$key"]
#        fi
#    done
#
#    # Write the updated header back to the state file
#    {
#        for key in $(seq 1 6); do
#            [[ -n "${lines[$key]:-}" ]] && printf "%s:%s\n" "$key" "${lines[$key]}"
#        done
#    } > "${_fzfHeaderState}"
#
#    # Apply formatting and print the updated header for fzf
#    {
#        for key in $(seq 1 6); do
#            if [[ -n "${lines[$key]:-}" ]]; then
#                case "$key" in
#                    1) printf "%s\n" "${lines[$key]}" ;; # Plain text
#                    2) printf "[\033[38;5;11m%s\033[0m]\n" "${lines[$key]}" ;; # Yellow text in brackets
#                    3) printf "\033[3;38;5;13m%s\033[0m\n" "${lines[$key]}" ;; # Magenta italic text
#                    4) printf "\033[38;5;10m%s\033[0m\n" "${lines[$key]}" ;; # Green text
#                    5) [[ "${_DEBUG}" == "true" ]] && printf "\033[38;2;42;161;179m%s\033[0m\n" "${lines[$key]}" ;; # Cyan text (only if _DEBUG=true)
#                    6) [[ "${_DEBUG}" == "true" ]] && printf "\033[38;2;42;161;179m%s:%s\033[0m\n" "$FZF_KEY" "$FZF_ACTION" ;; # Cyan text (always if _DEBUG=true)
#                esac
#            fi
#        done
#    }
#}
#export -f _transHeader

#_transHeader() {
#    # Path to the state file
#    local _fzfHeaderState="${_HOME}/.fzfHeaderState"
#
#    # Declare an associative array to store the header lines
#    declare -A _headerLines
#
#		# Initialize the header lines with default values
#    _headerLines[1]="context"
#    _headerLines[2]="? for help"
#
#    # Read the current header from the state file
#    if [[ -f "${_fzfHeaderState}" ]]; then
#        # Read the state file into the associative array `_headerLines`
#        while IFS=: read -r key value; do
#            _headerLines["$key"]="$value"
#        done < "${_fzfHeaderState}"
#    fi
#
#    # Process the input arguments (e.g., "1:content,2:content")
#    local input="${1:-}"
#    IFS=',' read -r -a fields <<< "$input"
#    for field in "${fields[@]}"; do
#        if [[ "$field" =~ ^([0-9]+):(.*)$ ]]; then
#            local line_number="${BASH_REMATCH[1]}" # Line number (1-based)
#            local line_content="${BASH_REMATCH[2]}" # Line content
##            # Update the corresponding line in the associative array
#            _headerLines["$line_number"]="$line_content"
#        fi
#    done
#
#    # Remove empty lines (e.g., if "2:" was passed)
#    for key in "${!_headerLines[@]}"; do
#        if [[ -z "${_headerLines[$key]}" ]]; then
#            unset _headerLines["$key"]
#        fi
#    done
#
#    # Write the updated header back to the state file
#    {
#        for key in $(seq 1 5); do
#            [[ -n "${_headerLines[$key]:-}" ]] && printf "%s:%s\n" "$key" "${_headerLines[$key]}"
#        done
#    } > "${_fzfHeaderState}"
#
#    # Apply formatting and print the updated header for fzf
#    {
#        for key in $(seq 1 6); do
#            if [[ -n "${lines[$key]:-}" ]]; then
#                case "$key" in
#                    1) printf "%s\n" "${lines[$key]}" ;; # Plain text
#                    2) printf "[\033[38;5;11m%s\033[0m]\n" "${lines[$key]}" ;; # Yellow text in brackets
#                    3) printf "\033[3;38;5;13m%s\033[0m\n" "${lines[$key]}" ;; # Magenta italic text
#                    4) printf "\033[38;5;10m%s\033[0m\n" "${lines[$key]}" ;; # Green text
#                    5) [[ "${_DEBUG}" == "true" ]] && printf "\033[38;2;42;161;179m%s\033[0m\n" "${lines[$key]}" ;; # Cyan text (only if _DEBUG=true)
#                esac
#            fi
#        done
#        [[ "${_DEBUG}" == "true" ]] && printf "\033[38;2;42;161;179m%s:%s\033[0m\n" "$FZF_KEY" "$FZF_ACTION"
#    }
#}
#export -f _transHeader

# preview help window	
_showHelp() {
	printf '
 +-------------------------+---------------------------------+
 |       germ help         |     hit "/" to close help       |
 +-------------------------+---------------------------------+

 main navigation
 - alt-P   page up         - alt-H   half page up
 - alt-p   page down       - alt-h   half page down

 preview navigation
 - ctrl-[up|down]         scrolls the preview window
 - alt-shift-[up|down]    scrolls by half page
 - alt-[up|down]          scrolls to top/bottom
 
 search order (SOURCE^> = reverse)
 - alt-r 	 toggle search order 

 source management (notebooks)
 - ctrl-v    cycle view (all, sources, smart, sets)
 - ctrl-del  delete selected source

 index management (virtual notebook indexes)
 - alt-i   create a new index
 - alt-u   read the notebook without index
 - alt-a   append selected to current index
 - alt-D   delete selected from current index
 - alt-t   toggle view between all files and only non-linked ones

 set management (virtual collections of notebooks)
 - alt-s   create a new set or select an existing one
 - alt-S   delete selected set (alt-shift-s)
 - ctrl-s  manipulate selected set (add/remove)

'
}
# export functions to fzf (child)
export -f _showHelp

	# run the fzf loop, building the fzf command with an array
	while true; do
		# basic fzf defaults
		FZF_COMMAND=()
		FZF_COMMAND+=(--no-multi)				# limits to single selection
		FZF_COMMAND+=(--no-mouse)				# prevents mouse interaction
		FZF_COMMAND+=(--ansi)						# enables ansi color code processing
		FZF_COMMAND+=(--print-query)		# prints the query term as the first line
		FZF_COMMAND+=(--exact)					# enables exact-match

		# look and feel
		# main border style and color
		FZF_COMMAND+=(--style=full)			# all the borders
		FZF_COMMAND+=(--border=rounded)
		FZF_COMMAND+=(--margin=1%)	# sets the margin outside (T,R,B,L)
		FZF_COMMAND+=(--padding=1%,0%,1%,0%) # sets padding inside (T,R,B,L)
		FZF_COMMAND+=(--border-label="germ")	# sets the border label
		FZF_COMMAND+=(--border-label-pos=7)
		FZF_COMMAND+=(--color='border:#85846b,label:11')
		# header border
		FZF_COMMAND+=(--header-border)	# prints header border
		FZF_COMMAND+=(--header-label="guidance")	# sets the header label
		FZF_COMMAND+=(--color='header-border:#b8733b,header-label:#eeb71b')
		# the input field
		FZF_COMMAND+=(--ghost="type to filter")
		FZF_COMMAND+=(--input-label="search")
		FZF_COMMAND+=(--color='input-border:#21a269,input-label:#2ee66e')
		# the info-command inside the input border (includes command errors)
		FZF_COMMAND+=(--info=default)
		FZF_COMMAND+=(--info-command='echo -e "\x1b[33;1m$FZF_POS\x1b[m/$FZF_INFO ($FZF_KEY:$FZF_ACTION)"')
		# the list border
		FZF_COMMAND+=(--color='list-border:#073f6c,list-label:14,scrollbar:#85846b')
		FZF_COMMAND+=(--bind='result:transform-list-label(_getSource)')

		# the preview border
		FZF_COMMAND+=(--color='preview-border:#073f6c,preview-label:#c2c1b4,preview-scrollbar:#85846b')
		# the preview window
		FZF_COMMAND+=(--preview="${_preview} {q} {}")
		FZF_COMMAND+=(--preview-window=75%,wrap,border)
		FZF_COMMAND+=(--preview-border=top)
		FZF_COMMAND+=(--bind='focus:transform-preview-label:[[ -n {} ]] && printf "previewing:%s" {}')

		# prompt and instructions and initial list input
		FZF_COMMAND+=(--header="${_instructions}")
		# clean up header with each focus change
		FZF_COMMAND+=(--bind="focus:+transform-header(_transHeader '2:? for help,3:,4:')")
		FZF_COMMAND+=(--bind="start:reload(${_input})")	# loads using given _input function ($2)
		FZF_COMMAND+=(--bind="start:+transform-prompt(_setPrompt)")
		FZF_COMMAND+=(--bind="start:+transform-header(_transHeader '2:? for help')")

		# catch common keys and notify accordingly
		FZF_COMMAND+=(--bind="ctrl-c:transform-header(_transHeader '3:ESC to abort')")
		FZF_COMMAND+=(--bind="ctrl-q:transform-header(_transHeader '3:ESC to abort')")
		FZF_COMMAND+=(--bind="ctrl-z:transform-header(_transHeader '3:no ctrl-z,4:mess,5:debug')")
		FZF_COMMAND+=(--bind="backward-eof:transform-header(_transHeader '3:ESC to abort')")

		# key bindings for index creation
		FZF_COMMAND+=(--bind="alt-i:execute(_createIndex)")
		FZF_COMMAND+=(--bind="alt-i:+transform-prompt(_setPrompt)")
		FZF_COMMAND+=(--bind="alt-i:+reload(${_input})")
		FZF_COMMAND+=(--bind="alt-u:execute(_readRaw)")
		FZF_COMMAND+=(--bind="alt-u:+transform-prompt(_setPrompt)")
		FZF_COMMAND+=(--bind="alt-u:+reload(${_input})")

		# add selected file to index (simple append)
		FZF_COMMAND+=(--bind="alt-a:execute(_addToIndex {})")
		FZF_COMMAND+=(--bind="alt-a:+reload(${_input})")
		# remove selected file from index (and renumber)
		FZF_COMMAND+=(--bind="alt-D:execute(_removeFromIndex {})")
		FZF_COMMAND+=(--bind="alt-D:+reload(${_input})")
		# toggle between showing all files and only files without symbolic links
		FZF_COMMAND+=(--bind="alt-t:execute(_toggleShowAll)")
		FZF_COMMAND+=(--bind="alt-t:+reload(${_input})")

		# set management
		# create set
		FZF_COMMAND+=(--bind="alt-s:execute(_createSet)")
		FZF_COMMAND+=(--bind="alt-s:+reload(${_input})")
		# delete set
		FZF_COMMAND+=(--bind="alt-S:execute(_deleteSet {})")
		FZF_COMMAND+=(--bind="alt-S:+reload(${_input})")
		# manage set
		FZF_COMMAND+=(--bind="ctrl-s:transform-header(echo 'manage set')")
		FZF_COMMAND+=(--bind="ctrl-s:+transform-header-label(echo 'manage set')")
		FZF_COMMAND+=(--bind="ctrl-s:+transform-prompt(echo 'set:{}>')")
		FZF_COMMAND+=(--bind="ctrl-s:+transform-header(_transHeader '3:alt-right:add, alt-left:remove')")
		FZF_COMMAND+=(--bind="ctrl-s:+reload(_getSourceList 'sources')")
		FZF_COMMAND+=(--bind="ctrl-s:+change-preview(_previewSets {})")
		# bind alt-right and alt-left to functions (that are context aware)
		FZF_COMMAND+=(--bind="alt-right:execute(_addToSet {})+up")
		FZF_COMMAND+=(--bind="alt-left:execute(_removeFromSet {})+up")

		# the exit / abort command is ESC
		FZF_COMMAND+=(--bind="esc:abort")

		# main help (toggles preview and disables ESC)
		FZF_COMMAND+=(--bind="?:change-preview(_showHelp)")
		FZF_COMMAND+=(--bind="?:+unbind(esc)")
		FZF_COMMAND+=(--bind="?:+transform-header(_transHeader '3:/ to close help')")
		FZF_COMMAND+=(--bind="/:change-preview(${_preview} {q} {})")
		FZF_COMMAND+=(--bind="/:+rebind(esc)")
		FZF_COMMAND+=(--bind="/:+transform-header(_transHeader '3:')")

		# reverse the order of the list
		FZF_COMMAND+=(--bind="alt-r:transform-prompt(_toggleSearchOrder)")
		FZF_COMMAND+=(--bind="alt-r:+reload(${_input})")

		# source management
		# cycle the source viewer (all, sources, smart, sets)
		FZF_COMMAND+=(--bind="ctrl-v:execute(_cycleSourceView)")
		FZF_COMMAND+=(--bind="ctrl-v:+reload(${_input})")
		# delete selected source
		FZF_COMMAND+=(--bind="ctrl-delete:execute(_deleteSource {})")
		FZF_COMMAND+=(--bind="ctrl-v:+reload(${_input})+clear-query")
		
		# navigation shortcuts
		FZF_COMMAND+=(--bind="alt-P:page-up")
		FZF_COMMAND+=(--bind="alt-p:page-down")
		FZF_COMMAND+=(--bind="alt-H:half-page-up")
		FZF_COMMAND+=(--bind="alt-h:half-page-down")
		# shift-left to exit back or abort
		FZF_COMMAND+=(--bind="shift-left:abort")

		# make tab work like command completion
		FZF_COMMAND+=(--bind="tab:replace-query")

		# preview scrolling
		FZF_COMMAND+=(--bind="alt-shift-down:preview-half-page-down")
		FZF_COMMAND+=(--bind="alt-shift-up:preview-half-page-up")
		FZF_COMMAND+=(--bind="alt-down:preview-bottom")
		FZF_COMMAND+=(--bind="alt-up:preview-top")

		# enter selects with _selectEntry
		FZF_COMMAND+=(--bind="enter:execute(_selectEntry {} {q})")
		# this command runs until user aborts the sub-child _fzfBrowser
		FZF_COMMAND+=(--bind="enter:+reload(${_input})+clear-query")
		FZF_COMMAND+=(--bind="enter:+transform-header(_transHeader '3:' '2:? for help')")

		# assign the fzf results to _selection (what was "selected")
		_FZF_selection=$(fzf "${FZF_COMMAND[@]}")

		# split out the query string into $query
		query=$(echo "${_FZF_selection}" | head -n1)

		# assign the selection to $selection (note no MULTI SELECT yet)
		selection=$(echo "${_FZF_selection}" | tail -n1)
		_debug "${FUNCNAME[0]}: query is '${query}'"
		_debug "${FUNCNAME[0]}: selection is '${selection}'"

		# finally, return the two values into the nameref _return (colon-separated)
		_return="${query}:${selection}"
		break
	done 
}
export -f _fzfBrowser

_newSource() {
	# function to create a new source
	# $1 = name of the new source (optional)
	# if $1 is empty, run fzfBrowser to select the name
	local _newSource="${1:-}"
	if [[ -z "${_newSource}" ]]; then
		# run fzfBrowser to select the name
		_fzfBrowser _newSource _listSources _validateName source "1:create a new source"
		# always use the query here
		_newSource=${_newSource%%:*}
		[[ -z "${_newSource}" ]] && { _warn "empty names not allowed"; return; }
	fi
	_isNameValid source "${_newSource}" || { _error "'${_newSource}' is invalid"; return; }
	_getSourceDetails "${_newSource}" || { _warn "aborted adding new source"; return; }
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/${_newSource}/.description"
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] added ${_newSource}"
}
export -f _newSource

_selectEntry() {
	# function to decide on the action based on the selected entry
	# triggered with ENTER
	# $1 = selected entry
	# $2 = typed query
	local _selectedEntry="${1:-}"
	local _typedQuery="${2:-}"

	_debug "${FUNCNAME[0]}: selected entry: ${_selectedEntry}"
	_debug "${FUNCNAME[0]}: typed query: ${_typedQuery}"

	# first, remove the header state file if it exists
  [[ -f "${_fzfHeaderState}" ]] && rm -f "${_fzfHeaderState}"
  _debug "${FUNCNAME[0]}: cleanup removed ${_fzfHeaderState}"

	# if _selectedEntry is empty
	if [[ -z "${_selectedEntry}" ]]; then
		_debug "${FUNCNAME[0]}: no match, query='${_typedQuery}'"
		_newSource "${_typedQuery}"
		return
	fi

  # check if the selection is an existing set
  if [[ "${_selectedEntry}" =~ \[.*\]$ ]]; then
    # extract the set name
    local _setName="${_selectedEntry%\[*\]}"
    _debug "${FUNCNAME[0]}: selected set '${_setName}'"
		_debug "${FUNCNAME[0]}: reload _fzfBrowser with set '${_setName}'"
		# reload with the set members
    _fzfBrowser _setMember "_listSetMembers ${_setName}" "_previewSets {}" "set:${_setName}" "1:browse set members"
		_debug "${FUNCNAME[0]}: set member selected: ${_setMember}"
		return
	fi

  # check if the selection is an existing source
  if _doesSourceExist "${_selectedEntry}"; then
    _debug "${FUNCNAME[0]}: selected source '${_selectedEntry}'"
		_debug "${FUNCNAME[0]}: reload _fzfBrowser with source '${_selectedEntry}'"
		_setSource "${_selectedEntry}"
    _fzfBrowser _entity _listEntities _previewEntry "source:${_selectedEntry}" "1:browse source entities"
		return
	fi

  # check if it's a key file in the current source
  local _currentSource=$(_getSource)
  local _filePath="${_HOME}/${_currentSource}/${_selectedEntry}"
  if [[ -f "${_filePath}" ]]; then
    _debug "${FUNCNAME[0]}: selected file '${_filePath}'"
    _debug "${FUNCNAME[0]}: open the editor on "${_filePath}
		return
  fi

  # If none of the above, warn about invalid selection
  _warn "${FUNCNAME[0]}: invalid selection '${_selectedEntry}'"
}
export -f _selectEntry

_listEntities () {
	# generate an index-aware list for fzf
  local _currentSource=$(_getSource)
	local _sourceDir="${_HOME}/${_currentSource}"
	local _currentIndex="${_HOME}/${_currentSource}/.current"
  local _indexedFiles=()
  local _nonIndexedFiles=()

	# check for the current index
	if [ -f "${_currentIndex}" ]; then
		local _currentIndexName=$(cat "${_currentIndex}")
		local _currentIndexDir="${_HOME}/${_currentSource}/.index/${_currentIndexName}"
	fi

	# Ensure the active index directory exists
	if [[ -d "${_currentIndexDir}" ]]; then
		# Read the symbolic links in the active index directory
		while IFS= read -r -d '' link; do
			local _linkName=$(basename "${link}")
			local _originalFile=$(readlink "${link}")
			_indexedFiles+=(".index/${_currentIndexName}/${_linkName}")
		done < <(find "${_currentIndexDir}" -mindepth 1 -maxdepth 1 -type l -print0)
	fi

	# Get the list of non-indexed files
	local _allFiles
	_allFiles=$(ls "${_HOME}/${_currentSource}")
	for _file in ${_allFiles}; do
		# Check if the file is already indexed
		if [[ ! " ${_indexedFiles[*]} " =~ " ${_file} " ]]; then
			_nonIndexedFiles+=("${_file}")
		fi
	done

  # Sort the files based on the current order
  if _isSearchReversed; then
    _indexedFiles=($(printf '%s\n' "${_indexedFiles[@]}" | sort -nr))
    _nonIndexedFiles=($(printf '%s\n' "${_nonIndexedFiles[@]}" | sort -nr))
  else
    _indexedFiles=($(printf '%s\n' "${_indexedFiles[@]}" | sort -n))
    _nonIndexedFiles=($(printf '%s\n' "${_nonIndexedFiles[@]}" | sort -n))
  fi

	# Output the combined list: indexed files first, then non-indexed files
	for _indexed in "${_indexedFiles[@]}"; do
		echo "${_indexed}"
	done
	for _nonIndexed in "${_nonIndexedFiles[@]}"; do
		echo "${_nonIndexed}"
	done
}
export -f _listEntities

_createIndex() {
  # create or select an index for the current source
  local _currentSource=$(_getSource)
	local _sourceDir="${_HOME}/${_currentSource}"
  local _indexDir="${_HOME}/${_currentSource}/.index"
  local _indexName
  local _indexPath

  # Use _fzfBrowser to create an index name
  _fzfBrowser _indexName _listIndexes _validateName index "1:create or select index"

	# abort if fzf returns null
	[[ ${_indexName} = ":" ]] && { _warn "index creation aborted"; return; }
	
	# fzfBrowser returns "query:selection", so trim to selection only
	_indexName=${_indexName#*:}

  # Validate the selected or entered index name
  #if ! _isSourceNameValid "${_indexName}"; then
  if ! _isNameValid index "${_indexName}"; then
    _warn "invalid index name: '${_indexName}'"
    return 1
  fi

  # create the new index directory if it doesn't exist
  _indexPath="${_indexDir}/${_indexName}"
  if [[ ! -d "${_indexPath}" ]]; then
    mkdir -p "${_indexPath}"
    _info "index '${_indexName}' created successfully"
  else
    _info "index '${_indexName}' already exists"
  fi

	# set the current view to the index
	echo ${_indexName} > "${_sourceDir}/.current"

}
export -f _createIndex

_readRaw () {
	# remove the .current file and read the raw list
  local _currentSource=$(_getSource)
	local _sourceDir="${_HOME}/${_currentSource}"
	rm "${_sourceDir}/.current"
}
export -f _readRaw

_listIndexes() {
  # List all indexes for the current source
  local _source=$(_getSource)
  local _indexDir="${_HOME}/${_source}/.index"

  # Check if the .index directory exists
  if [[ -d "${_indexDir}" ]]; then
    # List all directories inside .index (or return true if empty)
    find "${_indexDir}" -mindepth 1 -maxdepth 1 -type d -exec basename {} \; || true
  else
    # If .index does not exist, return an empty list
		true
  fi
}
export -f _listIndexes

_removeFromIndex() {
  # Remove a file from the current index
  # $1 = selected file
  local _currentSource=$(_getSource)
  _debug "current source is ${_currentSource}"
  local _currentIndex="${_HOME}/${_currentSource}/.current"
  _debug "current index is ${_currentIndex}"

  # Check for the current index
  if [ -f "${_currentIndex}" ]; then
    local _currentIndexName=$(cat "${_currentIndex}")
    _debug "current index name is ${_currentIndexName}"
    local _currentIndexDir="${_HOME}/${_currentSource}/.index/${_currentIndexName}"
    _debug "current index dir is ${_currentIndexDir}"
  else
    return 1
  fi

  # Remove the symbolic link
  local _linkPath="${_currentSource}/${1}"
  _debug "link path is ${_linkPath}"
  if [[ -L "${_linkPath}" ]]; then
    rm "${_linkPath}"
    _info "removed '${1}' from index '${_currentIndexName}'"
  else
    _error "file '${1}' does not exist in index"
    return 1
  fi

  # Reindex the symbolic links to start at 1 and remove gaps
  if [[ -d "${_currentIndexDir}" ]]; then
    _debug "Reindexing links to start at 1"
    local _newIndex=1
    local _links=()

    # Collect all symbolic links into an array
    while IFS= read -r -d '' _link; do
      _links+=("${_link}")
    done < <(find "${_currentIndexDir}" -mindepth 1 -maxdepth 1 -type l -print0 | sort -z)

    # Rename each link sequentially
    for _oldLink in "${_links[@]}"; do
      local _newLink="${_currentIndexDir}/${_newIndex}"
      _debug "Renaming '${_oldLink}' to '${_newLink}'"
      mv "${_oldLink}" "${_newLink}"
      (( _newIndex++ ))
    done
  fi
}
export -f _removeFromIndex

_addToIndex() {
  # Add a file to the current index
  # $1 = selected file
  local _currentSource=$(_getSource)
  local _currentIndex="${_HOME}/${_currentSource}/.current"

  # Check for the current index
  if [ -f "${_currentIndex}" ]; then
    local _currentIndexName=$(cat "${_currentIndex}")
    local _currentIndexDir="${_HOME}/${_currentSource}/.index/${_currentIndexName}"
  else
    return 1
  fi

  # Determine the next available number for the symbolic link
  local _nextIndex
  local _lastIndex
  _lastIndex=$(find "${_currentIndexDir}" -mindepth 1 -maxdepth 1 -type l -exec basename {} \; | sort -n | tail -1)
  _nextIndex=$((_lastIndex + 1))

  # Create the symbolic link
  local _sourceFile="${_HOME}/${_currentSource}/${1}"
  local _linkPath="${_currentIndexDir}/${_nextIndex}"

  # Check if the target file is a symbolic link
  if [[ -L "${_sourceFile}" ]]; then
    _warn "Cannot add '${1}' to index: it is a symbolic link"
    return 1
  fi

  # Check if the target file is a real file
  if [[ -f "${_sourceFile}" ]]; then
    # The link must be relative to allow for renaming
    ln -s "$(realpath --relative-to="${_currentIndexDir}" "${_sourceFile}")" "${_linkPath}"
    _info "Added '${1}' to index '${_currentIndexName}' as entry '${_nextIndex}'"
  else
    _error "File '${1}' does not exist"
    return 1
  fi
}
export -f _addToIndex

_getSourceDetails() {
	local _newSourceName=$1
	[[ ${_newSourceName} = $(_getSource) ]] && return
	echo -e $(_ask "enter a description for '${_newSourceName}' ?=help q=abort")
	while read -r -e -p "$(_ask ": ")" _newSourceDescription; do
		case "${_newSourceDescription}" in
			help|h|\?)
				_info "enter a description for '${_newSourceName}'"
				_info "example: little green notebook 12 Jan 2023" 
				_info "example: lecture notes from chem 202"
				_info "note: the description can be changed later"
				_info "    : multiple lines can be added later as well"
				_info "usage: q to abort, h for this help."
				_info "enter a description for '${_newSourceName}'"
				;;
			quit|q)
				_warn "aborting; '${_newSourceName}' not added. try again later"
				return 1
				;;
			*)
				[[ -z ${_newSourceDescription} ]] && { _warn "empty description not allowed"; continue; } 
				[[ ${_newSourceDescription} =~ ^[[:alnum:]] ]] || { _warn "use your words"; continue; }
				break
				;;
		esac
	done
	[[ -z ${_newSourceDescription} ]] && { _warn "empty description not allowed"; return; } 
	while read -r -e -n1 -p "$(_ask "save '${_newSourceName}' as a new source? (y/n)") " _c; do
		case ${_c} in
			y)
				_saveSource "${_newSourceName}" "${_newSourceDescription}"
				break
				;;
			n)
				return 1
				;;
			*)
				continue
				;;
		esac
	done
	while read -r -e -n1 -p "$(_ask "set '${_newSourceName}' as current? (y/n) ") " _d; do
		case ${_d} in
			y)
				_setSource "${_newSourceName}"
				return
				;;
			n)
				return
				;;
			*)
				continue
				;;
		esac
	done
}
export -f _getSourceDetails

_previewSource() {
	# used by fzf during source change...shows description and entity count
	[[ -z ${2} ]] && { echo "source does not exist"; return; }
	echo "source: $2"
	echo "entries: $(_getSourceCount $2)"
	echo
	echo "----DESCRIPTION-------------------"
	cat "${_HOME}/${2}/.description"
}
export -f _previewSource

_previewEntry() {
	# used by fzf during edit to display the germ 
	#echo "query    : $1"
	#echo "selection: $2"
	#echo "----entity contents below---------"
	if [[ -z "${2}" ]]; then
		echo "no such entity"
	else
		echo
		# add a left margin for readability
		cat "${_HOME}/${_currentSource}/${2}" | sed 's/^/   /'
		echo
	fi
}
export -f _previewEntry

#_isSourceNameValid() {
_isNameValid() {
	# generic (source, set, and index) name validator
	# arg 1 = name type (source, set, index)
	# arg 2 = name
	local _nameType=${1:-source}
	local _name=${2:-}
	local _maxLength=25
	local _minLength=1
	if [[ "${_name}" =~ ^([[:lower:]|[:upper:]|[:digit:]]|[-_.]){${_minLength},${_maxLength}}$ ]]; then
		[[ "${_name}" =~ ^[[:lower:]|[:digit:]] ]] || return 1
		[[ "${_name}" =~ [[:lower:]|[:digit:]]$ ]] || return 1
		[[ "${_name}" =~ ([.]|[-]|[_]){2} ]] && return 1
		if _doesNameExist ${_nameType} "${_name}"; then
			_warn "'${_name}' is not new"
			return 1
		else
			return 0
		fi
	else
		_warn "'${_name}' is not allowed, try again"
		_info "rules: a-z A-Z 0-9 _ - . allowed; no spaces allowed"
		_info "rules: max length ${_maxLength} characters, min is ${_minLength}"
		return 1
	fi
}
export -f _isNameValid

_mergeSource() {
	_current=${_currentSource}
	_fzfBrowser _mergeWhat _getSourceList _previewSource "WHAT" "1:merge into '$_current'" || return
	[[ ${_mergeWhat} = ":" ]] && { _warn "merge aborted"; return; }
	# separate the return
	_query=${_mergeWhat%%:*}
	_selection=${_mergeWhat#*:}
	_debug "query is '${_query}'"
	_debug "selection is '${_selection}'"
	# if query is empty and selection exists, use it 
	[[ -z "${_query}" ]] && _doesNameExist source "${_selection}" \
		&& _what=${_selection}
	# if query is not empty and it matches a source, use that
	if [[ ! -z "${_query}" ]]; then
		if [[ "${_query}" = "${_selection}" ]]; then
			# user did not use arrow to select, use _query
	 		_doesNameExist source "${_query}" && _what=${_query}
		else
			# query and selection do not match...user selected
	 		_doesNameExist source "${_selection}" && _what=${_selection}
		fi
	fi
	# if query is not empty and it does not match a source, use selection
	# if it exists
	if [[ ! -z "${_query}" ]] && ! _doesNameExist source "${_query}"; then
		if _doesNameExist source "${_selection}"; then
		 	_what=${_selection}
		else
			_warn "'${selection}' does not exist; cannot merge from nothing"
			return
		fi
	fi
	[[ ${_what} = ${_current} ]] && { _warn "cannot merge into self"; return; }
	[[ $(_getSourceCount ${_what}) = 0 ]] && { _warn "cannot merge from empty source"; return; }
	read -rsn1 -p $(_ask "merge '${_what}' into '${_current}' ? [y/n]") _yn
 	echo
 		[[ ${_yn} != "y" ]] && { _warn "merge aborted"; return; }
	_debug "now merge '${_what}' into '${_current}'"
	# git mv all 
	git -C "${_HOME}" --git-dir="${_GITDIR}" mv "${_HOME}/${_what}/"* "${_HOME}/${_what}/".* "${_HOME}/${_current}"
	# then remove if not default
	[[ ${_what} != "default" ]] && git -C "${_HOME}" rm -rq "${_HOME}/${_what}"
	# then commit
 	git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] merged ${_what} into ${_current}"
}

_changeSource() {
	_fzfBrowser _changeTo _getSourceList _previewSource "source" "1:change to selected" || return
	[[ ${_changeTo} = ":" ]] && { _warn "change source aborted"; return; }
	# separate the return
	_query=${_changeTo%%:*}
	_selection=${_changeTo#*:}
	_debug "query is '${_query}'"
	_debug "selection is '${_selection}'"
	# if query is empty and selection exists, do it
	[[ -z "${_query}" ]] && _doesNameExist source "${_selection}" \
		&& { _setSource "${_selection}"; return; }
	# if query is not empty and it matches a source, use that
	if [[ ! -z "${_query}" ]]; then
		if [[ "${_query}" = "${_selection}" ]]; then
			# user did not use arrow to select, use _query
	 		_doesNameExist source "${_query}" && { _setSource "${_query}"; return; }
		else
			# query and selection do not match...user selected
	 		_doesNameExist source "${_selection}" && { _setSource "${_selection}"; return; }
		fi
	fi
	# if query is not empty and it does not match a source, use selection
	# if it exists
	if [[ ! -z "${_query}" ]] && ! _doesNameExist source "${_query}"; then
		if _doesNameExist source "${_selection}"; then
		 	_setSource "${_selection}"; return
		else
			_warn "'${selection}' does not exist; use N to create new source"
			return
		fi
	else
		_warn "'${selection}' invalid"
		return
	fi
}

_renameSource() {
	_current=${_currentSource}
	[[ "${_current}" = "default" ]] && { _warn "cannot rename 'default'"; return; }
	_fzfBrowser _newName _getSourceList _validateName source "1:rename '$_current'" || return
	[[ ${_newName} = ":" ]] && { _warn "rename source aborted"; return; }
	# always use the query here
	_newName=${_newName%%:*}
	[[ -z ${_newName:-} ]] && { _warn "empty names not allowed"; return; }
	#_isSourceNameValid "${_newName}" || { _error "'${_newName}' is invalid"; return; }
	_isNameValid source "${_newName}" || { _error "'${_newName}' is invalid"; return; }
	_doesNameExist source "${_newName}" && { _warn "${_newName} exists"; return; }
 	git -C "${_HOME}" --git-dir="${_GITDIR}" mv "${_HOME}/${_current}" "${_HOME}/${_newName}"
 	git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] renamed ${_current} to ${_newName}"
	_setSource "${_newName}"
}

_edit() {
	# launch picker to select what to edit
	local _current=${_currentSource}
	[[ $(_getSourceCount ${_current}) = 0 ]] && { _warn "'${_current}' is empty"; return; }
	_fzfBrowser _what "_printSourceEntities ${_current}" _previewEntry "${_current}" "1:choose what to edit" || return
	[[ ${_what} = ":" ]] && { _warn "edit aborted"; return; }
	# always use the selection
	_file=${_what#*:}
	# edit
	${_EDITOR} "${_HOME}/${_current}/${_file}"
	# test for changes
  git -C "${_HOME}" --git-dir="${_GITDIR}" diff --quiet --exit-code "${_HOME}/${_current}/${_file}" && return
	_commitMsgString=$(_buildCommitMsg "$(cat "${_HOME}/${_current}/${_file}")")
	# save file and commit
	_doCommit "${_HOME}/${_current}/${_file}" "[edit in ${_current}] ${_commitMsgString}"
}

_browse() {
	local _current=${_currentSource}
	[[ $(_getSourceCount ${_current}) = 0 ]] && { _warn "'${_current}' is empty"; return; }
	_c=${_currentSource}
	#_fzfBrowser _w _listEntities _previewEntry _setPrompt "2:? for help" || return
	_fzfBrowser _w _listEntities _previewEntry _setPrompt || return
}


_deleteSource() {
  local _state="empty"
  local _current
  _current=$(_getSource)

  # ensure the default source cannot be deleted
  if [[ "${_current}" == "default" ]]; then
    _warn "cannot delete 'default'"
    return
  fi

  # check if the source is empty
  if [[ $(_getSourceCount "${_current}") != 0 ]]; then
    _warn "'${_current}' is not empty"
    _state="non-empty"
  fi

  # prompt for confirmation
  local _yn
  read -r -n1 -p "$(_ask "delete ${_state} '${_current}'? [y/n] ")" _yn
  echo
  if [[ "${_yn}" != "y" ]]; then
    _warn "delete aborted"
    return
  fi

  # delete the source
  git -C "${_HOME}" rm -rq "${_HOME}/${_current}"
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] deleted ${_state} ${_current}"
  _setSource "default"
}
export -f _deleteSource

########################
# SEARCH
########################

_search() {
	rg --color=always --line-number --no-heading --smart-case "${*:-}" | fzf \
		--ansi \
		--color "hl:-1:underline,hl+:-1:underline:reverse" \
		--delimiter : \
		--preview 'batcat --color=always {1} --highlight-line {2}' \
		--preview-window 'up,60%,border-bottom,+{2}+3/3,~3'
}

########################
# PDF
########################

_pdf() {
	# produce a nice pdf and save to desktop
	# source notebook provided as $1
	local _source=${1}
	# destination for output file
	local _destination="$HOME/Desktop/"
	# temp working dir
	local _temp=$(mktemp -d)
	# log file
	local _logfile="${_temp}/germ_pdf.log"
	_debug "logging to '$_logfile'"
	# set the output file name
	local _filename="${_source}-$(date +%Y%m%d-%H%M%S)"
	# set the output file full path
	local _output_full_path="${_destination}${_filename}"
	# full commit hash (40 characters)
	full_hash=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-parse HEAD)
	# Short commit hash (typically 7 characters)
	short_hash=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-parse --short HEAD)

	# create a list of files, sorted chronologically by timestamp
	local files=()
		while IFS= read -r -d '' file; do
			files+=("$file")
		done < <(find "${_source}" -maxdepth 1 -type f -regextype posix-extended -regex ".*[0-9]{10}\.[0-9]+" -print0 | sort -z)

	# add trap to remove temporary directory on exit
#	trap 'rm -rf "$_temp"' EXIT

	# gather statistics
	local total_files=${#files[@]}
	local words_per_file=()
	local pages_per_file=()
	
	# calculate words and pages for each file
	for file in "${files[@]}"; do
		words_per_file+=("$(wc -w < "$file")")
		# estimate pages (assuming ~66 lines per page with enscript defaults)
		local file_lines=$(wc -l < "$file")
		pages_per_file+=("$(( (file_lines + 65) / 66 ))")
	done
	
	# create cover page
	local cover_file="${_temp}/cover_page.txt"
	cat > "$cover_file" << EOF

source name: $_source
description: $(cat ${_HOME}/${_currentSource}/.description)
file count: $total_files
draft date: $(date '+%Y-%m-%d %H:%M:%S %Z')
germ git hash: $full_hash


EOF
	
	# enumerate file details into cover page
	printf "%-6s %-21s %-35s %6s %8s %7s\n" "index" "key" "name" "words" "pages" "revs" >> "$cover_file"
	printf -- "------------------------------------------------------------------------------------------\n" >> "$cover_file"
	for i in "${!files[@]}"; do
		local filename=$(basename "${files[i]}")
		local givenname=$(head -1 "${files[i]}")
		local revs=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-list --count HEAD -- "${files[i]}")
		printf "%3d. %*s %-21s %-35s %5d %7d %7d\n" \
			$((i+1)) 1 "" "$filename" "$givenname" "${words_per_file[i]}" "${pages_per_file[i]}" "$revs" >> "$cover_file"
	done

	# create cover header
	local _header="${_MASTER}:${_NAME}:${_USERNAME}"
	_header+="|==--DRAFT--=="
	_header+="|${_source} [${short_hash}]"

	# convert cover page to PDF
	enscript -f Courier10 -b"${_header}" -p "${_temp}/cover.pdf" "$cover_file" >> "${_logfile}" 2>&1

	# combine files into a single PDF
	local combined_pdf="${_temp}/text_archive.pdf"
	local temp_pdfs=()
	for i in "${!files[@]}"; do
		local file="${files[i]}"
		local filename=$(basename "$file")

		# create header string for each file
		local _header="${_source}:DRAFT"
		_header+="|$filename"
		_header+="|page $% of $="

		# convert file to PDF
		local file_pdf="${_temp}/file_${i}.pdf"
		enscript -f Courier10 -b"${_header}" -p "$file_pdf" "$file" >> "${_logfile}" 2>&1
		temp_pdfs+=("$file_pdf")
	done

	# combine all PDFs
	gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile="$combined_pdf" \
		"${_temp}/cover.pdf" "${temp_pdfs[@]}"

	# copy final PDF to Desktop
	cp "${combined_pdf}" "${_destination}${_filename}"
	_info "copied file to desktop as '${_filename}'"
}

###############
###### SHELL
###############

_shell() {
	# the main UI function
	# use the experimental TUI mode if called (and available)
	#source "$(dirname "$0")/tui-shell.sh"
	#_tui_shell
	#return
	# Check if TUI mode is enabled
 	if [[ "${_TUI:-false}" == "true" ]]; then
		# Source the TUI shell script if it exists
		if [[ -e "$(dirname "$0")/tui-shell.sh" ]]; then
			source "$(dirname "$0")/tui-shell.sh"
			_tui_shell
			return
		else
			_warn "TUI shell not found, falling back to standard shell"
		fi
	fi

	cd "${_HOME}" || { _error "can not enter ${_NAME}"; return 1; }
	# set up shell history business
	HISTFILE="${_HOME}/.${_NAME}_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	# here would be the right place to lock the session
	## SESSION-LOCK
	# and keep session timers and counters
	# set the current source
	export _currentSource=$(_getSource)
	# the splash welcome
	_displayWelcome() {
	cat <<HEREDOC
  __  ___  ___   __  __ 
 / _)(  _)(  ,) (  \/  )
( (/\ ) _) )  \  )    ( 
 \__/(___)(_)\_)(_/\/\_)

      type ${green}h${reset} for help
      type ${red}q${reset} to quit

HEREDOC
	}
	# the main menu
	_printMenu() {
		printf '\n'
		printf ':-----germ commands------------------------------------------------------------o\n'
		printf '\n'
		printf '  h   how to use                      == current source: "%s" ==== \n' "${_currentSource}"
		printf '  a   add new note (editor)            C  change source                        .\n'
		printf '  f   fast add (one line, no editor)   N  new source                           .\n'
		printf '  e   edit (within current)            R  rename current                       .\n'
		printf '  b   browse (within current)          M  merge (other into current)           .\n'
		printf '  s   search                           D  delete current                       .\n'
		printf '                                       P  print description                    .\n'
		printf '  p   pdf current to desktop           E  edit description                     .\n'
		printf '                                       S  split (future)                       .\n'
		printf '                                       B  browse all source notebooks          .\n'
		printf '  \n'
		printf '  \n'
		printf '  \n'
		printf '                                         ===========debug etc==============\n'
		printf '  a   add new (editor)                    ctrl-x toggle bash debug (set -x) \n'
		printf '  f   fast add (no editor)                ctrl-b toggle germ debug          \n'
		printf '  e   edit                                0 print env                       \n'
		printf '  b   browse                              ctrl-g git status                 \n'
		printf '  q   quit %s\n' ${_NAME}
		printf '.  *insert msg*                                                                .\n'
	}
	_printGuidance() {
		printf '\n'
		printf ':-----germ usage guide---------------------------------------------------------o\n'
		printf '\n'
		printf ' in the simplest form, there is one "notebook" aka "source"  \n'
		printf '  which is called "default"                                                    .\n'
		printf '   press "a" to add a new note to the current source                           .\n'
		printf '                                                                               .\n'
		printf '                                                                               .\n'
		printf '  to use and manipulate multiple "notebooks" use the source commands           .\n'
		printf '   N creates new notebook names                                                .\n'
		printf '   R renames the current                                                       .\n'
		printf '   M allows one to merge the contents of one source into the current           .\n'
		printf '            it also deletes the now empty other source                         .\n'
		printf '   D deletes the current source (even if it is not empty!)                     .\n'
		printf '  \n'
		printf '  commands operate on the current "source"\n'
		printf '  \n'
		printf '  \n'
		printf '  the default notebook cannot be renamed or removed                            .\n'
		printf '  \n'
		printf '  \n'
		printf '  \n'
		printf '  q   quit %s\n' ${_NAME}
		printf '.  *insert msg*                                                                .\n'
	}
	# the prompt and interpreter
	_mainPrompt() {
		# disallow use of ctrl-c etc
		trap '' SIGQUIT SIGTSTP SIGINT SIGTERM
		_p() {
			local _cs=$(_getSource)
			# set the prompt
			reset=$'\001\e[0m\002'
			_cH=$'\001\e[00;45m\002'		#home
			_cG=$'\001\e[00;7m\002'			#germ
			_cU=$'\001\e[00;32m\002'		#user
			_cS=$'\001\e[00;33m\002'		#source
			_dirty="${green}o${reset}"
			_isIndexClean || _dirty="${red}-${reset}"
			echo -n "${_cH}${_MASTER}${reset}:${_cG}${_NAME}${reset} ${_cU}${_USERNAME}${reset} [${_cS}${_cs}${reset}] ${_dirty} > "
		}
		_displayWelcome
		local __input
		while read -rsn1 -p "$(_p)" __input || true; do
			echo
			case ${__input} in
				\?)
					_printMenu
					;;
				h)
					_printGuidance
					;;
				a)
					_add || :
					;;
				f)
					# fast (editor-free) add
					echo -e $(_ask "add to '${_currentSource}'; ENTER to accept")
					read -r -p "$(_ask ": ")" _newEntry
					[[ -z "${_newEntry}" ]] && continue
					_key=$(_getNewKey)
					_commitMsg=$(_buildCommitMsg "${_newEntry}")
					echo "${_newEntry}" > "${_HOME}/${_currentSource}/${_key}"
					_doCommit "${_HOME}/${_currentSource}/${_key}" "[add to ${_currentSource}] ${_commitMsg}"
					;;
				e)
					_edit || :
					;;
				b)
					_browse || :
					;;
				s)
					_search || :
					;;
				p)
					_pdf "${_currentSource}"
					;;
				B)
					_browseSources || :
					;;
				C)
					_changeSource || :
					;;
				N)
					_newSource || :
					;;
				R)
					_renameSource || :
					;;
				M)
					_mergeSource || :
					;;
				D)
					_deleteSource || :
					;;
				S)
					_debug "split requires multi-select fzf function"
					;;
				E)
					# edit source description
					${_EDITOR} "${_HOME}/${_currentSource}/.description"
  				git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/${_currentSource}/.description"
  				git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] updated '${_currentSource}' description"
					# TODO fix this...when desc is not saved, error 
					;;
				P)
					_info "current source: ${_currentSource}"
					_info "entries       : $(_getSourceCount ${_currentSource})"
					_info "description   : $(cat ${_HOME}/${_currentSource}/.description)"
					_info "entities      : $(_printSourceEntities ${_currentSource})"
					;;
				$'\x18')
					# toggle bash set -x debug with ctrl-x
					[[ $- == *x* ]] && set +x || set -x
					;;
				$'\x02')
					# toggle script _DEBUG with ctrl-B
					[ $_DEBUG = "true" ] && _DEBUG=false || _DEBUG=true
					_debug "debug on"
					;;
				$'\x07')
					# ctrl-g (run git status)
  				git -C "${_HOME}" --git-dir="${_GITDIR}" status
					;;
				0)
					printenv | grep "^_"
					;;
				t)
					_inspect
					;;
				q)
					return
					;;
				$'\e')
					# ignore all escape sequences
					_debug "esc ignored"
					# eat anything there
					read -rsn8 -t .002 _escape || continue
					_debug "esc $_escape"
					;;
				$'\04')
					# read ctrl-d
					_warn "use 'q' to quit"
					;;
			esac
		done
	}
	_mainPrompt
}

main() {
	# read all the positional parameters
  _getOpts "${@}"
  # setup the environment after processing all command line parameters
  _setEnv
  # validate the environment (external tools required)
  _checkExternalTools || { _error "cannot run until these problems are resolved"; return 1; }
  # check for the working directory
  _checkHome || { _error "cannot run without a working environment"; return 1;  }
	# check health
	# TODO eg check for .swp file from vim crash
	#
  # enter custom shell if no arguments
  [ -z "${_subCommand:-}" ] && _shell
  # otherwise, pass the commands to the called "command"
  [[ -n "${_subCommand:-}" ]] && _debug "now calling the eval to run '${_subCommand:-}'"
  [[ -n "${_subCommand:-}" ]] && eval _"${_subCommand}" || :
}
main "${@}"
