#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/notelos.git
# author: jason@bloom.us
# description: note taking tool

# STRICT SHELL
set -o errexit 
set -o nounset
set -o pipefail
IFS=$'\n\t'

###########################
# PREREQUISITES
###########################
 
# required external commands
_requiredCommands=(git tig fzf)

###########################
# LIBRARY
###########################

# source library commands and set up log/console
# use the library file from the same directory if possible
# otherwise, source it from the path
[[ -e "$(dirname $0)/notelos-lib.sh" ]] \
	&& source "$(dirname $0)/notelos-lib.sh" \
	|| source notelos-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

# default initial debugging and logging settings
# note: command line parameters can modify these
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=false

# instantiate the log/mesg functions with defaults (these will be re-initialized
# after reading positional parameters)
_fLOG

####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF
usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit
 -x      force standalone mode
 -t      tui (experimental)

alternate env settings:
 -a <name>  set the germ dir name to <name>
 -p <path>  set alternate base path

commands:
EOF
_printCommands
}

_printCommands() {
	cat <<  EOF
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database
 inspect             run tig on the germ git bare repo
 search              interactive search
 browse              read through the current source entities
 source              add and manipulate source
 pdf                 produce a pdf from notebook
EOF
}

_printInfo () {
  cat << EOF
germ takes simple notes and adds them to a git repo
EOF
}

####################################
# PARAMETER PROCESSING
####################################

_getOpts () {
	# preserve the initial positional parameters
	export _fullCommand="${@}"
	_debug "full command is '${_fullCommand}'"
	local OPTIND
	# do not allow names for notelos or self to be names of germ commands
	_isCommand() {
		local _allowed=true
		local _commandList
		_commandList=$(_printCommands | cut -f2 -d' ')
		for _command in ${_commandList}; do
      [[ "${_command}" = "${1}" ]] && _allowed=false 
    done
    [[ ${_allowed} = "true" ]] || return 1
  }
	while getopts ":hsdlxtva:p:" flag ; do
		case ${flag} in 
			h)
				_printInfo; _printUsage; exit 0
				;;
			a)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is    NOT a flag ($OPTARG)"; exit 1; }
				_isCommand "${OPTARG}" || { _error "'${OPTARG}' is not allowed (it is a command)"; exit 1; }
				_NAME=${OPTARG}
				_warn "using alt name '${_NAME}'"
				;;
			p)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_BASE=${OPTARG}
				_warn "using alt path '${_BASE}'"
				;;
 	    s)
				_debug "${FUNCNAME[0]}: enabling silent mode with flag -$flag"
 	      _SILENT=true
				;;
			d)
				_debug "${FUNCNAME[0]}: enabled debug mode with flag -$flag"
				_DEBUG=true
				;;
			l)
				_debug "${FUNCNAME[0]}: enabled log mode with flag -$flag"
				_LOG=true
				;;
			x)
        _debug "${FUNCNAME[0]}: running in standalone mode with -$flag"
        _MODE=standalone
        ;;
			t)
				_debug "${FUNCNAME[0]}: running experimental TUI mode"
				_TUI=true
				;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -${OPTARG}"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1)); OPTIND=1
	# preserve the full subcommand with its parameters
	export _subCommandParams="${@}"
	# look for the subcommand and check for its options
	while ((${#})); do
		case ${1} in
			help)
				_printInfo; _printUsage; exit 0
				;;
			add)
				_subCommand=$1; shift
				while getopts ":ibs:" flag; do
					case ${flag} in
						i)
							# inline add (no editor invoked)
							_debug "enabled inline mode"
							_inline=true
							_inlineString="${_subCommandParams#*add -i*}"
							_debug "inline string: '${_inlineString}'"
							;;
						b)
							# bulk add disables commit...this is a hack to allow bulk input
							# without commiting each one...behavior is not correct imo
							_debug "bulk add operation"
							_bulk=true
							;;
						s)
							# specify the source notebook for the add
							_debug "source specified '${OPTARG}'"
							_addTO="${OPTARG}"
							;;
						?)
				 			_error "${FUNCNAME}: unknown flag -${OPTARG}"; exit 1
							;;
					esac
				done
				return
				;;
			edit)
				_subCommand=$1; shift
				return
				;;
			create)
				_subCommand=$1; shift
				return
				;;
			inspect)
				_subCommand=$1; shift
				return
				;;
			status)
				_subCommand=$1
				return
				;;
			source)
				_subCommand=$1
				return
				;;
			pdf)
				_subCommand=$1
				return
				;;
			*)
				_error "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
  # get the name and absolute path of the calling script
  _selfNAME=$(basename "${BASH_SOURCE[0]}")
  _selfABSOLUTE=$(readlink -f "${BASH_SOURCE[0]}")
  _selfBASE=$(dirname "${_selfABSOLUTE}")
  _selfCALL=${0}
  _selfPWD=$(pwd)
	# determine mode (notelos-integrated or standalone)
	[[ -n "${_notelosHOME+x}" && ${_MODE:-} != "standalone" ]] && _MODE=integrated || _MODE=standalone
	# note: the -x switch overrides the global _notelosHOME var 
	# set up the working environment
	if [[ ${_MODE} = "integrated" ]]; then
		# set up integrated mode
		_MASTER="${_notelosNAME}"
		_BASE="${_notelosHOME}"
		_NAME="${_NAME:-germ}"
		_HOME="${_BASE}/${_NAME}"
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/.log/${_NAME}.log"
		# inherit these (from notelos)
		_DEBUG=${_notelosDEBUG}
		_LOG=${_notelosLOG}
		_SILENT=${_notelosSILENT}
		_USERNAME=${_notelosUSERNAME}
		_USERFULLNAME=${_notelosUSERFULLNAME}
		_USEREMAIL=${_notelosUSEREMAIL}
		_EDITOR=_notelosEdit
	else
		# set up standalone mode
		_MASTER=self
		_BASE="${_BASE:-$HOME}"
		_NAME="${_NAME:-germ}"
		_HOME=${_BASE}/${_NAME}
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/${_NAME}.log"
		# inherit these
		_DEBUG=${_DEBUG:-false}
		_LOG=${_LOG:-false}
		_SILENT=${_SILENT:-false}
		_USERNAME=$(whoami)
		_USERFULLNAME="unknown"
		_USEREMAIL="unknown"
		_EDITOR=${EDITOR:-nano}
	fi
  [[ -f "${_LOGFILE:-}" ]] && _LOGGING=true || _LOGGING=false
	_debug "$(declare -p _MODE)"
	_debug "$(declare -p _MASTER)"
	_debug "$(declare -p _NAME)"
	_debug "$(declare -p _BASE)"
	_debug "$(declare -p _HOME)"
	_debug "$(declare -p _USERNAME)"
	_debug "$(declare -p _USERFULLNAME)"
	_debug "$(declare -p _USEREMAIL)"
	_debug "$(declare -p _GITDIR)"
	_debug "$(declare -p _LOGFILE)"
	_debug "$(declare -p _DEBUG)"
	_debug "$(declare -p _SILENT)"
	_debug "$(declare -p _LOG)"
	_debug "$(declare -p _LOGGING)"
	export _HOME
	export _EDITOR
	export _GITDIR
	export _DEBUG
	export _LOG
	export _SILENT
}

_checkExternalTools() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			: #_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}

_checkHome() {
  # check if the home dir exists
  # check if it is a germ-created git
  # return 1 if missing or not git
  # mind condition: if subcommand is create
	[[ ! -d "${_BASE}" && ${_MODE} = "notelos" ]] && { _error "notelos base not found"; exit 1; }
	[[ -d "${_BASE}" ]] || { _error "base '${_BASE}' does not exist"; exit 1; }
	local _base="${_BASE}"
	local _dirName="${_NAME}"
	local _dirPath="${_HOME}"
	local _git_desc="${_dirPath}/.git/description"
  if [ -d "${_dirPath}" ]; then
    if [ -f "${_git_desc}" ]; then
      # the git description file exists, lets check it for our marker
      read -r _desc < "${_git_desc}"
			if [[ ${_desc} == ${_MASTER}:${_NAME}:${_USERNAME}* ]]; then
        # if repo does exist, return 0
        _debug "${_git_desc} = ${_desc}"
      else
        # if repo does not exist, warn and exit
        _error "${_dirPath} exists and is NOT a studio-created repo"
        return 1
      fi
    else
      _error "${_dirPath} exists and is NOT a git repo"
      _error "move existing ${_dirPath} before proceeding"
      return 1
    fi
  else
    # dir does not exist
    _warn "'${_dirPath}' does not exist"
    read -rsn1 -p "$(_ask 'create repo now? [y/n]')" _yn
    echo
    [[ ${_yn} != "y" ]] && { _warn "cannot run without a repo"; return 1;  }
    _create || { _error "could not create ${_dirName} repo"; return 1; }
    return
  fi
}

############################
# CREATE
############################

_create() {
	# do not overwrite an existing anything
	[[ -d "${_HOME}" ]] && { _error "'${_HOME}' exists"; return 1; }
	[ ! -d "${_HOME}" ] && mkdir "${_HOME}"
	git init -q -b main "${_HOME}"
  git -C "${_HOME}" config user.name "${_USERNAME}"
  git -C "${_HOME}" config user.email "${_USEREMAIL}"
	# make the default notebook (aka "source")
	mkdir "${_HOME}/default"
	echo "default source (notebook, project, etc)" > "${_HOME}/default/.description"
	echo ".state" >> "${_HOME}/.gitignore"
	echo ".${_NAME}_history" >> "${_HOME}/.gitignore"
  git -C "${_HOME}" --git-dir="${_GITDIR}" add .gitignore
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/default/.description" 
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[genesis] ${_NAME} created by ${_USERNAME}"
	# put the installed signature in git description file
  _gitInitial=$(git -C "${_HOME}" rev-parse --short --verify main)
  _time=$(date +%s)
  printf "${_MASTER}:${_NAME}:${_USERNAME}:${_time}:${_gitInitial}\n" >      "${_HOME}/.git/description"
}

##################################
# INSPECT
##################################

_inspect() {
	tig -C ${_GITDIR}
}

##################################
# ADD
##################################

_pageSource() {
	exec 2>>/tmp/fzf.debug
  # Function to read all files in a source directory with pager
  # arg 1: source directory name
  local _source=${1}
  local _files=()
  local _tempFile
  local _oldTerm
  
  # Change terminal settings
  _oldTerm=$(stty -g)
  stty sane
  clear
  
  # Get all files in source directory (excluding hidden files)
  while IFS= read -r -d '' file; do
    _files+=("$file")
  done < <(find "${_HOME}/${_source}" -mindepth 1 -maxdepth 1 -type f -not -path "*/\.*" -print0 | sort -z)
  
  if [[ ${#_files[@]} -eq 0 ]]; then
    echo "No files found in source '${_source}'"
    read -n 1 -p "Press any key to continue..."
    stty "${_oldTerm}"
    return
  fi
  
  # Create a temporary file with all contents concatenated
  _tempFile=$(mktemp)
  
  # Add file contents to temp file with headers
  for file in "${_files[@]}"; do
    filename=$(basename "$file")
    echo -e "\n\033[1;33m======== ${filename} ========\033[0m\n" >> "${_tempFile}"
    sed 's/^/     /' "$file" >> "${_tempFile}"
    echo -e "\n\033[1;33m======== END ${filename} ========\033[0m\n" >> "${_tempFile}"
  done
  
  # Page through the combined file
  less -Ps"${_source} [${#_files[@]} files]  [ n:next file p:prev file ]  [ q:quit ]" \
       --pattern="^======== " -N --use-color "${_tempFile}"
  
  # Clean up and restore terminal
  rm "${_tempFile}"
  stty "${_oldTerm}"
}
export -f _pageSource

_pager () {
	exec 2>>/tmp/fzf.debug
	#set -x
	# arg 1 = what to page
	# either a file, or a directory
	local _source="${1}"
	local _file="${2:-}"
	local _fileList=()
	local _lesskey="--lesskey-src=${_notelosHOME}/.config/lesskey"

	# if $2 was not passed, we need a list of files
	if [[ -z "${_file}" ]]; then
    while IFS= read -r -d '' file; do
      _fileList+=("${file}")
    done < <(find "${_source}" -maxdepth 1 -type f -not -name ".*" -print0 | sort -z)
	else
		# otherwise just add the one
		_fileList+=("${_source}/${_file}")
	fi

	# if we have an empty list, just return
	[[ ${#_fileList[@]} -eq 0 ]] && return
	
	# less colors: -Dxy.z x=less parts, y=fg z=bg 	
	# open the files in less
	less ${_lesskey} -N -j1 \
		--use-color -DN238.- -DP238.72 \
		-Ps"${_source} (%i/%m) [ space/b ]  [ search / ] [ files right/left ]  [ quit q ] {%Pb\%/%L}" \
		"${_fileList[@]}"
}
export -f _pager

_pageEntity () {
	exec 2>>/tmp/fzf.debug
	#set -x
	# function to read a file with pager
	# arg 1: currentSource
	# arg 2: file
	_current=${1}
	_file=${2}

	# change terminal
	local _oldTerm
	_oldTerm=$(stty -g)	
	stty sane
	clear
	
	# page file
	#less "${_HOME}/${_current}/${_file}"
	# add a left margin
	#less -N -Ps"File: %f | Size: %s bytes | Line: %lt/%L | %pt%%" 
	#less --use-color -N -f <(sed 's/^/   /' "${_HOME}/${_current}/${_file}")
	sed 's/^/     /' "${_HOME}/${_current}/${_file}" | \
		less -Ps"${_current}  [ page space/b ]  [ search with / ]  [ quit q ]" -N --use-color 
		# the less prompt is difficult...it
	# change terminal back
	stty "${_oldTerm}"
}
export -f _pageEntity

_editEntity () {
	exec 2>>/tmp/fzf.debug
	#set -x
	# function to edit a file from within _germFZF
	# arg 1: source
	# arg 2: file
	# arg 3: line (optional) [0=open in insert mode]
	# arg 4: mode (insert or view, otherwise normal)
	# return based on two factors
	# changed + commited      = 0
	# changed + uncommitted   = 1
	# unchanged + uncommitted = 2
	# not found               = 3
	_current=${1}
	_file=${2}
	_line=${3:-}
	_mode=${4:-}

	# make sure the file exists
	if [[ ! -f "${_HOME}/${_current}/${_file}" ]]; then
		return 3
	fi
	
	# edit file (at line 1 if not provided and in "mode" if instructed
	# (see _notelosEditor)
	${_EDITOR} "${_HOME}/${_current}/${_file}" ${_line:-1} ${_mode:-}
							
	# check for changes
  if git -C "${_HOME}" --git-dir="${_GITDIR}" diff --quiet --exit-code "${_HOME}/${_current}/${_file}"; then
		return 2
	fi

	# build commit message
	_commitMsgString=$(_buildCommitMsg "$(cat "${_HOME}/${_current}/${_file}")")

	# save file and commit
	if _doCommit "${_HOME}/${_current}/${_file}" "[edit in ${_current}] ${_commitMsgString}"; then
		return 0
	else
		return 1
	fi
}
export -f _editEntity

_newEntity () {
	exec 2>>/tmp/fzf.debug
	#set -x
	# arg 1 = source
	# return 0 file created, committed
	# return 1: file created, commit failed
	# return 2: no file created
	local _source=${1}
	local _file
	local _commitMsg
	local _key=$(_getNewKey)
	_file="${_HOME}/${_source}/${_key}"
	# edit file
	${_EDITOR} "${_file}"
	# commit file if it was created
	[[ -e "${_file}" ]] || return 2
	_commitMsg=$(_buildCommitMsg "$(cat "${_file}")")
	if _doCommit "${_source}/${_key}" "[add to ${_source}] ${_commitMsg}"; then
		return 0
	else
		return 1
	fi

}
export -f _newEntity

_add() {
	# add a new entry
	local _currentSource=$(_getSource)
	local _commitMsg
	# determine if the source notebook has been declared in positional parameters
	if [[ -z ${_addTO:-} ]]; then
		# it was not specified, therefore use "current"
		_useSource=${_currentSource}
	else
		_useSource=${_addTO}
	fi
	# determine the destination for the file to write
	local _dir="${_HOME}/${_useSource}"
	local _key=$(_getNewKey)
	local _file="${_dir}/${_key}"
	# check for piped standard input
	if [ ${_inline:-null} = "true" ]; then
		# note that pipe input takes priority over message appended to 'add -i'
		if [ -p /dev/stdin ]; then
			cat < /dev/stdin > "${_file}"
		else
			[ -z "${_inlineString}" ] && { _error "${FUNCNAME}: 'add -i' cannot contain an empty message"; return 1; }
			echo "$(_trimString ${_inlineString})" > "${_file}"
		fi
	else
		# catch pipe in without -i
		[ -p /dev/stdin ] && { _error "use 'add -i' for pipe input"; return 1; }
		# maybe we don't need the -i?
		# now just use the editor as usual
		${_EDITOR} "${_file}"
	fi
	[[ -e "${_file}" ]] || return
	_commitMsg=$(_buildCommitMsg "$(cat "${_file}")")
	_doCommit "${_useSource}/${_key}" "[add to ${_useSource}] ${_commitMsg}"
}

_trimString() {
	# Usage: trim_string "   example   string    "
	# source https://github.com/dylanaraps/pure-bash-bible
	: "${1#"${1%%[![:space:]]*}"}"
	: "${_%"${_##*[![:space:]]}"}"
	printf '%s\n' "$_"
}

_getNewKey() {
	# print the key (unixseconds.nano)
	echo "$(date +%s.%N)"
}
export -f _getNewKey

_buildCommitMsg() {
	# arg 1 = string [required]
	# read string (the whole blob) line by line
	# construct git commit message string (combining lines until max exceeded)
	# truncate if necessary and append with "..."
	# total character count <=75
	# print string or return 1
	local _maxLength=60
	local _commitMsgString=
	local _lines
	# empty string not allowed
	[ -z "${1:-}" ] && return 1
	# count lines
	l="${1//[!$'\n']/}"
	_lines=$((${#l} + 1))
	# process multi-line entries
	while read -r line; do
		# single line entry, set and break
		if [ ${_lines} = 1 ]; then
			_commitMsgString="${1}"
			break
		fi
		words=($line)
		# one word lines
		if [[ ${#words[@]} = 1 ]]; then
			# if the commit message string is empty
			if [[ -z "${_commitMsgString}" ]]; then
				_commitMsgString+="${line%% *}:"
			elif [[ ${_commitMsgString:(-1)} = ":" ]]; then
				_commitMsgString+=" ${line%% *}"
			else
				_commitMsgString+="; ${line%% *}"
			fi
		# empty lines
		elif [[ ${#words[@]} = 0 ]]; then
			true
		# multi-word lines
		else
			if [[ ${_commitMsgString:(-1)} = ":" ]]; then
				# first line after first-word+colon
				_commitMsgString+=" ${line}"
			elif [[ -z "${_commitMsgString}" ]]; then
				# first slot in empty commit message string
				_commitMsgString+="${line}:"
			else
				# insert semi-colon to designate new line
				_commitMsgString+="; ${line}"
			fi	
		fi
		# once we have exceeded the maxLength...stop processing
		if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
			break
		fi
	done < <(printf '%s\n' "${1}")
	# truncate if necessary, appending elipsis to indicate truncation
	if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
		_commitMsgString="${_commitMsgString:0:${_maxLength}}..."
	fi
	# this should never occur...
	[ -z "${_commitMsgString}" ] && return 1
	# return the final string...with echo (should be using the indirect variable
	# here
	echo "${_commitMsgString}"
}
export -f _buildCommitMsg

_doCommit() {
	_newFile="${1}"
	_commitMsg="${2}"
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_newFile}"  
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "${_commitMsg}"
}
export -f _doCommit

################
# INDEX
################

_isIndexClean() {
	git -C "${_HOME}" --git-dir="${_GITDIR}" diff-index --quiet --cached main 2>&1 >/dev/null || return 1
}

################
# SOURCE
################

_getSource() {
	# print the current SOURCE
	#! _isSourceSet && { echo "default"; return; }
	_stateRead "currentSource" || echo "default"
}
export -f _getSource

_isSourceSet() {
	# return 0 if true
	# return 1 if false
	_stateRead "currentSource" >/dev/null
}
export -f _isSourceSet

_doesSourceExist() {
	# return 0 if true (yes)
	# return 1 if false (no)
	[[ -d "${_HOME}/${1}" ]]
}
export -f _doesSourceExist

_doesNameExist () {
    # Check if the name exists by type (source, index, set)
    # $1 = name type (source, index, set)
    # $2 = name to check
    # Return 0 if true (exists), 1 if false (does not exist)

    local _nameType=${1}
    local _name=${2}

    case "${_nameType}" in
        source)
            # Check if the source directory exists
            [[ -d "${_HOME}/${_name}" ]] && return 0 || return 1
            ;;
        index)
            # Check if the index directory exists for the current source
            local _currentSource=$(_getSource)
            local _indexDir="${_HOME}/${_currentSource}/.index/${_name}"
            [[ -d "${_indexDir}" ]] && return 0 || return 1
            ;;
        *)
            # Invalid name type
            _error "Invalid name type: '${_nameType}'"
            return 1
            ;;
    esac
}
export -f _doesNameExist

_setSource() {
	# arg 1 = new source
	# check if source is set, if so, remove
	# then set to new
	[ -z "${1:-}" ] && return 1
	# TODO check if the source is valid first!!!
	_isSourceSet && _stateSet "currentSource" "${1}"
	export _currentSource=${1}
}
export -f _setSource

_saveSource() {
	# arg 1 = source name
	# arg 2 = source description
	mkdir "${_HOME}/$1"
	echo "${2}" > "${_HOME}/$1/.description"
}
export -f _saveSource

_printSourceEntities() {
	# arg 1 = source
	ls "${_HOME}/${1}"
}
export -f _printSourceEntities

_getSourceCount() {
	# arg 1 = source
	local _count=0
	_count=$(_printSourceEntities ${1} | wc -l)
	echo "$_count"
}
export -f _getSourceCount

_setViewMode() {
    # $1 sets view mode explicitly (optional)
    # $1 "toggle-search" toggles between search and default
    # With no arg, cycles to next valid mode
    
    local _viewScope
    local _viewMode
    local _nextMode
    local _transform

    # Get the current view scope and mode
    _viewScope=$(_stateRead "germFZF/viewScope")
    _viewMode=$(_stateRead "germFZF/viewMode")
    
    # Define default mode for each scope
    local _defaultMode
    case "${_viewScope}" in
        source) _defaultMode="all" ;;
        entity) _defaultMode="raw" ;;
    esac
    
    # Process the input argument
    if [[ -n ${1} ]]; then
        _nextMode=${1}
        
        # Handle toggle-search special case
        if [[ ${_nextMode} == "toggle-search" ]]; then
            if [[ ${_viewMode} == "search" ]]; then
                _nextMode=${_defaultMode}
            else
                _nextMode="search"
            fi
        else
            # Validate explicit mode
            case "${_viewScope}" in
                source)
                    case "${_nextMode}" in
                        all|search) ;; # Valid modes
                        *) _nextMode=${_defaultMode} ;; # Invalid, use default
                    esac
                    ;;
                entity)
                    case "${_nextMode}" in
                        raw|indexed|search) ;; # Valid modes
                        *) _nextMode=${_defaultMode} ;; # Invalid, use default
                    esac
                    ;;
                *)
                    _nextMode=${_defaultMode} # Unknown scope, use default
                    ;;
            esac
        fi
    else
        # No argument - cycle to next mode
        case "${_viewScope}" in
            source)
                case "${_viewMode}" in
                    all) _nextMode="search" ;;
                    search) _nextMode="all" ;;
                    *) _nextMode=${_defaultMode} ;; # Invalid current mode
                esac
                ;;
                
            entity)
                case "${_viewMode}" in
                    raw) _nextMode="firstline" ;;
										firstline) _nextMode="indexed" ;;
                    indexed) _nextMode="search" ;;
                    search) _nextMode="raw" ;;
                    *) _nextMode=${_defaultMode} ;; # Invalid current mode
                esac
                ;;
                
            *)
                _nextMode=${_defaultMode} # Unknown scope
                ;;
        esac
    fi
    
    # update the state
    _stateSet "germFZF/viewMode" "${_nextMode}"

    # construct the correct mode settings
		if [[ ${_nextMode} == "search" ]]; then
			_stateSet germFZF/headerLines/4 "search-mode on"
			_stateSet germFZF/headerLines/3 "ctrl-s search off"
			_transform+="disable-search"
			_transform+="+change-ghost(type to search)"
			_transform+="+change-preview-label(searching: )"
			_transform+="+rebind(change)"
			_transform+="+rebind(focus)"
			_transform+="+rebind(result)"
			_transform+="+reload(_loadList)"
			_transform+="+transform-header(_setHeader)"
    	_transform+="+transform-list-label(_printListLabel)"
			# put the preview-window adjustment in change and focus bindings
		else
			_stateSet germFZF/headerLines/4
			_stateSet germFZF/headerLines/3
			_transform+="+enable-search"
			_transform+="+change-ghost()"
			_transform+="+change-preview-window()"
			_transform+="+change-preview-label()"
			_transform+="+reload(_loadList)"
			_transform+="+transform-header(_setHeader)"
    	_transform+="+transform-list-label(_printListLabel)"
			_transform+="+unbind(change)"
			_transform+="+unbind(focus)"
			_transform+="+unbind(result)"
			_transform+="+clear-query+first"
			# mode-specific changes
			if [[ ${_nextMode} == "firstline" && ${_viewScope} == "entity" ]]; then
  			# For firstline mode, match against all but the last field (the key)
				# this means that we must always set it back to (..) with esc, etc
				_transform+="+change-nth(..-2)" 
   		else
				# For other modes (raw, all, indexed, etc.), match on the entire line
				_transform+="+change-nth(..)" 
			fi
		fi

		# return transform string to fzf
    echo "${_transform}"
}
export -f _setViewMode

_searchCenterPreviewWindow () {
	exec 2>>/tmp/fzf.debug

	# triggered by change and focus when in search mode
	# reads the selection from rg and extracts the line number
	# sets the preview window offset to center on selected line
	local _selection=${1}
	local _lineNumber
	local _center
	local _transform
	_lineNumber=$(echo ${_selection} | cut -d: -f2)
	_center=$(( $FZF_PREVIEW_LINES / 2 ))
	_transform+="+change-preview-window(+${_lineNumber}-6/${_center})"
	_transform+="+change-preview-label(searching: ${FZF_QUERY})"
	_debug "${FUNCNAME[0]}: change-preview-window +${_lineNumber}-6/${_center}"
	echo ${_transform}
}
export -f _searchCenterPreviewWindow

_XsetViewMode() {
	# $1 sets view mode explicity (optional)
	# $1 "toggle-search" toggles between raw/search
	# with no arg, cycles to next valid mode
	# used as fzf transform action

	local _viewScope
	local _viewMode
  local _nextState
	local _transform

	# get the current view scope
	_viewScope=$(_stateRead germFZF/viewScope)
	# get the current view mode
	_viewMode=$(_stateRead "germFZF/viewMode")
	
	# read $1 to _nextState if provided
	if [[ -n ${1} ]]; then
		_nextState=${1}
		# perform toggle if directed
		if [[ ${_nextState} == "toggle-search" ]]; then
			# toggle search mode
			if [[ ${_viewMode} == "search" ]]; then
				_nextState=default
			else
				_nextState=search
			fi
		fi

	# no directive, simply cycle to the next
	else
		case "${_viewScope}" in
			source)
				case "${_viewMode}" in
					raw)
						# simple list of sources
						_nextState="search"
						;;
					search)
						# rg-produced list
						_nextState="raw"
						;;
					*)
						# default is raw
						_nextState="raw"
						;;
				esac
			;;
		entity)
			case "${_viewMode}" in
				raw)
					# viewing raw entity file names (1741753269.081301248)
					_nextState="indexed"
					;;
				indexed)
					# raw entity file names converted into indexed integers (1,2,3...)
					# we use TAB for delimiter, thus line is "1 \t 1741753269.081301248"
					_nextState="search"
					;;
				search)
					# rg-produced line numbers (text \t file \n line)
					_nextState="raw"
					;;
				*)
					# default mode is raw
					_nextState="raw"
					;;
			esac
			;;
    esac
	fi
  
	# Update the state using _stateSet
  _stateSet "germFZF/viewMode" "${_nextState}"

	# trigger searchmode check
	#_transform+="transform(_searchMode {})"
	#_transform+="+clear-query+first"
	
	# return the transform string
	_transform+="+reload(_loadList)"
	_transform+="+transform-list-label(_printListLabel)"
	echo ${_transform}
}
export -f _XsetViewMode

_printListLabel() {
	# print the label for the list based on the current view context and mode
	local _viewScope
	local _viewMode
	
	# determine the current view context
	_viewScope=$(_stateRead "germFZF/viewScope")

	# determine the source view mode
	_viewMode=$(_stateRead "germFZF/viewMode")

	echo "${_viewScope}:${_viewMode}"
}
export -f _printListLabel


##################################################################
##################################################################
##########     germFZF
##################################################################
##################################################################

_germFZF () {
	# an fzf-based UI for germ

	# clear the screen to remove previous terminal artifacts
	#clear

	# define whether the germFZF state data remains persistent
	# not clear whether the use case exists for this
	local _germFZFstatePersistence=false
	if [[ ${_germFZFstatePersistence:-false} = false ]]; then
		# clean out the state directory
		rm -rf "${_HOME}/.state/germFZF"
		mkdir -p "${_HOME}/.state/germFZF" 
	else
		# make sure the base is there
		mkdir -p "${_HOME}/.state/germFZF" 
	fi
	# set up the defaults
  _viewScope=$(_stateRead "germFZF/viewScope") || _viewScope="source"
  _stateSet "germFZF/viewScope" "$_viewScope"
  _viewMode=$(_stateRead "germFZF/viewMode") || _viewMode="all"
  _stateSet "germFZF/viewMode" "$_viewMode"

	# run the fzf loop, building the fzf command with an array
	while true; do
		# basic fzf defaults
		FZF_COMMAND=()
		FZF_COMMAND+=(--no-multi)				# limits to single selection
		FZF_COMMAND+=(--no-mouse)				# prevents mouse interaction
		FZF_COMMAND+=(--ansi)						# enables ansi color code processing
		FZF_COMMAND+=(--print-query)		# prints the query term as the first line
		FZF_COMMAND+=(--exact)					# enables exact-match

		# look and feel
		# main border style and color
		FZF_COMMAND+=(--style=full)			# all the borders
		FZF_COMMAND+=(--border=rounded)
		FZF_COMMAND+=(--margin=1%)	# sets the margin outside (T,R,B,L)
		FZF_COMMAND+=(--padding=1%,0%,1%,0%) # sets padding inside (T,R,B,L)
		FZF_COMMAND+=(--border-label="germ")	# sets the border label
		FZF_COMMAND+=(--border-label-pos=7)
		FZF_COMMAND+=(--color='border:#85846b,label:11')
		# header border
		FZF_COMMAND+=(--header-border)	# prints header border
		FZF_COMMAND+=(--header-label="guidance")	# sets the header label
		FZF_COMMAND+=(--color='header-border:#b8733b,header-label:#eeb71b')
		# the input field
		FZF_COMMAND+=(--input-label="search")
		FZF_COMMAND+=(--color='input-border:#21a269,input-label:#2ee66e')
		# the info-command inside the input border (includes command errors)
		FZF_COMMAND+=(--info=default)
		FZF_COMMAND+=(--info-command='echo -e "\x1b[33;1m$FZF_POS\x1b[m/$FZF_INFO"')
		# the list border
		FZF_COMMAND+=(--color='list-border:#073f6c,list-label:#2aa1b3,scrollbar:#85846b')
		# the preview border
		FZF_COMMAND+=(--color='preview-border:#073f6c,preview-label:#2aa1b3,preview-scrollbar:#a3306a')
		
		# the preview window
		FZF_COMMAND+=(--preview="_preview {} {q} {+n}")
		FZF_COMMAND+=(--preview-window="75%,right,nowrap,border-top,~6")
		#FZF_COMMAND+=(--preview-window="60%,wrap,border-top,<100(75%,nowrap)")
		# this broke _searchMode preview window placement when screen was small
		
		# initial load and setup
		FZF_COMMAND+=(--header="loading...")
		FZF_COMMAND+=(--bind="start:reload(_loadList)")
		# FOLD INTO TRANSenter
		FZF_COMMAND+=(--bind="start:+transform-header(_setHeader '1:select $(printf \\u2215) create')")
		FZF_COMMAND+=(--bind="start:+transform-header(_setHeader '2:$(printf \\uff1f) for help')")
		FZF_COMMAND+=(--bind='start:+transform-list-label(_printListLabel)')

		# make tab work like command completion
		FZF_COMMAND+=(--bind="tab:replace-query")

		# reverse the order of the list
		FZF_COMMAND+=(--bind="ctrl-r:transform-prompt(_toggleSearchOrder)")
		FZF_COMMAND+=(--bind="ctrl-r:+reload(_loadList)+first")
		
		# list navigation shortcuts
		FZF_COMMAND+=(--bind="alt-shift-up:page-up")
		FZF_COMMAND+=(--bind="alt-shift-down:page-down")
		FZF_COMMAND+=(--bind="alt-up:half-page-up")
		FZF_COMMAND+=(--bind="alt-down:half-page-down")

		# preview scrolling (semi page) [use ctrl-p for less]
		FZF_COMMAND+=(--bind="ctrl-space:preview-half-page-down")
		FZF_COMMAND+=(--bind="ctrl-b:preview-half-page-up")

		# action triggers
		
		# bind esc to return to source and reset state
		FZF_COMMAND+=(--bind="esc:transform(_transformReset)")

		# enter selects (or triggers new) and changes state
		FZF_COMMAND+=(--bind="enter:execute(_processEnter {} {q})")
		FZF_COMMAND+=(--bind="enter:+transform(_transformEnter)")

		# navigation alt-right and alt-left pseudo forward and back
		FZF_COMMAND+=(--bind="alt-left:execute-silent(_navigateBack)")
		FZF_COMMAND+=(--bind="alt-left:+reload(_loadList)")
		FZF_COMMAND+=(--bind="alt-left:+transform-header(_setHeader '3:,4:,5:,6:')")
		FZF_COMMAND+=(--bind="alt-left:+clear-query+first")
		FZF_COMMAND+=(--bind="alt-left:+change-nth(..)")
		# alt-right (same as enter)
		FZF_COMMAND+=(--bind="alt-right:execute(_processEnter {} {q})")
		FZF_COMMAND+=(--bind="alt-right:+transform(_transformEnter)")
		FZF_COMMAND+=(--bind="alt-right:+change-nth(..)")

		# delete selected source
		FZF_COMMAND+=(--bind="ctrl-delete:execute-silent(_EXEdeleteSource {})")
		FZF_COMMAND+=(--bind="ctrl-delete:+change-preview-window(up,20%,<24(up,35%))")
		FZF_COMMAND+=(--bind="ctrl-delete:+change-input-label(delete ?)")
		FZF_COMMAND+=(--bind="ctrl-delete:+transform-ghost(echo -e type \'{}\' then hit enter to confirm deletion)")
		FZF_COMMAND+=(--bind="ctrl-delete:+reload(echo -e 'cancel\n{}')")
		FZF_COMMAND+=(--bind="ctrl-delete:+transform-header(_setHeader)+clear-query+first")

		# rename source 
		FZF_COMMAND+=(--bind="alt-r:execute-silent(_stateSet germFZF/nextObject {})")
		FZF_COMMAND+=(--bind="alt-r:+execute-silent(_stateSet germFZF/nextAction rename-source)")
		FZF_COMMAND+=(--bind="alt-r:+change-input-label(new name:)")
		FZF_COMMAND+=(--bind="alt-r:+change-ghost(select new name)")
		FZF_COMMAND+=(--bind="alt-r:+transform-header(_setHeader '3:rename {}')")
		FZF_COMMAND+=(--bind="alt-r:+clear-query")

		# merge selected source into another
		# merge another source into selected
		# split source
		# edit source description

		# add new entity
		FZF_COMMAND+=(--bind="ctrl-n:execute-silent(_stateSet germFZF/nextAction new-entity)")
		FZF_COMMAND+=(--bind="ctrl-n:+execute(_processEnter {} {q} {n})")
		FZF_COMMAND+=(--bind="ctrl-n:+transform-header(_setHeader)")
		FZF_COMMAND+=(--bind="ctrl-n:+reload(_loadList)")
		FZF_COMMAND+=(--bind="ctrl-n:+first+clear-query")
		
		# create new "typed query" source 
		FZF_COMMAND+=(--bind="alt-enter:execute-silent(_stateSet germFZF/nextAction new-source)")
		FZF_COMMAND+=(--bind="alt-enter:+execute(_processEnter {} {q} {n})")
		FZF_COMMAND+=(--bind="alt-enter:+transform-header(_setHeader)")
		FZF_COMMAND+=(--bind="alt-enter:+reload(_loadList)")
		FZF_COMMAND+=(--bind="alt-enter:+first+clear-query")

		# use pager to read selected
		FZF_COMMAND+=(--bind="ctrl-p:execute-silent(_stateSet germFZF/nextAction read)")
		FZF_COMMAND+=(--bind="ctrl-p:+execute(_processEnter {} {q} {n})")
		FZF_COMMAND+=(--bind="ctrl-p:+refresh-preview")

		# ctrl-alt-s search group (BROKEN)
		FZF_COMMAND+=(--bind="ctrl-alt-s:change-multi+select-all")
		FZF_COMMAND+=(--bind="ctrl-alt-s:+execute-silent(_toggleSearchMode)")
		FZF_COMMAND+=(--bind="ctrl-alt-s:+transform(_searchGroup {+} {q})+clear-query")


		# ctrl-v cycles the view mode
		FZF_COMMAND+=(--bind="ctrl-v:transform(_setViewMode)")
		
		# ctrl-s toggle search on/off
		FZF_COMMAND+=(--bind="ctrl-s:transform(_setViewMode toggle-search)")

		# search mode bindings
		# these bindings are unbound by default, and rebound in search mode
		# event:change triggers when query string changes
		#  updates search and selection and preview offset
		FZF_COMMAND+=(--bind="change:+reload(_loadList)")
		FZF_COMMAND+=(--bind="start:+unbind(change)")
		# event:focus triggers on vertical cursor move or search result update
		# focus updates selection and preview offset
		FZF_COMMAND+=(--bind="focus:+transform(_searchCenterPreviewWindow {})")
		FZF_COMMAND+=(--bind="start:+unbind(focus)")
		# event:result triggers when the filtering of a query change is complete
		# result updates the preview offset
		FZF_COMMAND+=(--bind="result:+transform(_searchCenterPreviewWindow {})+refresh-preview")
		FZF_COMMAND+=(--bind="start:+unbind(result)")

		# help (toggles preview)
		FZF_COMMAND+=(--bind="?:change-preview(_previewHelp)")
		FZF_COMMAND+=(--bind="?:+transform-header(_setHeader '2:,3:$(printf \\u2215) to close help')")
		FZF_COMMAND+=(--bind="/:change-preview(_preview {} {q} {n})")
		FZF_COMMAND+=(--bind="/:+transform-header(_setHeader '2:$(printf \\uff1f) for help,3:')")

		# catch common keys and notify accordingly
		FZF_COMMAND+=(--bind="ctrl-g:transform-header(_setHeader '3:ctrl-q to quit')")
		FZF_COMMAND+=(--bind="ctrl-c:transform-header(_setHeader '3:ctrl-q to quit')")
		FZF_COMMAND+=(--bind="ctrl-z:transform-header(_setHeader '3:ctrl-q to quit,4:test message,5:debug line,6:alert')")
		FZF_COMMAND+=(--bind="backward-eof:transform-header(_setHeader '3:ctrl-q to quit')")
		FZF_COMMAND+=(--bind="ctrl-d:transform-header(_setHeader '3:ctrl-q to quit')")

		# the exit / abort command is ctrl-q
		FZF_COMMAND+=(--bind="ctrl-q:abort")

		# assign the fzf results to _selection (what was "selected")
		# abort returns 1, so just break then
		_FZF_selection=$(fzf "${FZF_COMMAND[@]}") || break

		# this needs to get fixed...question, will this ever be used to pass
		# results back?

		# split out the query string into $query
		query=$(echo "${_FZF_selection}" | head -n1)

		# assign the selection to $selection (note no MULTI SELECT yet)
		selection=$(echo "${_FZF_selection}" | tail -n1)
		_debug "${FUNCNAME[0]}: query is '${query}'"
		_debug "${FUNCNAME[0]}: selection is '${selection}'"

		# finally, return the two values into the nameref _return (colon-separated)
		_return="${query}:${selection}"
		break
	done
}

##################################################################
##################################################################
##########     germFZF flow logic
##################################################################
##################################################################

_processEnter () {
	exec 2>>/tmp/fzf.debug
	#set -x
	# fzf inputs
	local _selection=${1:-}
	local _query=${2:-}
	local _position=${FZF_POS}
	local _nth=${FZF_NTH}
	local _totalcount=${FZF_TOTAL_COUNT}
	local _matchcount=${FZF_MATCH_COUNT}
	local _selectcount=${FZF_SELECT_COUNT}
	local _lastkey=${FZF_KEY}
	# current state
	local _viewScope
	local _viewMode	
	local _viewContext
	# trigger action and object
	local _triggerAction	# triggered by fzf
	local _triggerObject
	# decision
	local _nextAction			# select, edit, read, etc
	local _nextObject			# the selection
	local _nextType				# what is it
	local _nextContext		# source name
	local _nextLine				# optional line number (from search)
	# next state
	local _nextViewScope
	local _nextViewMode
	local _nextViewContext

	# read the current state
	_viewScope=$(_stateRead germFZF/viewScope)
	_viewMode=$(_stateRead germFZF/viewMode)
	_viewContext=$(_stateRead germFZF/viewContext)

	# read the nextAction (and object) trigger state (and clear immediately)
	_triggerAction=$(_stateRead germFZF/nextAction)
	_triggerObject=$(_stateRead germFZF/nextObject)
	_stateSet germFZF/nextAction
	_stateSet germFZF/nextObject

	# clear last error etc header messages
	_stateSet germFZF/headerLines/3
	_stateSet germFZF/headerLines/4
	_stateSet germFZF/headerLines/5
	_stateSet germFZF/headerLines/6

	# first check trigger action
	if [[ -n ${_triggerAction} ]]; then
		_debug "${FUNCNAME[0]}: trigger    : ${_triggerAction}"
		_nextAction=${_triggerAction}
		if [[ -n ${_triggerObject} ]]; then
			_debug "${FUNCNAME[0]}: trigger object: ${_triggerObject}"
			_nextObject=${_triggerObject}
		fi
	fi

	# in source mode
	if [[ ${_viewScope} == "source" ]]; then
		_debug "${FUNCNAME[0]}: source mode"
		# first check if in search mode
		if [[ ${_viewMode} == "search" ]]; then
			_debug "${FUNCNAME[0]}: search mode"
			# parse the selection (source/file:line)
			IFS='/:' read -r _source _file _line <<< "${_selection}"
			# edit, unless triggerAction pre-set the action
			_nextAction=${_nextAction:-edit}
			_nextObject=${_nextObject:-${_file}}
			_nextContext=${_source}
			_nextLine=${_line}
			_nextType=$(_getType "${_nextObject}" "${_viewScope}")
			# these don't change
			_nextViewScope=${_viewScope}
			_nextViewContext=${_nextContext}
			# but we exit search mode to return to all
			_nextViewMode=all
		# next check if not in search mode
		else
			# use seeded trigger, otherwise, use select
			_nextAction=${_nextAction:-select}
			_nextObject=${_nextObject:-$(_determineSelection "${_selection}" "${_query}")}
			_nextType=$(_getType "${_nextObject}" "${_viewScope}")
			_nextContext=${_nextObject}
			# set up next state (source switch to entity)
			_nextViewScope=entity
			_nextViewMode=raw
			_nextViewContext=${_nextContext}
		fi

	# in entity mode
	elif [[ ${_viewScope} == "entity" ]]; then
		_debug "${FUNCNAME[0]}: entity mode"
		# first check if in search mode
		if [[ ${_viewMode} == "search" ]]; then
			_debug "${FUNCNAME[0]}: search mode"
			# parse the selection (source/file:line)
			IFS='/:' read -r _source _file _line <<< "${_selection}"
			# edit, unless triggerAction pre-set the action
			_nextAction=${_nextAction:-edit}
			_nextObject=${_nextObject:-${_file}}
			_nextContext=${_source}
			_nextLine=${_line}
			_nextType=$(_getType "${_nextObject}" "${_viewScope}")
			# these don't change
			_nextViewScope=${_viewScope}
			_nextViewContext=${_nextContext}
			# but we exit search mode to return to raw
			_nextViewMode=raw
		# next check if not in search mode
		else
    	# _selection will be "Display Name\tActualFilename" in 'firstline' mode
      # or just "ActualFilename" in 'raw' mode
      if [[ ${_viewMode} == "firstline" ]]; then
				_debug "${FUNCNAME[0]}: firstline mode"
        # Extract the actual filename (second field)
				IFS=$'\t' read -r _firstLine _file <<< "${_selection}"
				_debug "SELECTING ${_file}"
        _nextObject=${_file}
      fi
      # use seeded trigger, otherwise, use edit
      _nextAction=${_nextAction:-edit}
      _nextType=$(_getType "${_nextObject}" "${_viewScope}") # _viewScope is correct here
      _nextContext=${_viewContext} # _viewContext is the current source name
		fi
	fi

	# print the conditions
	_debug "===processEnter========================================="
	_debug "${FUNCNAME[0]}: fzf selection   : $_selection"
	_debug "${FUNCNAME[0]}: fzf query       : $_query"
	_debug "${FUNCNAME[0]}: fzf position    : $_position"
	_debug "${FUNCNAME[0]}: fzf nth         : $_nth"
	_debug "${FUNCNAME[0]}: fzf total count : $_totalcount"
	_debug "${FUNCNAME[0]}: fzf match count : $_matchcount"
	_debug "${FUNCNAME[0]}: fzf select count: $_selectcount"
	_debug "${FUNCNAME[0]}: fzf last key    : $_lastkey"
	_debug "${FUNCNAME[0]}: viewScope       : $_viewScope"
	_debug "${FUNCNAME[0]}: viewMode        : $_viewMode"
	_debug "${FUNCNAME[0]}: viewContext     : $_viewContext"
	_debug "${FUNCNAME[0]}: triggerAction   : $_triggerAction"
	_debug "${FUNCNAME[0]}: triggerObject   : $_triggerObject"
	_debug "${FUNCNAME[0]}: nextAction      : $_nextAction"
	_debug "${FUNCNAME[0]}: nextObject      : $_nextObject"
	_debug "${FUNCNAME[0]}: nextType        : $_nextType"
	_debug "${FUNCNAME[0]}: nextContext     : $_nextContext"
	_debug "${FUNCNAME[0]}: nextLine        : $_nextLine"
	_debug "${FUNCNAME[0]}: nextViewScope   : $_nextViewScope"
	_debug "${FUNCNAME[0]}: nextViewMode    : $_nextViewMode"
	_debug "${FUNCNAME[0]}: nextViewContext : $_nextViewContext"

	# now perform the action
	# if select, just set state and return
	# this returns to fzf trigger which should _loadList
	if [[ ${_nextAction} == "select" ]]; then
		# save current state to backStack (if anything changed)
  	if [[ "${_nextViewScope}" != "${_viewScope}" || 
  		"${_nextViewMode}" != "${_viewMode}" || 
  		"${_nextViewContext}" != "${_viewContext}" ]]; then
   		_pushBackStack
  	fi
		# update the state and return (nothing more to do)
		_stateSet germFZF/viewScope "${_nextViewScope}"
		_stateSet germFZF/viewMode "${_nextViewMode}"
		_stateSet germFZF/viewContext "${_nextViewContext}"
		return
	
	else
		case ${_nextAction} in
			edit)
				# edit
				if _editEntity "${_nextContext}" "${_nextObject}" "${_nextLine:-}"; then
					_stateSet germFZF/headerLines/4 "change committed"
				else
					case $? in
						1)
							# changed, but uncommitted
							_stateSet germFZF/headerLines/6 "no commit!"
							;;
						2)
							# unchanged file
							_stateSet germFZF/headerLines/6 "no change"
							;;
						3)
							# file not found
							_stateSet germFZF/headerLines/6 "no such file"
							;;
					esac
				fi
				# the state does not change...?
				_stateSet germFZF/viewScope "${_viewScope}"
				_stateSet germFZF/viewMode "${_viewMode}"
				_stateSet germFZF/viewContext "${_viewContext}"
				;;
			new-source)
				# create a new source
				if _createSource "${_nextObject}"; then
					_stateSet germFZF/headerLines/4 "new source created"
					_stateSet germFZF/viewScope "${_nextViewScope}"
					_stateSet germFZF/viewMode "${_nextViewMode}"
					_stateSet germFZF/viewContext "${_nextObject}"
				else
					case $? in
						1)
							# created, but uncommitted
							_stateSet germFZF/headerLines/6 "no commit!"
							;;
						2)
							# invalid name
							_stateSet germFZF/headerLines/6 "invalid name!"
							;;
						3)
							# source exists
							_stateSet germFZF/headerLines/6 "source exists!"
							;;
						4)
							# failed to make source
							_stateSet germFZF/headerLines/6 "failed create!"
							;;
					esac
				fi
				;;

			new-entity)
				# create a new entity in the designated source
				# and open for edit
				if _newEntity "${_nextContext}"; then
					_stateSet germFZF/headerLines/4 "new entitiy committed"
				else
					case $? in
						1)
							# created, but uncommitted
							_stateSet germFZF/headerLines/6 "no commit!"
							;;
						2)
							# aborted
							_stateSet germFZF/headerLines/6 "no file"
							;;
					esac
				fi
				;;

			delete-source)
				# if empty, just do it
  			if [[ $(_getSourceCount "${_nextObject}") == 0 ]]; then
    			_info "'${_nextObject}' is empty"
    			_stateSet germFZF/headerLines/5 "${_nextObject} is empty"
				# otherwise, use confirm-delete routine
				else
					_stateSet germFZF/viewScope confirm-delete
				fi
				;;

			delete-confirm)
				# coming back from the delete-confirm routine
				# check that _query matches
				if [[ ${_query} == ${_viewContext} ]]; then
					# it is safe now to delete
					if _deleteSource "${_viewContext}"; then
						_stateSet germFZF/viewScope source
						_stateSet germFZF/viewContext
						_stateSet germFZF/viewMode all
					else
						case $? in
							1)
								# deleted, but uncommitted
								_stateSet germFZF/headerLines/6 "no commit!"
								;;
							2)
								# empty request
								_stateSet germFZF/headerLines/6 "cannot delete nothing"
								;;
							3)
								# cannot delete default
								_stateSet germFZF/headerLines/6 "cannot delete default"
								;;
						esac
					fi
				else
					# we did not get the typed confirmation
					_stateSet germFZF/headerLines/6 "no confirmation!"
				fi
				;;

			rename-source)
  			# Rename the source from _nextObject to query
			  if [[ -z "${_nextObject}" ]]; then
 			  	_stateSet germFZF/headerLines/6 "no source selected"
   				return
  			fi
  
  			if [[ -z "${_query}" ]]; then
    			_stateSet germFZF/headerLines/6 "no name provided"
    			return
  			fi
  
  			# Don't allow renaming default
  			if [[ "${_nextObject}" == "default" ]]; then
    			_stateSet germFZF/headerLines/6 "cannot rename 'default'"
    			return
  			fi
  
  			# Attempt to rename the source
  			if _renameSource "${_nextObject}" "${_query}"; then
    			_stateSet germFZF/headerLines/4 "renamed '${_nextObject}' to '${_query}'"
    			_stateSet germFZF/viewScope "source"
    			_stateSet germFZF/viewMode "all"
  			else
    			case $? in
     				1)
        			# Git operation failed
        			_stateSet germFZF/headerLines/6 "git operation failed!"
        			;;
      			2)
        			# Invalid old source
        			_stateSet germFZF/headerLines/6 "source not found!"
        			;;
      			3)
        			# Invalid new name
        			_stateSet germFZF/headerLines/6 "invalid name!"
        			;;
      			4)
        			# New name already exists
        			_stateSet germFZF/headerLines/6 "name exists!"
        			;;
    			esac
  			fi
  			;;

			read)
				# read with pager
				# Check if selection is a source directory or an entity
				if [[ ${_viewScope} == "source" && ${_nextType} == "source" ]]; then
					# page through all files in the source directory
					_pager "${_nextObject}"
				else
					# page single entity
					_pager "${_nextContext}" "${_nextObject}"
				fi
				;;
		esac
	fi
}
export -f _processEnter

_transformReset () {
	# reset back to normal mode
	# used for ESC
	local _transform
	_transform+="+execute-silent(_stateSet germFZF/viewScope source)"
	_transform+="+execute-silent(_stateSet germFZF/viewMode all)"
	_transform+="+execute-silent(_stateSet germFZF/viewContext)"
	_transform+="+execute-silent(_stateSet germFZF/nextAction)"
	_transform+="+execute-silent(_clearBackStack)"
	_transform+="+transform-header(_setHeader '1:select $(printf \\u2215) create')"
	_transform+="+transform-header(_setHeader '2:$(printf \\uff1f) for help')"
	_transform+="+transform-header(_setHeader '3:ctrl-q to quit,4:,5:,6:')"
	_transform+="+transform-header(_setHeader)"
	_transform+="+transform-list-label(_printListLabel)"
	_transform+="+change-preview-window(right,75%)"
	_transform+="+change-preview(_preview {} {q} {n})"
	_transform+="+change-ghost()"
	_transform+="+enable-search"
	_transform+="+change-input-label(search)"
	_transform+="+reload(_loadList)"
	_transform+="+change-nth(..)" 
	_transform+="+clear-query"
	_transform+="+first"
	echo ${_transform}
}
export -f _transformReset

_transformEnter () {
	# reset back to normal mode
	# used after _processEnter
	local _transform
	_transform+="+transform-header(_setHeader)"
	_transform+="+change-preview-window(right,75%)"
	_transform+="+transform-list-label(_printListLabel)"
	_transform+="+change-ghost()"
	_transform+="+change-input-label(search)"
	_transform+="+reload(_loadList)"
	_transform+="+clear-query"
	_transform+="+first"
	echo ${_transform}
}
export -f _transformEnter

##################################################################
##################################################################
##########     germFZF navigation
##################################################################
##################################################################

_pushBackStack() {
    # Push current state onto the backStack as a colon-separated tuple
    # Usage: _pushBackStack
    
    # Read current state values
    local _currentScope=$(_stateRead "germFZF/viewScope")
    local _currentContext=$(_stateRead "germFZF/viewContext")
    local _currentMode=$(_stateRead "germFZF/viewMode")
    
    # Get the current stack height
    local _stackDir="${_HOME}/.state/germFZF/backStack"
    mkdir -p "${_stackDir}"
    local _stackHeight=$(find "${_stackDir}" -mindepth 1 -maxdepth 1 -type d | wc -l)
    local _nextIndex=$((_stackHeight + 1))
    
    # Create a new directory for this stack item
    local _itemDir="${_stackDir}/${_nextIndex}"
    mkdir -p "${_itemDir}"
    
    # Store the full state as a single tuple file
    local _stateTuple="${_currentScope}:${_currentContext}:${_currentMode}"
    touch "${_itemDir}/${_stateTuple}"
}
export -f _pushBackStack

_popBackStack() {
    # Pop and restore a state from the backStack
    # Returns 0 on success, 1 if stack is empty
    
    # Get the current stack height
    local _stackDir="${_HOME}/.state/germFZF/backStack"
    [[ ! -d "${_stackDir}" ]] && mkdir -p "${_stackDir}"
    
    local _stackHeight=$(find "${_stackDir}" -mindepth 1 -maxdepth 1 -type d | wc -l)
    [[ ${_stackHeight} -eq 0 ]] && return 1
    
    # Get the top stack item directory
    local _topItemDir="${_stackDir}/${_stackHeight}"
    
    # The state is stored as a single file with the tuple format: "context:object:mode"
    local _stateFile=$(find "${_topItemDir}" -maxdepth 1 -type f -not -name ".*" | head -1)
    local _stateTuple=$(basename "${_stateFile}")
    
    # Parse the tuple
    IFS=':' read -r _prevScope _prevContext _prevMode <<< "${_stateTuple}"
    
    # Set defaults if parsing failed
    _prevScope=${_prevScope:-source}
    _prevContext=${_prevContext:-}
    _prevMode=${_prevMode:-all}
    
    # Set the state to the previous state
    _stateSet germFZF/viewScope "${_prevScope}"
    _stateSet germFZF/viewContext "${_prevContext}"
    _stateSet germFZF/viewMode "${_prevMode}"
    
    # Remove the stack item
    rm -rf "${_topItemDir}"
    
    # Return success
    return 0
}
export -f _popBackStack

_clearBackStack() {
    # Clear the entire backStack
    rm -rf "${_HOME}/.state/germFZF/backStack"
    mkdir -p "${_HOME}/.state/germFZF/backStack"
}
export -f _clearBackStack

_navigateBack() {
    # Navigate back using the backStack
    # Called by alt-left or after actions like edit
    if ! _popBackStack; then
        # If stack is empty, return to main view
        _stateSet germFZF/viewScope "source"
        _stateSet germFZF/viewMode "all"
        _stateSet germFZF/viewContext ""
    fi
}
export -f _navigateBack

_determineSelection () {
	# given fzf state input, decide on query vs selection
	# print either the query or the selection
	local selection=${1:-}
	local query=${2:-}
	local position=${FZF_POS}

	# case 1 (no query present: use selection)
	if [[ -z "${query}" && -n "${selection}" ]]; then
		echo ${selection}
		return
	# case 2 (unique query: use query)
	elif [[ -n "${query}" && -z "${selection}" ]]; then
		echo ${query}
		return
	elif [[ -n "${query}" && -n "${selection}" ]]; then
		# case 3 (exact match: use selection)
		if [[ ${query} == "${selection}" ]]; then
			echo ${selection}
			return
		fi
		# case 4 (partial match, no cursor movement)
		if [[ ${position} -eq 1 ]]; then
			echo ${selection}
			return
		else
			# case 5 (partial match, cursor movement)
			echo ${selection}
			return
		fi
	else
		return 1
	fi
}
export -f _determineSelection

_getType () {
		exec 2>>/tmp/fzf.debug
		#set -x
    # Determines the type of a selected item based on its format and context
    # $1 = selected item name
    # $2 = current view context
    # Returns the determined type ("source", "entity", "index")
		# returns empty if unknown
    
    local _selection="${1:-}"
    local _viewContext="${2:-source}"
		local _viewMode
		_viewMode=$(_stateRead germFZF/viewMode)

		_debug "${FUNCNAME[0]}: type of ${_selection} in ${_viewContext}"
    
    case "${_viewContext}" in
        "source")
            # In source view, items are only sources
						# unless we are in search mode

   					# Simple check - if it exists as a source, it's a source
    				if _doesNameExist "source" "${_selection}"; then
        			echo "source"
						# otherwise we don't know
						elif [[ ${_viewMode} == "search" ]]; then
							echo "entity"
						fi
            ;;
            
        "entity")
            # In entity view, the type depends on the viewMode
						# because we will have index types soon
            case "${_viewMode}" in
                "raw")
                    echo "entity"
                    ;;
                "firstline")
                    echo "entity"
                    ;;
                "search")
                    echo "entity"
                    ;;
                *)
                    echo "unknown"
                    ;;
            esac
            ;;
            
        "index")
            # Index view only contains index items
            echo "index"
            ;;
            
        *)
            # Default fallback
            echo "unknown"
            ;;
    esac
}
export -f _getType 

_toggleSearchOrder() {
    # Check the current FZF_PROMPT and toggle between "> " and "^> "
    if [[ "${FZF_PROMPT}" == "> " ]]; then
        # If the prompt is "> ", switch to "^> "
        echo "^> "
    else
        # Otherwise, switch to "> "
        echo "> "
    fi
}
export -f _toggleSearchOrder

_isSearchReversed() {
    # Check if the FZF_PROMPT indicates reversed search
    if [[ "${FZF_PROMPT}" == "^> " ]]; then
        return 0 # Reversed
    else
        return 1 # Not reversed
    fi
}
export -f _isSearchReversed

##################################################################
##################################################################
##########     germFZF list
##################################################################
##################################################################

_loadList() {
	exec 2>>/tmp/fzf.debug
	#set -x
	# dynamically produce a list for fzf based on context
	# this function is more of a broker...it calls the real list makers in case()
	# arg 1 (optional) view scope (source,entity)
	# arg 2 (optional) view mode (all,smart, etc)
	# arg 3 (optional) view context (ie object)
    local _param_viewScope=${1:-}
    local _param_viewMode=${2:-}
    local _param_viewContext=${3:-} # Parameter for viewContext

    local _viewScope
    local _viewMode
    local _viewContext

    # Determine the current view scope
    if [[ -n "${_param_viewScope}" ]]; then
        _viewScope="${_param_viewScope}"
    else
        _viewScope=$(_stateRead "germFZF/viewScope") || _viewScope="source"
    fi

    # Determine the view mode
    if [[ -n "${_param_viewMode}" ]]; then
        _viewMode="${_param_viewMode}"
    else
        _viewMode=$(_stateRead "germFZF/viewMode")
    fi

    # Determine the view context
    if [[ -n "${_param_viewContext}" ]]; then
        _viewContext="${_param_viewContext}"
    else
        _viewContext=$(_stateRead "germFZF/viewContext")
    fi

    _debug "${FUNCNAME[0]}: view scope    : ${_viewScope}"
    _debug "${FUNCNAME[0]}: view mode     : ${_viewMode}"
    _debug "${FUNCNAME[0]}: view context  : ${_viewContext}"

    local _generatedListOutput

    # Capture the output of the list generation logic
    _generatedListOutput=$(
        case "${_viewScope}" in
            "source")
                if [[ ${_viewMode} == "search" ]]; then
                    local _query=${FZF_QUERY:-'.'}
                    # rg output will be sorted externally
                    rg --color=always --line-number --no-heading --smart-case \
                        --glob=!.*/ "${_query}" * || true
                else # "all" mode
                    ls "${_HOME}"
                fi
                ;;
            "entity")
                if [[ ${_viewMode} == "search" ]]; then
                    local _query=${FZF_QUERY:-'.'}
                    # rg output will be sorted externally
                    rg --color=always --line-number --no-heading --smart-case \
                        --glob=!.*/ "${_query}" "${_viewContext}" || true
                elif [[ ${_viewMode} == "raw" ]]; then
                    ls "${_viewContext}"
                elif [[ ${_viewMode} == "firstline" ]]; then
                    local _entityFile
                    # The find | sort -z is for processing order of files before _getEntityFirstLine.
                    # The final display sort (normal or reversed) is handled externally.
                    find "${_viewContext}" -mindepth 1 -maxdepth 1 -type f -not -name ".*" -print0 | sort -z | while IFS= read -r -d $'\0' _entityPath; do
                        _entityFile=$(basename "${_entityPath}")
                        _getEntityFirstLine "$(basename "${_viewContext}")" "${_entityFile}"
                    done
                elif [[ ${_viewMode} == "indexed" ]]; then
                    # This output will also be sorted externally
                    echo -e "1 mock first line\tfilename\n2 mock 2nd line\tfile2"
                fi
                ;;
        esac
    )

    # Apply final sorting based on _isSearchReversed
    if [[ -n "${_generatedListOutput}" ]]; then
        if _isSearchReversed; then
            echo "${_generatedListOutput}" | sort -r
        else
            echo "${_generatedListOutput}" | sort # Apply a default sort if not reversed
        fi
    fi
}
export -f _loadList

_getEntityList() {
	exec 2>>/tmp/fzf.debug
	# List all entities in a given source
	# $1 = view mode
	# $2 = source name
	local _viewMode="${1:-}"
	local _sourceName="${2:-}"
	local _sourceDir="${_HOME}/${_sourceName}"

	# Validate the source name
	if [[ -z "${_sourceName}" || ! -d "${_sourceDir}" ]]; then
		_warn "no source '${_sourceName}'"
		return 1
	fi

	# Find all files in the source directory and resolve them
	local _entityList=()
	while IFS= read -r -d '' file; do
		local _resolvedPath
		_resolvedPath=$(readlink -f "${file}")
		_entityList+=("$(basename "${_resolvedPath}")")
	done < <(find "${_sourceDir}" -mindepth 1 -maxdepth 1 -type f -not -name ".*" -print0)

	# Sort the entity list based on the current order
	if _isSearchReversed; then
		printf "%s\n" "${_entityList[@]}" | sort -r
	else
		printf "%s\n" "${_entityList[@]}" | sort
	fi
}
export -f _getEntityList

_getEntityFirstLine() {
    # $1: source name
    # $2: entity timestamp filename
    # Outputs: "Display Name (first line or truncated)\tActualFilename"
    # or just "ActualFilename" if file issues or empty first line.
    local _sourceName="${1}"
    local _entityFilename="${2}"
    local _filePath="${_HOME}/${_sourceName}/${_entityFilename}"
    local _firstLineDisplay
    local _maxDisplayLength=70 # Max length for the first line display

    if [[ -f "${_filePath}" ]]; then
        # Read the first non-empty line
        _firstLineDisplay=$(grep -m 1 '[^[:space:]]' "${_filePath}" || true)
        # Trim leading/trailing whitespace
        _firstLineDisplay="${_firstLineDisplay#"${_firstLineDisplay%%[![:space:]]*}"}"
        _firstLineDisplay="${_firstLineDisplay%"${_firstLineDisplay##*[![:space:]]}"}"
        
        if [[ -z "${_firstLineDisplay}" ]]; then
            # If first line is empty, use filename as display
            _firstLineDisplay="${_entityFilename}"
        elif [[ ${#_firstLineDisplay} -gt ${_maxDisplayLength} ]]; then
            # Truncate if too long
            _firstLineDisplay="${_firstLineDisplay:0:$((_maxDisplayLength-3))}..."
        fi
        echo -e "${_firstLineDisplay}\t${_entityFilename}"
    else
        # Fallback if file not found or other issues
        echo -e "${_entityFilename}\t${_entityFilename}"
    fi
}
export -f _getEntityFirstLine


##################################################################
##################################################################
##########     germFZF header
##################################################################
##################################################################

_setHeader() {
    #exec 2>>/tmp/fzf.debug
    #set -x
		#
		# to make them visible to tree in .state we will get a little tricky
		# for example, we can't use "/" in file names
		# yet we want to use:
		# headerFiles/
		#   1:manage set
		#   2:? for help
		#   3:etc
		# including
		#   2:/ to close
		# for that we use unicode since this is only display
		# touch "use $(printf \\u2215) to exit"

    # Path to the state file for header lines
    local _headerStateDir="${_HOME}/.state/germFZF/headerLines"

    # Ensure the state directory exists
    mkdir -p "$(dirname "${_headerStateDir}")"

    # Declare an associative array to store the header lines
    declare -A lines

		# create the keys
		for i in {1..6}; do
			lines["i"]=""
		done

    # Read the current headers from the state dir
		_debug "checking state"
    if [[ -d "${_headerStateDir}" ]]; then
				for keydir in "${_headerStateDir}"/*; do
						key=$(basename $keydir)
						if [[ -d $keydir ]]; then
							value=$(basename "${keydir}/"*)
            	lines["$key"]="$value"
							_debug "added key '$key' with value '$value'"
						else
							_debug "no keys found in state"
						fi
        done
    fi

    # Process the function input arguments (if any)
		_debug "processing arguments"
    local input="${1:-}"
    if [[ -n "$input" ]]; then
        IFS=',' read -r -a fields <<< "$input"
        for field in "${fields[@]}"; do
            if [[ "$field" =~ ^([0-9]+):(.*)$ ]]; then
                local line_number="${BASH_REMATCH[1]}" # Line number (1-based)
                local line_content="${BASH_REMATCH[2]}" # Line content
								if [[ -z "${line_content}" ]]; then
									# directive is to clear the line
									lines["$line_number"]=""
									_debug "clear line directive"
								else
                	# update the line
                	lines["$line_number"]="$line_content"
									_debug "update line $line_number in bash state"
								fi
            fi
        done
    fi

    # Write the updated header back to the state file
		_debug "updating state"
    for key in $(seq 1 6); do
 	  	local key_dir="${_headerStateDir}/${key}"
      if [[ -n "${lines[$key]:-}" ]]; then
        _debug "found line $key with content '${lines[$key]}'"
				# clean state before repopulating
				rm -rf "${key_dir}"/*
				# Replace Unicode symbols with their evaluated printf equivalents
        local sanitized_line="${lines[$key]}"
        sanitized_line=$(echo "$sanitized_line" | sed -e "s/？/$(printf '\uff1f')/g" -e "s/∕/$(printf '\u2215')/g")
				# create new state
        mkdir -p "${_headerStateDir}/${key}"
        touch "${_headerStateDir}/${key}/${sanitized_line}"
			else
				# line was removed
				_debug "removing line $key"
				rm -rf "${_headerStateDir}/${key}"
			fi
    done

    # Apply formatting and print the updated header for fzf
    for key in $(seq 1 6); do
	    if [[ -n "${lines[$key]:-}" ]]; then
  	    case "$key" in
       		1) printf "%s\n" "${lines[$key]}" ;;
          2) printf "\033[38;5;11m%s\033[0m\n" "${lines[$key]}" ;;
          3) printf "\033[3;38;5;13m%s\033[0m\n" "${lines[$key]}" ;;
          4) printf "\033[3;38;5;10m%s\033[0m\n" "${lines[$key]}" ;;
          5) [[ "${_DEBUG}" == "true" ]] && printf "\033[38;2;42;161;179m%s\033[0m\n" "${lines[$key]}" ;;
          6) printf "\033[3;38;5;9m%s\033[0m\n" "${lines[$key]}" ;;
        esac
      fi
    done

    # Append the viewContext as the last line in the header
		_viewContext=$(_stateRead germFZF/viewContext)
		if [[ -n ${_viewContext} ]]; then
	    printf "\033[38;5;14m%s\033[0m\n" "${_viewContext}"
		fi

}
export -f _setHeader

##################################################################
##################################################################
##########     germFZF preview
##################################################################
##################################################################

# one problem, when enter is pressed on a source name, preview
# reads the selection
# in viewscope=source
# arrow up to america
# select with enter
# _processEnter is correct
# _loadList is correct
# _preview FIRST reads selection from the first action, which triggered
# _preview to read "abcdef..."
# seems the order can be fixed?
# interesting, when i use reload-sync in _transformEnter
# _loadList and _preview interleave in the logs
# _preview still reading what _loadlist has not replaced


_preview () {
	# the main preview function
	exec 2>>/tmp/fzf.debug
	#set -x
	local _selection=${1:-}
	local _query=${2:-}
	local _index=${3:-}
	local _position=${FZF_POS}
	local _matchcount=${FZF_MATCH_COUNT}
	local _selectcount=${FZF_SELECT_COUNT}
	local _lastaction=${FZF_ACTION}
	local _viewScope
	local _viewMode
	local _viewContext
	local _queryType

	# get the current view context
	_viewScope=$(_stateRead "germFZF/viewScope")
	_viewMode=$(_stateRead germFZF/viewMode)
	_viewContext=$(_stateRead "germFZF/viewContext")

	# print the conditions
	_debug "${FUNCNAME[0]}: FZF selection       : $_selection"
	_debug "${FUNCNAME[0]}: fzf query           : $_query"
	_debug "${FUNCNAME[0]}: fzf index           : $_index"
	_debug "${FUNCNAME[0]}: fzf position        : $_position"
	_debug "${FUNCNAME[0]}: fzf last action     : $_lastaction"
	_debug "${FUNCNAME[0]}: fzf match count     : $_matchcount"
	_debug "${FUNCNAME[0]}: fzf select count    : $_selectcount"
	_debug "${FUNCNAME[0]}: viewScope           : $_viewScope"
	_debug "${FUNCNAME[0]}: viewMode            : $_viewMode"
	_debug "${FUNCNAME[0]}: viewContext         : $_viewContext"
	_debug "---------------------------------------------------"

	# preview based on type
	# preview for source
	if [[ ${_viewScope} == "source" ]]; then
		if [[ ${_viewMode} == "search" ]]; then
			# we are in search mode
			_previewSearch "${1:-}" "${2:-}"
		elif [[ ${_viewMode} == "delete-confirm" ]]; then
			# we are in the delete confirmation routine
			echo "deleting ${_viewContext}"
			tree -Ca "${_HOME}/${_viewContext}"

		else
			# not in search mode
			# if query is not null, user is typing and may want to create
			# print name feedback
			if [[ -n "${_query}" ]]; then
				_previewNameValidation "${_query}" "${_selection}" source
			fi
			#   name, description, entity count, index list
			_previewSource "${_query}" "${_selection}"
			#echo
			#echo "------SELECTED SOURCE CONTENTS-----------"
			#[[ -z "${_selection}" ]] && echo "free" || tree -Ca "${_HOME}/${_selection}"
			[[ -z "${_selection}" ]] && echo "free" || {
			echo "------SOURCE CONTENTS-----------"
			# Create an array to hold the files
			files=()
				
			# Get all files in source directory (excluding hidden files)
			while IFS= read -r file; do
				files+=("$file")
			done < <(find "${_HOME}/${_selection}" -maxdepth 1 -type f -not -path "*/\.*" | sort)
				
			# Process each file and print its first line
			counter=1
			for file in "${files[@]}"; do
				# Get first line, trim whitespace, and truncate if too long
				first_line=$(head -n 1 "$file" 2>/dev/null | tr -d '\r')
				first_line="${first_line#"${first_line%%[![:space:]]*}"}"  # trim leading whitespace
				first_line="${first_line%"${first_line##*[![:space:]]}"}"  # trim trailing whitespace
					
				# Truncate long lines
				if [[ ${#first_line} -gt 65 ]]; then
					first_line="${first_line:0:62}..."
				fi
					
				# Print formatted output (no extra newlines)
				printf "%3d. %s\n" "$counter" "$first_line"
				((counter++))
			done
			}
		fi

	# preview for entity
	# the following is experimental
	# to use query as a search term in the preview window
	# requires disable-search activated by alt-Q
	# if view context is entity, query triggers search within source
  elif [[ ${_viewScope} == "entity" && ${_viewMode} != "search" ]]; then
    local _actualFileToPreview="${_selection}"
    if [[ ${_viewMode} == "firstline" ]]; then
       # _selection is "Display Name\tActualFilename"
       _actualFileToPreview=$(echo -e "${_selection}" | cut -f2 -d$'\t')
       [[ -z "${_actualFileToPreview}" || "${_actualFileToPreview}" == "${_selection}" ]] && _actualFileToPreview="${_selection}"
    fi

    if [[ -z $2 ]]; then # $2 is _query
      _previewEntity "${_actualFileToPreview}" "" "${_viewContext}"
    else
      _previewEntity "${_actualFileToPreview}" "${_query}" "${_viewContext}" | sed "s/${_query}/$(printf '\033[1;31m&\033[0m')/g"
    fi

	# in search mode
	elif [[ ${_viewScope} == "entity" && ${_viewMode} == "search" ]]; then
		_previewSearch "${1:-}" "${2:-}"
	fi
}
export -f _preview

_previewSource() {
	# used by fzf during source change...shows description and entity count
	[[ -z ${2} ]] && { echo "source does not exist"; return; }
	echo "source: $2"
	echo "entries: $(_getSourceCount $2)"
	echo
	echo "----DESCRIPTION-------------------"
	cat "${_HOME}/${2}/.description" || echo "no description"
}
export -f _previewSource

_previewSearch () {
	exec 2>>/tmp/fzf.debug
	#set -x
	local _selection=${1:-}
	local _query=${2:-}

  # Parse the ripgrep output format: source/file:line:content
  # First split into source and the rest
  local _source _rest
  IFS='/' read -r _source _rest <<< "${_selection}"
  
  # Now split the rest into file, line, and content
  local _file _line _content
  # Extract just the first two colon-separated fields
  _file=$(echo "$_rest" | cut -d: -f1)
  _line=$(echo "$_rest" | cut -d: -f2)
  
  # Verify we have required information
	if [[ -z ${_selection} ]]; then
		echo "no match"
		return
  elif [[ -z "${_file}" || -z "${_line}" ]]; then
    echo "Invalid search result format: ${_selection}"
    return
  fi

	# print our preview winow header (5 lines)
	echo -e "     \e[38;5;238m source : $_source \e[0m"
	echo -e "     \e[38;5;238m file   : $_file \e[0m"
	echo -e "     \e[38;5;238m line   : $_line \e[0m"
	echo -e "     \e[38;5;238m query  : $_query \e[0m"
	echo -e "     \e[38;5;238m title  :\e[0m $(head -1 ${_source}/${_file})"
	echo -e "    \e[38;5;238m====================================================================\e[0m"

	# Calculate the previous and next line numbers
	local _prevLine=$(( _line - 1 ))
  local _nextLine=$(( _line + 1 ))

# use awk to highlight lines and the query word
awk -v query="${_query}" -v red="\033[48;2;192;30;40m" -v reset="\033[0m" -v yellow="\033[48;2;80;60;0m" '
BEGIN { IGNORECASE = 1 } # Enable case-insensitive matching for the query variable
NR == '${_prevLine}' || NR == '${_line}' || NR == '${_nextLine}' {
    current_line_content = $0 # Work with the original line content

    # Perform case-insensitive replacement on current_line_content.
    # Due to IGNORECASE = 1, "query" will match case-insensitively.
    # "&" in the replacement string will contain the actual matched text, preserving its original case.
    # The "red "&" reset yellow" sequence ensures the matched text gets the "red" background,
    # and the "yellow" background continues after the match within the same line.
    gsub(query, red "&" reset yellow, current_line_content)

    # Print the modified line, wrapped in the overall "yellow" background.
    print yellow current_line_content reset
    next
}
{ print } # Print other lines as is
' "${_source}/${_file}" | batcat --color=always --style=numbers
return

	# this is the easiest way to figure out what ansi codes are coming through
	_showANSI() {
   # Replace ESC character with visible "<ESC>"
   sed 's/\x1b/\[ESC\]/g'
	}
	export -f _showANSI

  batcat --color=always --style=numbers \
		--highlight-line "${_prevLine}:${_nextLine}" \
		"${_file}" 2>/dev/null | head -10 | _showANSI

	# display with batcat
	# highlight line before and line after
	# pipe through sed to make the search term pop out in red
#  batcat --color=always --style=numbers \
#		--highlight-line "${_prevLine}:${_nextLine}" \
#		"${_file}" 2>/dev/null | sed "s/${2}/$(printf '\033[1;31m&\033[0m')/g"
  # Use batcat with default highlighting then pipe through sed twice:
  # 1. Replace the gray background with golden yellow (RGB 238,183,27)
  # 2. Highlight search query in bold red
  batcat --color=always --style=numbers \
    --highlight-line "${_prevLine}:${_nextLine}" \
    "${_file}" 2>/dev/null | 
    sed 's/\x1b\[48;2;51;51;51/\x1b[48;2;110;90;63/g' |
    sed "s/${_query}/$(printf '\033[1;31m&\033[0m')/gi"
}
export -f _previewSearch

_previewEntity() {
	exec 2>>/tmp/fzf.debug
	#set -x
	# used by fzf during edit to display the germ 
	echo "selection: $1"
	echo "query    : $2"
	echo "----entity contents below---------"
	if [[ -z "${1}" ]]; then
		echo "no such entity"
	else
		echo
		# add a left margin for readability
		cat "${_HOME}/${3}/${1}" | sed 's/^/   /'
		echo
	fi
}
export -f _previewEntity

_previewNameValidation () {
	# called by _preview when the user is typing
	# arg1 = query
	# arg2 = selection
	# arg3 = selectedType
	local _nameType=${3}
	local _maxLength=25
	local _minLength=1
	local lengthStatus
	local avail
	local allowedChars="n/a"
	local lead="n/a"
	local last="n/a"
	local repeat="n/a"
	local acceptable="NO"

	_cStat() {
		# print the key word in a set color
		# arg 1 = key word
		[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
		[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
		[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
		echo -n "${1}"
		tput sgr0 
	}
	export -f _cStat

	# validate the name first
	if [[ ${#1} -lt ${_minLength} ]]; then
		lengthStatus="TOO SHORT"
		avail="n/a"
	elif [[ ${#1} -gt ${_maxLength} ]]; then
		lengthStatus="TOO LONG"
		avail="n/a"
	else
		lengthStatus="OK"
		# check for name uniqueness (by type)
		_doesNameExist ${_nameType} "${1}" && { avail="NO"; acceptable="NO"; } || { avail="YES"; acceptable="YES"; }
	fi
	[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
	[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ [[:upper:]] ]] && { lower="NO"; acceptable="NO"; } || lower="YES"
	[[ "${1}" =~ [^[:alnum:]._-] ]] && { specials="NO"; acceptable="NO"; } ||specials="YES"

_activeNameFeedback () {
		# print the validation info into the fzf preview window	
		rule1="  the name must be valid"
		rule2="  max length: ${_maxLength}, min: ${_minLength}"
		rule3="  the name must be unique"
		rule4="  lower case and numbers only"
		rule5="   also allowed:"
		rule6="   dash, dot, underscore"
		rule7="  specials cannot repeat"
		rule8="  first alphanumeric only"
		rule9="  last alphanumeric only"

		echo "---CREATING NEW SOURCE?----------NAMING RULES-----------"
		printf "name: \e[33m%-25s\e[0m\n" "$1"
		printf "valid? %-30s \e[2m%-27s\e[0m\n" $(_cStat ${acceptable}) "$rule1"
		printf "length [%.2d] %25s \e[2m%-27s\e[0m\n" ${#1} "$(_cStat "${lengthStatus}")" "$rule2"
		printf "unique: %29s \e[2m%-27s\e[0m\n" "$(_cStat "${avail}")" "$rule3"
		printf "characters allowed: %17s \e[2m%-27s\e[0m\n" $(_cStat "${allowedChars}") "$rule4"
		printf " lower case: %24s \e[2m%-27s\e[0m\n" $(_cStat "${lower}") "$rule5"
		printf " specials (.-_): %20s \e[2m%-26s\e[0m\n" $(_cStat "${specials}") "$rule6"
		printf "special repeats: %20s \e[2m%-27s\e[0m\n" "$(_cStat "${repeat}")" "$rule7"
		printf "first ['\e[33m%s\e[0m'] allowed: %16s \e[2m%-27s\e[0m\n" "${1:0:1}" "$(_cStat "${lead}")" "$rule8"
		printf "last ['\e[33m%s\e[0m'] allowed: %17s \e[2m%-27s\e[0m\n" "${1:(-1)}" "$(_cStat "${last}")" "$rule9"
		echo "============================"
		if [[ ${acceptable} == "YES" && -n ${2} ]]; then
			printf "\e[31mENTER\e[0m to select: \e[33m%-25s\e[0m\n" "$2"
			printf "\e[31mALT-ENTER\e[0m to create: \e[33m%-25s\e[0m\n" "$1"
			echo "ctrl-n to add new entity to $2"
			echo "alt-D to delete source $2"
		elif [[ ${acceptable} == "YES" && -z ${2} ]]; then
			printf "\e[31mENTER\e[0m to create: \e[33m%-25s\e[0m\n" "$1"
		elif [[ ${acceptable} == "NO" && -n ${2} ]]; then
			printf "\e[31mENTER\e[0m to select: \e[33m%-25s\e[0m\n" "$2"
			echo "ctrl-n to add new entity to $2"
			echo "alt-D to delete source $2"
		fi
		echo
	}
	export -f _activeNameFeedback
	# print the results
	_activeNameFeedback $1 $2
}
export -f _previewNameValidation


##################################################################
##################################################################
##########     germFZF preview help
##################################################################
##################################################################

_previewHelp() {
	# preview help windows
	# arg1 = context (source is default)
  
  # determine the current view context
  local _viewContext
  if [[ -n "${1:-}" ]]; then
  	_viewContext="$1"
  else
  	_viewContext=$(_stateRead "germFZF/viewContext") || _viewContext="source"
	fi

	_debug ${FUNCNAME[0]}: "context is ${_viewContext}"

	case "${_viewContext}" in
		source)
			# show help for source
			_helpSource
			;;
		entity)
			# show help for entity
			_helpEntity
			;;
		index)
			# show help for index
			_helpIndex
			;;
	esac
}
export -f _previewHelp

_helpSource() {
	# note the header width is the ideal max for a line
	# in a 80w term (the constrained view)
	# this prevents line wrapping even in default term window
	printf '
 +--------------------+-------------------------------+
 |     source help    |     hit "/" to close help     |
 +--------------------+-------------------------------+

list navigation and selection
 - enter           selects
 - up/down         moves in selection list
 - alt-left        go back to the previous view
 - alt-up          half page up
 - alt-down        half page down
 - alt-shift-up    page up
 - alt-shift-down  page down
 - tab             fills query with selected
 - backspace       deletes backwards
 - left/right      moves within query
 - ctrl-u          clears query
 - ctrl-a          moves to beginning of query line
 - ctrl-e          moves to end of query line
 - escape          returns to home view (ctrl-[)

sorting and viewing
- ctrl-v        cycles view modes
- ctrl-r        reverses search order (^ reverse)
- ctrl-?        toggles wrap/truncate in list

creating new
- ctrl-n     creates new in selected source (+editor)
- alt-enter  creates new source from typed query
- enter      special create mode (REMOVE)

managing
- ctrl-delete         deletes selected

quitting
 - ctrl-q             exits

preview screen
- ctrl-space          scrolls half page down
- ctrl-b              scrolls half page up
- ctrl-[up|down]      scrolls the preview window

 index management (virtual notebook indexes)
 - alt-i   create a new index
 - alt-u   read the notebook without index
 - alt-a   append selected to current index
 - alt-D   delete selected from current index
 - alt-t   toggle view between all files and only non-linked ones

'
}
export -f _helpSource

_helpEntity() {
	printf '
 +-------------------------+---------------------------------+
 |   germ entity help      |     hit "/" to close help       |
'
}
export -f _helpEntity
	
_helpIndex() {
	printf '
 +-------------------------+---------------------------------+
 |   germ index help       |     hit "/" to close help       |
'
}
export -f _helpIndex

_createSource () {
	exec 2>>/tmp/fzf.debug
	#set -x
	# function to create a new source
	# $1 = name of the new source
	# return 0 for success and commit
	# return 1 for created but no commit
	# return 2 for invalid name
	# return 3 for source exists
	# return 4 for failed mkdir/description
	local _newSource="${1:-}"
	
	# check if the name is empty
	if [[ -z "${_newSource}" ]]; then
		_error "${FUNCNAME[0]}: no name provided"
		return 1
	fi

	# check if the name is valid and unique
	_isNameValid "${_newSource}" || { _error "'${_newSource}' is invalid"; return 2; }
	_doesNameExist source "${_newSource}" && { _error "'${_newSource}' already exists"; return 3; }

	# make the new source directory and touch the source description
	mkdir "${_HOME}/${_newSource}" || { _error "failed to create source directory"; return 4; }
	touch "${_HOME}/${_newSource}/.description" || { _error "failed to create source description"; return 4; }

	# save file and commit
	if _doCommit "${_HOME}/${_newSource}" "[source] added ${_newSource}"; then
		return 0
	else
		return 1
	fi
	
}
export -f _createSource

_isNameValid() {
	exec 2>>/tmp/fzf.debug
	#set -x
    # Existing validation 
    local _name=${1:-}
    local _maxLength=25
    local _minLength=1
    
    # Basic validation checks
    if [[ ! "${_name}" =~ ^([[:lower:]|[:digit:]]|[-_.]){${_minLength},${_maxLength}}$ ]]; then
        return 1
    fi
    
    # Check start/end constraints and repeats
    [[ "${_name}" =~ ^[[:lower:]|[:digit:]] ]] || return 1
    [[ "${_name}" =~ [[:lower:]|[:digit:]]$ ]] || return 1
    [[ "${_name}" =~ ([.]|[-]|[_]){2} ]] && return 1
    
		return 0
}
export -f _isNameValid

_renameSource() {
	exec 2>>/tmp/fzf.debug

  # Rename a source directory
  # $1 = old source name (current source)
  # $2 = new source name
  # Return 0 for success
  # Return 1 for git failure
  # Return 2 for invalid old source 
  # Return 3 for invalid new name
  # Return 4 for new name already exists

  local _oldSource="${1}"
  local _newSource="${2}"
  
  # Check if old source exists
  if [[ ! -d "${_HOME}/${_oldSource}" ]]; then
    _error "Source '${_oldSource}' does not exist"
    return 2
  fi
  
  # Check if old source is "default" (cannot rename default)
  if [[ "${_oldSource}" == "default" ]]; then
    _error "Cannot rename the 'default' source"
    return 2
  fi
  
  # Check if new name is valid
  if ! _isNameValid "${_newSource}"; then
    _error "New name '${_newSource}' is not valid"
    return 3
	fi
  
  # Check if new name already exists
  if [[ -d "${_HOME}/${_newSource}" ]]; then
    _error "Name '${_newSource}' already exists"
    return 4
  fi
  
  # Perform the rename using git mv
  if ! git -C "${_HOME}" mv "${_oldSource}" "${_newSource}"; then
    _error "Git rename operation failed"
    return 1
  fi
  
  # Commit the change
  if ! git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] renamed '${_oldSource}' to '${_newSource}'"; then
    _error "Git commit failed"
    return 1
	fi
  
  # Update the current source state if we renamed the current source
  if [[ "$(_getSource)" == "${_oldSource}" ]]; then
    _setSource "${_newSource}"
  fi
  
  return 0
}
export -f _renameSource

_deleteSource() {
	# return 0 for success
	# return 1 for delete without commit
	# return 2 for empty request
	# return 3 for attempt to delete "default"

  local _source=${1:-}

	if [[ -z ${_source:-} ]]; then
		_warn "${FUNCNAME[0]}: arg required"
		return 2
	fi

  # ensure the default source cannot be deleted
  if [[ "${_source}" == "default" ]]; then
    _warn "cannot delete 'default'"
    return 3
  fi

  # delete the source
  git -C "${_HOME}" rm -rq "${_HOME}/${_source}"
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] deleted ${_state} ${_source}"
	if [[ $? != 0 ]]; then
		return 1
	fi
}
export -f _deleteSource


_XdeleteSource() {
  local _source=${1:-}
	local _state

	if [[ -z ${_source:-} ]]; then
		_warn "${FUNCNAME[0]}: arg required"
		return 1
	fi

  # ensure the default source cannot be deleted
  if [[ "${_source}" == "default" ]]; then
    _warn "cannot delete 'default'"
    return 1
  fi

  # check if the source is empty
  if [[ $(_getSourceCount "${_source}") != 0 ]]; then
    _warn "'${_source}' is not emptyinotify"
		_state="NON-EMPTY"
  fi

  # prompt for confirmation
  local _yn
  read -r -n1 -p "$(_ask "delete ${_state} '${_source}'? [y/n] ")" _yn
  echo
  if [[ "${_yn}" != "y" ]]; then
    _warn "delete aborted"
    return 1
  fi

  # delete the source
  git -C "${_HOME}" rm -rq "${_HOME}/${_source}"
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] deleted ${_state} ${_source}"
}
export -f _deleteSource

##################################################################
##################################################################
##########     search
##################################################################
##################################################################

_toggleSearchMode() {
  # toggle search mode on/off
  
  local _current_mode
  _current_mode=$(_stateRead "germFZF/viewMode") || _current_mode="all"
  
  if [[ "${_current_mode}" == "search" ]]; then
    # Turn search mode OFF
    _stateSet "germFZF/viewMode" "all"
  else
    # Turn search mode ON
    _stateSet "germFZF/viewMode" "search"
  fi
}
export -f _toggleSearchMode

_search () {
	exec 2>>/tmp/fzf.debug
	#set -x
	local _viewScope
	_viewScope=$(_stateRead germFZF/viewScope)
	local _viewContext
	_viewContext=$(_stateRead germFZF/viewContext)
	local _searchPath
	if [[ ${_viewScope} == "entity" ]]; then
		_searchPath="${_viewContext}"
	elif [[ ${_viewScope} == "source" ]]; then
		_searchPath="*"
		# here we could read a list provided by fzf to filter
	fi
	# search with rg against the provided arg list using query
	local _query=${FZF_QUERY:-'.'}

	_debug "${FUNCNAME[0]}: viewScope   : ${_viewScope}"
	_debug "${FUNCNAME[0]}: viewcontext : ${_viewContext}"
	_debug "${FUNCNAME[0]}: search path : ${_searchPath}"
	_debug "${FUNCNAME[0]}: search term : ${_query}"

	# run rg, print line number of match, sort, and remove matched line
	if ! rg --color=always --line-number --no-heading --smart-case \
		--glob=!.*/ "${_query}" ${_searchPath} | sort | cut -d: -f1,2; then
		echo "no match for ${_query}"
	fi
}
export -f _search

_EXEdeleteSource () {
	exec 2>>/tmp/fzf.debug
	local _selection=${1}
	local _viewScope=$(_stateRead germFZF/viewScope)
 	local _entityCount=$(_getSourceCount "${_selection}")

	# ignore empty
	if [[ -z ${_selection} ]]; then
		_stateSet germFZF/headerLines/6 "cannot delete nothing"

	# if not in viewScope source, ignore
	elif [[ ${_viewScope} != "source" ]]; then
		_stateSet germFZF/headerLines/6 "not allowed"

	# cannot delete "default"
	elif [[ ${_selection} == "default" ]]; then
		_stateSet germFZF/headerLines/6 "cannot delete 'default'"

	# make sure it exists
	elif ! _doesSourceExist "${_selection}"; then
		_stateSet germFZF/headerLines/6 "${_selection} does not exist"

	# chack if it is empty
 	elif [[ ${_entityCount} != 0 ]]; then
		_stateSet germFZF/headerLines/1
		_stateSet germFZF/headerLines/2 "to delete the source notebook:"
		_stateSet germFZF/headerLines/3 "type '${_selection}' and hit enter"
		_stateSet germFZF/headerLines/5 "${_selection} contains ${_entityCount} entities"
		_stateSet germFZF/headerLines/6 "${_selection} is not empty!"
		_stateSet germFZF/viewMode delete-confirm
		_stateSet germFZF/viewContext "${_selection}"
		_stateSet germFZF/nextAction delete-confirm

	# it is empty, not 'default', and is an existing source, so delete it
	else
		_stateSet germFZF/headerLines/1
		_stateSet germFZF/headerLines/2 "to delete the source notebook:"
		_stateSet germFZF/headerLines/3 "type '${_selection}' and hit enter"
		_stateSet germFZF/headerLines/4 "${_selection} is empty"
		_stateSet germFZF/viewMode delete-confirm
		_stateSet germFZF/viewContext "${_selection}"
		_stateSet germFZF/nextAction delete-confirm
	fi
}
export -f _EXEdeleteSource


_TRANSdeleteSource () {
	exec 2>>/tmp/fzf.debug
	local _selection=${1}
	local _viewScope=$(_stateRead germFZF/viewScope)
 	local _entityCount=$(_getSourceCount "${_selection}")
	local _transform

	# ignore empty
	if [[ -z ${_selection} ]]; then
		_stateSet germFZF/headerLines/6 "cannot delete nothing"

	# if not in viewScope source, ignore
	elif [[ ${_viewScope} != "source" ]]; then
		_stateSet germFZF/headerLines/6 "not allowed"

	# cannot delete "default"
	elif [[ ${_selection} == "default" ]]; then
		_stateSet germFZF/headerLines/6 "cannot delete 'default'"

	# make sure it exists
	elif ! _doesSourceExist "${_selection}"; then
		_stateSet germFZF/headerLines/6 "${_selection} does not exist"

	# ensure that it is empty
 	elif [[ ${_entityCount} != 0 ]]; then
		_stateSet germFZF/headerLines/1
		_stateSet germFZF/headerLines/2 "to delete the source notebook:"
		_stateSet germFZF/headerLines/3 "type '${_selection}' and hit enter"
		_stateSet germFZF/headerLines/5 "${_selection} contains ${_entityCount} entities"
		_stateSet germFZF/headerLines/6 "${_selection} is not empty!"
		_stateSet germFZF/viewMode delete-confirm
		_stateSet germFZF/viewContext "${_selection}"
		_stateSet germFZF/nextAction delete-confirm
		_transform+="+change-preview-window(up,50%,<30(up,20%))"
		_transform+="+change-input-label(delete ${_selection} ?)"
		_transform+="+change-ghost(type '${_selection}' and enter to confirm deletion)"
		_transform+="+reload(echo -e 'cancel\n${_selection}')"

	# it is empty, not 'default', and is an existing source, so delete it
	else
  	git -C "${_HOME}" rm -rq "${_HOME}/${_selection}"
  	git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] deleted ${_selection}"
		_stateSet germFZF/headerLines/6 "deleted: ${_selection}'"
	fi

	# return the transform string
	_transform+="+transform-header(_setHeader)"
	_transform+="+clear-query+first"
	echo ${_transform}
}
export -f _TRANSdeleteSource

_searchMode () {
	exec 2>>/tmp/fzf.debug
	#set -x
	local _query=${FZF_QUERY}
	local _selection=${1}
	local _viewMode=$(_stateRead germFZF/viewMode)
	local _transform
	_debug "${FUNCNAME[0]}: triggered"
	# toggled by ctrl-s
	# triggered by query change and focus change (up/down arrows)
	# get current state
	if [[ $(_stateRead germFZF/viewMode) == "all" ]]; then
		_debug "${FUNCNAME[0]}: disable"
		# disable it because ctrl-s toggled it off
		_stateSet germFZF/headerLines/4 "search-mode off"
		_stateSet germFZF/headerLines/3
		_transform+="+enable-search"
		_transform+="+change-ghost()"
		_transform+="+change-preview-window(75%,wrap,border)"
		_transform+="+change-preview-label()"
		_transform+="+reload(_loadList)"
		_transform+="+transform-header(_setHeader)"
		_transform+="+unbind(change)"
		_transform+="+unbind(focus)"
		echo ${_transform}
	else
		# enable it because ctrl-s toggled it on, or query change
		_debug "${FUNCNAME[0]}: enable"
		_stateSet germFZF/headerLines/4 "search-mode on"
		_stateSet germFZF/headerLines/3 "ctrl-s search off"
		_transform+="disable-search"
		_transform+="+change-ghost(type to search)"
		_transform+="+change-preview-label(searching: '$_query')"
		_transform+="+rebind(change)"
		_transform+="+rebind(focus)"
		_transform+="+reload(_search)"
		_transform+="+transform-header(_setHeader)"
		# IMPERFECT method to center preview window on the matched line
		# when typing, this will provide the last line, not the current!!
		# this works if the query (search term) does not change, but arrowed yes
		# works only when selection is part of a path...because it triggers
		# against the selection when typing, that selection when ctrl-s toggles
		# search mode on is a "source" which is why we can filter for slash
		# this is deep in the kludge fix territory
		if [[ ${_selection} == */* ]]; then
			# get the rg line number of the match
			local _lineNumber=$(echo ${_selection} | cut -d: -f2)
			# get the vertical center line of the preview window
			local _center=$(( $FZF_PREVIEW_LINES / 2 ))
			_transform+="+change-preview-window(+${_lineNumber}-6/${_center},~6)"
		else
			_transform+="+change-preview-window(~6)"
		fi
		echo ${_transform}
	fi
}
export -f _searchMode

# aborted attempt to use filter to select a group to search against
# see ctrl-alt-s fzf trigger
# the way to do this is put the list to viewContext (subset of all)
# then note the filter term and the number of source selections
# and use _search to check for the subset before it feeds the path list
# to rg
_searchGroup () {
	exec 2>>/tmp/fzf.debug
	#set -x
	# triggered by ctrl-alt-s (multi-select)
	# the query is the last argument
	local _query="${!#}"
	# build the selection list
	local _selectionArray=()
	if [[ $# -gt 1 ]]; then
		for ((i=1; i<$#; i++)); do
			_selectionArray+=("${!i}")
		done
	fi
	# convert the selection list into a proper string for rg
	local _pathString
	for selectionElement in "${_selectionArray[@]}"; do
		_pathString+=" $selectionElement"
	done
	local _transform
	local RG
	RG="rg --color=always --line-number --no-heading --smart-case "
	RG+="--glob=!.git/ --glob=!.state/ ${_query} ${_pathString}"
	_debug "${FUNCNAME[0]}: selection  : ${_selection}"
	_debug "${FUNCNAME[0]}: select #   : ${FZF_SELECT_COUNT}"
	_debug "${FUNCNAME[0]}: query      : ${_query}"
	_debug "${FUNCNAME[0]}: rg command :'$RG'"
	_stateSet germFZF/headerLines/4 "search-group ${_query} [$_selectcount]"
	_transform="+disable-search"
	_transform+="+reload($RG)"
	_transform+="+preview(batcat)"
	echo ${_transform}
}
export -f _searchGroup


##################################################################
##################################################################
##########     pdf
##################################################################
##################################################################

_pdf() {
	# produce a nice pdf and save to desktop
	# source notebook provided as $1
	local _source=${1}
	# destination for output file
	local _destination="$HOME/Desktop/"
	# temp working dir
	local _temp=$(mktemp -d)
	# log file
	local _logfile="${_temp}/germ_pdf.log"
	_debug "logging to '$_logfile'"
	# set the output file name
	local _filename="${_source}-$(date +%Y%m%d-%H%M%S)"
	# set the output file full path
	local _output_full_path="${_destination}${_filename}"
	# full commit hash (40 characters)
	full_hash=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-parse HEAD)
	# Short commit hash (typically 7 characters)
	short_hash=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-parse --short HEAD)

	# create a list of files, sorted chronologically by timestamp
	local files=()
		while IFS= read -r -d '' file; do
			files+=("$file")
		done < <(find "${_source}" -maxdepth 1 -type f -regextype posix-extended -regex ".*[0-9]{10}\.[0-9]+" -print0 | sort -z)

	# add trap to remove temporary directory on exit
#	trap 'rm -rf "$_temp"' EXIT

	# gather statistics
	local total_files=${#files[@]}
	local words_per_file=()
	local pages_per_file=()
	
	# calculate words and pages for each file
	for file in "${files[@]}"; do
		words_per_file+=("$(wc -w < "$file")")
		# estimate pages (assuming ~66 lines per page with enscript defaults)
		local file_lines=$(wc -l < "$file")
		pages_per_file+=("$(( (file_lines + 65) / 66 ))")
	done
	
	# create cover page
	local cover_file="${_temp}/cover_page.txt"
	cat > "$cover_file" << EOF

source name: $_source
description: $(cat ${_HOME}/${_currentSource}/.description)
file count: $total_files
draft date: $(date '+%Y-%m-%d %H:%M:%S %Z')
germ git hash: $full_hash


EOF
	
	# enumerate file details into cover page
	printf "%-6s %-21s %-35s %6s %8s %7s\n" "index" "key" "name" "words" "pages" "revs" >> "$cover_file"
	printf -- "------------------------------------------------------------------------------------------\n" >> "$cover_file"
	for i in "${!files[@]}"; do
		local filename=$(basename "${files[i]}")
		local givenname=$(head -1 "${files[i]}")
		local revs=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-list --count HEAD -- "${files[i]}")
		printf "%3d. %*s %-21s %-35s %5d %7d %7d\n" \
			$((i+1)) 1 "" "$filename" "$givenname" "${words_per_file[i]}" "${pages_per_file[i]}" "$revs" >> "$cover_file"
	done

	# create cover header
	local _header="${_MASTER}:${_NAME}:${_USERNAME}"
	_header+="|==--DRAFT--=="
	_header+="|${_source} [${short_hash}]"

	# convert cover page to PDF
	enscript -f Courier10 -b"${_header}" -p "${_temp}/cover.pdf" "$cover_file" >> "${_logfile}" 2>&1

	# combine files into a single PDF
	local combined_pdf="${_temp}/text_archive.pdf"
	local temp_pdfs=()
	for i in "${!files[@]}"; do
		local file="${files[i]}"
		local filename=$(basename "$file")

		# create header string for each file
		local _header="${_source}:DRAFT"
		_header+="|$filename"
		_header+="|page $% of $="

		# convert file to PDF
		local file_pdf="${_temp}/file_${i}.pdf"
		enscript -f Courier10 -b"${_header}" -p "$file_pdf" "$file" >> "${_logfile}" 2>&1
		temp_pdfs+=("$file_pdf")
	done

	# combine all PDFs
	gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile="$combined_pdf" \
		"${_temp}/cover.pdf" "${temp_pdfs[@]}"

	# copy final PDF to Desktop
	cp "${combined_pdf}" "${_destination}${_filename}"
	_info "copied file to desktop as '${_filename}'"
}

##################################################################
##################################################################
##########     state machine
##################################################################
##################################################################

_stateInitialize () {
	# set up the state machine (runs once in _setEnv)
	export _stateDir="${_HOME}/.state"
	export _statePersistence=true
	export _lockFile="${_stateDir}/germInstance/lock"
	# ensure the state directory exists
	mkdir -p "${_stateDir}"
	# respect the state machine persistence setting
	if [[ ${_statePersistence:-true} = false ]]; then
		# remove the state directory if it exists
		rm -rf "${_stateDir}"
		# create the state directory skeleton
		mkdir -p "${_stateDir}/currentSource"
		# set the default source
		touch "${_stateDir}/currentSource/default"
	fi
	# check and acquire the lock
	_checkLock
}

_stateSet() {
	# set value for given key
	local key="$1"
	local value="$2"

	# ensure the state directory exists
	mkdir -p "${_stateDir}/${key}"

	# clear state when $2 is null
	[[ -z ${2:-} ]] && { rm -rf "${_stateDir}/${key}"; return; }

	# remove any existing state files in this key's directory
	rm -f "${_stateDir}/${key}"/*

	# create the new state file using touch
	touch "${_stateDir}/${key}/${value}"
}
export -f _stateSet

_stateRead() {
	# check for the value in the key
	local key="$1"    # the key

	# check if key directory exists
	if [[ ! -d "${_stateDir}/${key}" ]]; then
		return 1
	fi

  # find first file inside the key directory
	for file in "${_stateDir}/${key}"/*; do
 		if [[ -f "$file" ]]; then
   		basename "$file"
 			return 0
   	fi
 	done

 	# no value found
 	return 1
}
export -f _stateRead

_checkLock() {
  # Attempt to create the lock directory atomically
  if mkdir -p "${_stateDir}/germInstance/lock" 2>/dev/null; then
    # Successfully acquired the lock
    _stateSet "germInstance/shellPID" "$$"
    _debug "lock acquired (PID: $$)."
  else
    # Lock directory already exists, check for stale lock
    local _existingPID
    _existingPID=$(_stateRead "germInstance/shellPID")
    
    if [[ -n "${_existingPID}" && -d "/proc/${_existingPID}" ]]; then
      # Another instance is running
      _error "another instance of germ is already running (PID: ${_existingPID}). Exiting."
      exit 1
    else
      # Stale lock detected, remove and retry
      _warn "stale lock detected (PID: ${_existingPID}). Overwriting."
      rm -rf "${_stateDir}/germInstance/lock"
      mkdir "${_stateDir}/germInstance/lock"
      _stateSet "germInstance/shellPID" "$$"
      _info "lock acquired (PID: $$)."
    fi
  fi
}

_releaseLock() {
  # Remove the lock directory
  if [[ -d "${_stateDir}/germInstance/lock" ]]; then
    rm -rf "${_stateDir}/germInstance/lock"
    _debug "Lock released (PID: $$)."
  fi
}

##################################################################
##################################################################
##########     shell
##################################################################
##################################################################

_shell() {
	# the main UI function
	# use the experimental TUI mode if called (and available)
	#source "$(dirname "$0")/tui-shell.sh"
	#_tui_shell
	#return
	# Check if TUI mode is enabled
 	if [[ "${_TUI:-false}" == "true" ]]; then
		# Source the TUI shell script if it exists
		if [[ -e "$(dirname "$0")/tui-shell.sh" ]]; then
			source "$(dirname "$0")/tui-shell.sh"
			_tui_shell
			return
		else
			_warn "TUI shell not found, falling back to standard shell"
		fi
	fi

	cd "${_HOME}" || { _error "can not enter ${_NAME}"; return 1; }
	# set up shell history business
	HISTFILE="${_HOME}/.${_NAME}_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	# here would be the right place to lock the session
	## SESSION-LOCK
	# and keep session timers and counters
	# set the current source
	export _currentSource=$(_getSource)
	# the splash welcome
	_displayWelcome() {
	cat <<HEREDOC
  __  ___  ___   __  __ 
 / _)(  _)(  ,) (  \/  )
( (/\ ) _) )  \  )    ( 
 \__/(___)(_)\_)(_/\/\_)

      type ${green}h${reset} for help
      type ${red}q${reset} to quit

HEREDOC
	}
	# the main menu
	_printMenu() {
		printf '\n'
		printf ':-----germ commands------------------------------------------------------------o\n'
		printf '\n'
		printf '  h   how to use                      == current source: "%s" ==== \n' "${_currentSource}"
		printf '  a   add new note (editor)            C  change source                        .\n'
		printf '  f   fast add (one line, no editor)   N  new source                           .\n'
		printf '  e   edit (within current)            R  rename current                       .\n'
		printf '  b   browse (within current)          M  merge (other into current)           .\n'
		printf '  s   search                           D  delete current                       .\n'
		printf '                                       P  print description                    .\n'
		printf '  p   pdf current to desktop           E  edit description                     .\n'
		printf '                                       S  split (future)                       .\n'
		printf '                                       B  browse all source notebooks          .\n'
		printf '  \n'
		printf '  \n'
		printf '  \n'
		printf '                                         ===========debug etc==============\n'
		printf '  a   add new (editor)                    ctrl-x toggle bash debug (set -x) \n'
		printf '  f   fast add (no editor)                ctrl-b toggle germ debug          \n'
		printf '  e   edit                                0 print env                       \n'
		printf '  b   browse                              ctrl-g git status                 \n'
		printf '  q   quit %s\n' ${_NAME}
		printf '.  *insert msg*                                                                .\n'
	}
	_printGuidance() {
		printf '\n'
		printf ':-----germ usage guide---------------------------------------------------------o\n'
		printf '\n'
		printf ' in the simplest form, there is one "notebook" aka "source"  \n'
		printf '  which is called "default"                                                    .\n'
		printf '   press "a" to add a new note to the current source                           .\n'
		printf '                                                                               .\n'
		printf '                                                                               .\n'
		printf '  to use and manipulate multiple "notebooks" use the source commands           .\n'
		printf '   N creates new notebook names                                                .\n'
		printf '   R renames the current                                                       .\n'
		printf '   M allows one to merge the contents of one source into the current           .\n'
		printf '            it also deletes the now empty other source                         .\n'
		printf '   D deletes the current source (even if it is not empty!)                     .\n'
		printf '  \n'
		printf '  commands operate on the current "source"\n'
		printf '  \n'
		printf '  \n'
		printf '  the default notebook cannot be renamed or removed                            .\n'
		printf '  \n'
		printf '  \n'
		printf '  \n'
		printf '  q   quit %s\n' ${_NAME}
		printf '.  *insert msg*                                                                .\n'
	}
	# the prompt and interpreter
	_mainPrompt() {
		# disallow use of ctrl-c etc
		trap '' SIGQUIT SIGTSTP SIGINT SIGTERM
		_p() {
			local _cs=$(_getSource)
			# set the prompt
			reset=$'\001\e[0m\002'
			_cH=$'\001\e[00;45m\002'		#home
			_cG=$'\001\e[00;7m\002'			#germ
			_cU=$'\001\e[00;32m\002'		#user
			_cS=$'\001\e[00;33m\002'		#source
			_dirty="${green}o${reset}"
			_isIndexClean || _dirty="${red}-${reset}"
			echo -n "${_cH}${_MASTER}${reset}:${_cG}${_NAME}${reset} ${_cU}${_USERNAME}${reset} [${_cS}${_cs}${reset}] ${_dirty} > "
		}
		_displayWelcome
		local __input
		while read -rsn1 -p "$(_p)" __input || true; do
			echo
			case ${__input} in
				\?)
					_printMenu
					;;
				h)
					_printGuidance
					;;
				a)
					_add || :
					;;
				f)
					# fast (editor-free) add
					echo -e $(_ask "add to '${_currentSource}'; ENTER to accept")
					read -r -p "$(_ask ": ")" _newEntry
					[[ -z "${_newEntry}" ]] && continue
					_key=$(_getNewKey)
					_commitMsg=$(_buildCommitMsg "${_newEntry}")
					echo "${_newEntry}" > "${_HOME}/${_currentSource}/${_key}"
					_doCommit "${_HOME}/${_currentSource}/${_key}" "[add to ${_currentSource}] ${_commitMsg}"
					;;
				e)
					echo "REMOVED"
					;;
				b)
					echo "REMOVED"
					;;
				s)
					_search || :
					;;
				p)
					_pdf "${_currentSource}"
					;;
				B)
					echo REMOVED
					;;
				G)
					_germFZF
					;;
				C)
					echo "REMOVED"
					;;
				N)
					echo "REMOVED"
					;;
				R)
					echo REMOVED
					;;
				M)
					echo "REMOVED"
					;;
				D)
					_deleteSource || :
					;;
				S)
					_debug "split requires multi-select fzf function"
					;;
				E)
					# edit source description
					${_EDITOR} "${_HOME}/${_currentSource}/.description"
  				git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/${_currentSource}/.description"
  				git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] updated '${_currentSource}' description"
					# TODO fix this...when desc is not saved, error 
					;;
				P)
					_info "current source: ${_currentSource}"
					_info "entries       : $(_getSourceCount ${_currentSource})"
					_info "description   : $(cat ${_HOME}/${_currentSource}/.description)"
					_info "entities      : $(_printSourceEntities ${_currentSource})"
					;;
				$'\x18')
					# toggle bash set -x debug with ctrl-x
					[[ $- == *x* ]] && set +x || set -x
					;;
				$'\x02')
					# toggle script _DEBUG with ctrl-B
					[ $_DEBUG = "true" ] && _DEBUG=false || _DEBUG=true
					_debug "debug on"
					;;
				$'\x07')
					# ctrl-g (run git status)
  				git -C "${_HOME}" --git-dir="${_GITDIR}" status
					;;
				0)
					printenv | grep "^_"
					;;
				t)
					_inspect
					;;
				q)
					return
					;;
				$'\e')
					# ignore all escape sequences
					_debug "esc ignored"
					# eat anything there
					read -rsn8 -t .002 _escape || continue
					_debug "esc $_escape"
					;;
				$'\04')
					# read ctrl-d
					_warn "use 'q' to quit"
					;;
			esac
		done
	}
	_mainPrompt
}

##################################################################
##################################################################
##########     main launch
##################################################################
##################################################################

main() {
	# read all the positional parameters
  _getOpts "${@}"
  # setup the environment after processing all command line parameters
  _setEnv
	# initialize the state machine
	_stateInitialize
	# set up trap to release lock on exit
	trap _releaseLock EXIT
  # validate the environment (external tools required)
  _checkExternalTools || { _error "cannot run until these problems are resolved"; return 1; }
  # check for the working directory
  _checkHome || { _error "cannot run without a working environment"; return 1;  }
	# check health
	# TODO eg check for .swp file from vim crash
	#
  # enter custom shell if no arguments
  [ -z "${_subCommand:-}" ] && _shell
  # otherwise, pass the commands to the called "command"
  [[ -n "${_subCommand:-}" ]] && _debug "now calling the eval to run '${_subCommand:-}'"
  [[ -n "${_subCommand:-}" ]] && eval _"${_subCommand}" || :
}
main "${@}"
