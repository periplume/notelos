#!/usr/bin/env bash
# file: mnemon
# source: https://github.com/periplume/notelos.git
# author: jason@bloom.us
# description: dictate and transcription machine

# STRICT SHELL
set -o errexit 
set -o nounset
set -o pipefail
IFS=$'\n\t'

###########################
# PREREQUISITES
###########################
 
# required external commands
_requiredCommands=(git tig fzf ffmpeg whisper)

###########################
# LIBRARY
###########################

# source library commands and set up log/console
# use the library file from the same directory if possible
[[ -e "$(dirname $0)/notelos-lib.sh" ]] \
	&& source "$(dirname $0)/notelos-lib.sh" \
	|| source notelos-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

# default initial debugging and logging settings
# note: command line parameters can modify these
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=true

# instantiate the log/mesg functions with defaults (these will be re-initialized
# after reading positional parameters)
_fLOG

####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF
usage: nmemon [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit
 -x      force standalone mode

alternate env settings:
 -a <name>  set the nmemon dir name to <name>
 -p <path>  set alternate base path

commands:
EOF
_printCommands
}

_printCommands() {
	cat <<  EOF
 new                 record and transcribe a new thing   
 import              fetch external recordings and transcribe
 create              create a new nmemon git database
 inspect             run tig on the nmemon git bare repo
 search              interactive search
 browse              read through the transcriptions
EOF
}

_printInfo () {
  cat << EOF
nmemon records and transcribes spoken english to written text
EOF
}

####################################
# PARAMETER PROCESSING
####################################

_getOpts () {
	# preserve the initial positional parameters
	export _fullCommand="${@}"
	_debug "full command is '${_fullCommand}'"
	local OPTIND
	# do not allow names for notelos or self to be names of germ commands
	_isCommand() {
		local _allowed=true
		local _commandList
		_commandList=$(_printCommands | cut -f2 -d' ')
		for _command in ${_commandList}; do
      [[ "${_command}" = "${1}" ]] && _allowed=false 
    done
    [[ ${_allowed} = "true" ]] || return 1
  }
	while getopts ":hsdlxva:p:" flag ; do
		case ${flag} in 
			h)
				_printInfo; _printUsage; exit 0
				;;
			a)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_isCommand "${OPTARG}" || { _error "'${OPTARG}' is not allowed (it is a command)"; exit 1; }
				_NAME=${OPTARG}
				_warn "using alt name '${_NAME}'"
				;;
			p)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_BASE=${OPTARG}
				_warn "using alt path '${_BASE}'"
				;;
 	    s)
				_debug "${FUNCNAME[0]}: enabling silent mode with flag -$flag"
 	      _SILENT=true
				;;
			d)
				_debug "${FUNCNAME[0]}: enabled debug mode with flag -$flag"
				_DEBUG=true
				;;
			l)
				_debug "${FUNCNAME[0]}: enabled log mode with flag -$flag"
				_LOG=true
				;;
			x)
        _debug "${FUNCNAME[0]}: running in standalone mode with -$flag"
        _MODE=standalone
        ;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -${OPTARG}"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1)); OPTIND=1
	# preserve the full subcommand with its parameters
	export _subCommandParams="${@}"
	# look for the subcommand and check for its options
	while ((${#})); do
		case ${1} in
			help)
				_printInfo; _printUsage; exit 0
				;;
			new)
				_subCommand=$1; shift
				return
				;;
			import)
				_subCommand=$1; shift
				return
				;;
			create)
				_subCommand=$1; shift
				return
				;;
			inspect)
				_subCommand=$1; shift
				return
				;;
			search)
				_subCommand=$1
				return
				;;
			browse)
				_subCommand=$1
				return
				;;
			*)
				_error "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
  # get the name and absolute path of the calling script
  _selfNAME=$(basename "${BASH_SOURCE[0]}")
  _selfABSOLUTE=$(readlink -f "${BASH_SOURCE[0]}")
  _selfBASE=$(dirname "${_selfABSOLUTE}")
  _selfCALL=${0}
  _selfPWD=$(pwd)
	# determine mode (notelos-integrated or standalone)
	[[ -n "${_notelosHOME+x}" && ${_MODE:-} != "standalone" ]] && _MODE=integrated || _MODE=standalone
	# note: the -x switch overrides the global _notelosHOME var 
	# integrated mode only happens when global var _notelosHOME is available
	# set up the working environment
	if [[ ${_MODE} = "integrated" ]]; then
		# set up integrated mode
		_MASTER="${_notelosNAME}"
		_BASE="${_notelosHOME}"
		_NAME="${_NAME:-${_selfNAME}}"
		_HOME="${_BASE}/${_NAME}"
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/.log/${_NAME}.log"
		# inherit these (from notelos)
		_DEBUG=${_notelosDEBUG}
		_LOG=${_notelosLOG}
		_SILENT=${_notelosSILENT}
		_USERNAME=${_notelosUSERNAME}
		_USEREMAIL=${_notelosUSEREMAIL}
		_EDITOR=_notelosEdit
	else
		# set up standalone mode
		_MASTER=self
		_BASE="${_BASE:-$HOME}"
		_NAME="${_NAME:-${_selfNAME}}"
		_HOME=${_BASE}/${_NAME}
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/${_NAME}.log"
		# inherit these
		_DEBUG=${_DEBUG:-false}
		_LOG=${_LOG:-false}
		_SILENT=${_SILENT:-false}
		_USERNAME=$(whoami)
		_USEREMAIL="unknown"
		_EDITOR=${EDITOR:-nano}
	fi
  [[ -f "${_LOGFILE:-}" ]] && _LOGGING=true || _LOGGING=false
	_debug "$(declare -p _MODE)"
	_debug "$(declare -p _MASTER)"
	_debug "$(declare -p _NAME)"
	_debug "$(declare -p _BASE)"
	_debug "$(declare -p _HOME)"
	_debug "$(declare -p _USERNAME)"
	_debug "$(declare -p _USEREMAIL)"
	_debug "$(declare -p _GITDIR)"
	_debug "$(declare -p _LOGFILE)"
	_debug "$(declare -p _DEBUG)"
	_debug "$(declare -p _SILENT)"
	_debug "$(declare -p _LOG)"
	_debug "$(declare -p _LOGGING)"
	export _MODE
	export _MASTER
	export _NAME
	export _BASE
	export _HOME
	export _USERNAME
	export _USEREMAIL
	export _GITDIR
	export _LOGFILE
	export _DEBUG
	export _SILENT
	export _LOG
	export _LOGGING
}

_checkExternalTools() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			: #_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}

_checkHome() {
  # check if the home dir exists
  # check if it is a germ-created git
  # return 1 if missing or not git
  # mind condition: if subcommand is create
	[[ ! -d "${_BASE}" && ${_MODE} = "notelos" ]] && { _error "notelos base not found"; exit 1; }
	[[ -d "${_BASE}" ]] || { _error "base '${_BASE}' does not exist"; exit 1; }
	local _base="${_BASE}"
	local _dirName="${_NAME}"
	local _dirPath="${_HOME}"
	local _git_desc="${_dirPath}/.git/description"
  if [ -d "${_dirPath}" ]; then
    if [ -f "${_git_desc}" ]; then
      # the git description file exists, lets check it for our marker
      read -r _desc < "${_git_desc}"
      if [[ ${_desc} == ${_MASTER}:${_NAME}:${_USERNAME}* ]]; then
        # if repo does exist, return 0
        _debug "${_git_desc} = ${_desc}"
				return
      else
        # if repo does not exist, warn and exit
        _error "${_dirPath} exists and is NOT a notelos-created repo"
        return 1
      fi
    else
      _error "${_dirPath} exists and is NOT a git repo"
      _error "move existing ${_dirPath} before proceeding"
      return 1
    fi
  else
    # dir does not exist
    _warn "'${_dirPath}' does not exist"
    read -rsn1 -p "$(_ask 'create repo now? [y/n]')" _yn
    echo
    [[ ${_yn} != "y" ]] && { _warn "cannot run without a repo"; return 1;  }
    _create || { _error "could not create ${_dirName} repo"; return 1; }
    return
  fi
}

############################
# CREATE
############################

_create() {
	# do not overwrite an existing anything
	[[ -d "${_HOME}" ]] && { _error "'${_HOME}' exists"; return 1; }
	[ ! -d "${_HOME}" ] && mkdir "${_HOME}"
	git init -q -b main "${_HOME}"
  git -C "${_HOME}" config user.name "${_USERNAME}"
  git -C "${_HOME}" config user.email "${_USEREMAIL}"
	# make the nmemon skeleton workflow dirs
	mkdir "${_HOME}/mic"					# the live recording
	mkdir "${_HOME}/queue"				# the queue of audio files
	mkdir "${_HOME}/transcripts"	# whisper output
	mkdir "${_HOME}/proofs"				# human proofed...can push
	mkdir "${_HOME}/audio"				# audio files corresponding to transcripts
	mkdir "${_HOME}/state"				# where state is maintained
	mkdir "${_HOME}/log"					# where logs go
	mkdir "${_HOME}/catalog"			# the master catalog of recordings
	# ignore recordings and import
	echo "mic/" > "${_HOME}/.gitignore"
	echo "queue/" >> "${_HOME}/.gitignore"
	# add gitignore and make first commit
  git -C "${_HOME}" --git-dir="${_GITDIR}" add .gitignore
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[genesis] ${_NAME} created by ${_USERNAME}"
	# put the installed signature in git description file
  _gitInitial=$(git -C "${_HOME}" rev-parse --short --verify main)
  _time=$(date +%s)
  printf "${_MASTER}:${_NAME}:${_USERNAME}:${_time}:${_gitInitial}\n" > "${_HOME}/.git/description"
}

##################################
# INSPECT
##################################

_inspect() {
	tig -C${_GITDIR}
}

# usage:
# _namePicker _newName   _getSourceList _validateNamePreview "prompt"    "special notes"
# (function)  (nameref)     (fzf feed)      (fzf preview)     fxf prompt  (fzf header)    
_namePicker () {
	# $1 = nameref for return value
	# $2 = input function (prints the list of existing whatever)
	# $3 = validation function for fzf preview window (in which $1=query $2=selection)
	# $4 = prompt string
	# $5 = optional special instructions
	# basically an fzf wrapper for name selection to be used globally
	# single level only and single selection
	local -n _return=$1
	local _input=$2
	local _preview=$3
	local _prompt=$4
	export _instructions="${5:-existing above, guidance right >}"
	_transHeader() {
		# add a second line to the header with context-specific info in yellow
		# $1 string message to insert
		printf "%s\n[\033[38;5;11m%s\033[0m]" "${_instructions}" "${1}"
	}
	_showHelp() {
		printf '
 +------------------------------------------------+
 |  mnemon proofing    |  hit "/" to close help   |
 +---------------------+--------------------------+

you are viewing the whisper-produced transcripts

 - ctrl-[up|down] arrow scrolls the preview window
 - ctrl-j previews the json output (txt is default)
 - ctrl-p plays the audio in the background
 - ctrl-o stops the playing audio

for each transcript there are only 3 actions

  1. delete    alt-d
  2. accept    alt-a
  3. edit      alt-e

delete removes the audio and transcript permanently
accept moves it to the /proofs directory as is
edit opens an editor and saves to proofs/ dir

keep a clean work space'
	}
	export -f _showHelp
	export -f _transHeader
	while true; do
		_newName=$(fzf \
			--no-multi \
			--no-mouse \
			--disabled \
			--ansi \
			--print-query \
			--exact \
			--info="hidden" \
			--prompt="${_prompt}>" \
			--header="${_instructions}" \
			--bind="start:reload(${_input})" \
			--bind="?:change-preview(_showHelp)" \
			--bind="/:change-preview(${_preview} {q} {})" \
			--bind="focus:transform-header(_transHeader 'ctrl-p: play')" \
			--bind="alt-a:transform-header(_transHeader 'accepted')+execute(mv ${_HOME}/transcripts/{} ${_HOME}/proofs/{})+reload(${_input})" \
			--bind="alt-d:transform-header(_transHeader 'deleted')+execute(_deleteEntry {})+reload(${_input})+reload(${_input})" \
			--bind="alt-e:become(_editProof {} </dev/tty >/dev/tty)" \
			--bind="ctrl-c:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-q:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-p:transform-header(_transHeader 'ctrl-o: stop')+execute-silent(_play {}&)+refresh-preview" \
			--bind="ctrl-o:transform-header(_transHeader 'stopped')+execute-silent(_stopPlayer)+refresh-preview" \
			--bind="ctrl-z:transform-header(_transHeader 'no ctrl-z')" \
			--bind="ctrl-j:transform-header(_transHeader 'ctrl-t txt')+change-preview(${_preview} {q} {} json)" \
			--bind="ctrl-t:transform-header(_transHeader 'ctrl-p to play')+change-preview(${_preview} {q} {})" \
			--bind="backward-eof:transform-header(_transHeader 'ESC to abort')" \
			--bind="esc:abort" \
			--preview="${_preview} {q} {} txt" \
			--preview-window=80%,wrap,~5,border-double
		);
		query=$(echo "${_newName}" | head -n1)
		selection=$(echo "${_newName}" | tail -n1)
		#_debug "query is '${query}'"
		#_debug "selection is '${selection}'"
		_return="${query}:${selection}"
		break
	done
}

_getMediaFile() {
	# print the media file name
	# only looks in audio/ where media is placed after the transcript job completes
	# $1 = key
	if [ -f "${_HOME}/audio/${_key}.m4a" ]; then
		_audio="${_HOME}/audio/${_key}.m4a"
	elif [ -f "${_HOME}/audio/${_key}.mp3" ]; then
		_audio="${_HOME}/audio/${_key}.mp3"
	elif [ -f "${_HOME}/audio/${_key}.wav" ]; then
		_audio="${_HOME}/audio/${_key}.wav"
	else
		# notice that _debug doesn't get color here in the preview window
		# not exactly as designed
		_debug "${FUNCNAME[0]}: unknown media type for '${_key}'"
		[[ -d "${_HOME}/catalog/${_key}" ]] && _catalog=true
		[[ -d "${_HOME}/transcriptions/${_key}" ]] && _transcrpt=true
		# check for active transcription job with this key
		# add key to transcription pipeline (like import)
		return
	fi
	echo "$(basename ${_audio})"
}
export -f _getMediaFile

_deleteEntry() {
	local _key=$1
	local _file=$(_getMediaFile ${_key})
	rm "${_HOME}/audio/${_file}"
	rm -rf "${_HOME}/transcripts/${_key}"
	rm -rf "${_HOME}/catalog/${_key}"
}
export -f _deleteEntry

_previewEntry() {
	local _type=${3:-txt}
	local _key=$2
	local _file
	local _duration
	local _isPlaying
	_file=$(_getMediaFile ${_key})
	if [[ -z ${_file} ]]; then
		# there is no found file in audio/ but it may be in queue
	 	echo "nothing yet (probably transcribing now)"
		[[ -e "${_HOME}/queue/${_key}.wav" ]] && echo "wav file is in the queue"
		[[ -e "${_HOME}/queue/${_key}.m4a" ]] && echo "m4a file is in the queue"
		return
	fi
	_duration=$(ffprobe -v error -sexagesimal -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${_HOME}/audio/${_file}")
	# check if this key is playing or not
	if [[ -d "${_HOME}/state/player/playing" ]]; then
		_playingNow=$(basename "${_HOME}/state/player/playing"/*)
		if [[ ${_playingNow} = "${_key}" ]]; then
			# colorize _isPlaying to magenta blinking "playing"
			_isPlaying=$'\x1b[38;5;5;5mplaying\x1b[0m'
		fi
	fi
	printf '  +--%-31s----------+\n' "$(date -d @${_key})"
	printf '  |  media:    %-23s%-7s |\n' "${_file}" "${_isPlaying}"
	printf '  |  duration:  %-30s|\n' "${_duration}"
	if [ ${_type} = "txt" ]; then
		# reformat the txt into a single paragraph that fits the preview window
		# figure out the preview window width, which is 80% cols
		_termcols=$(tput cols)
		_previewcols=$((_termcols * 85 / 100))
		# highlight tags in green
		_tag='\x1b[1;32m' ; _rst='\x1b[0m'
		# display the proofed version if it exists
		if [ -e "${_HOME}/proofs/${_key}.txt" ]; then
			_proofed=true
			local _path="${_HOME}/proofs/${_key}.txt"
		else
			_proofed=false
			local _path="${_HOME}/transcripts/${_key}/${_key}.txt"
		fi
		[[ ${_proofed} = "true" ]] && _contentState=$'\033[38;5;2m proofed \033[0m' || _contentState=$'\x1b[38;5;3munproofed\x1b[0m' 
		printf '  +---[ %-4s ]--[ %-10s ]-----------------+\n\n' "${3:-txt}" "${_contentState}"
		cat "${_path}" | tr '\n' ' ' | fold -s -w ${_previewcols} | sed -E "s/#([[:alnum:]-]+)/${_tag}#\1${_rst}/g"
	elif [ ${_type} = "json" ]; then
		printf '  +------[ %-4s ]-----------------------------+\n\n' "${_type}"
		cat "${_HOME}/transcripts/${2}/${2}.json" | jq -C
	fi
}
export -f _previewEntry

# extra controls for player
# pause/unpause (send 'p' to /proc/PID/fd/0) or echo 'p' >&"${FFPLAY[0]}"
# nope, need to open named pipes for this
# stop (send 'q' to /proc/PID/fd/0) or echo 'q' >&"${FFPLAY[0]}"
# slow/speed (these need to be preset VARS and included in the cli invocation of
# the player)

_stopPlayer() {
	if [[ -e "${_HOME}/state/player/playing" ]]; then
		# get the monitor pid and stop it
		if [[ -e "${_HOME}/state/player/monitor" ]]; then
			_monitor_pid=$(cat "${_HOME}/state/player/monitor")
			kill "${_monitor_pid}"
			rm "${_HOME}/state/player/monitor"
		fi
		# already playing, get pid and kill player and coproc
		_playerPID=$(basename "${_HOME}/state/player/pid"/*)
		_coprocPID=$(basename "${_HOME}/state/player/coproc"/*)
		_debug "player pid is '${_playerPID}'"
		_debug "coproc pid is '${_coprocPID}'"
		kill ${_playerPID} 2>/dev/null
		kill ${_coprocPID} 2>/dev/null
		# reset player state
		rm -rf "${_HOME}/state/player/pid"
		rm -rf "${_HOME}/state/player/coproc"
		rm -rf "${_HOME}/state/player/playing"
	else
		_debug "nothing to stop according to state"
	fi
}
export -f _stopPlayer

_play() {
	_monitorPID() {
		# wait for the pid to be gone, then clear up the state
		local _pid=$1
		while kill -0 "${_pid}" 2>/dev/null; do
			# ffplayer pid is active
			sleep 1
		done
		# ffplayer pid no longer active, clear state
		rm -rf "${_HOME}/state/player/coproc"
		rm -rf "${_HOME}/state/player/pid"
		rm -rf "${_HOME}/state/player/playing"
		# clean up after itself
		rm "${_HOME}/state/player/monitor"
	}
	local _key=${1}
	_debug "play called for '${1}'"
	# make sure there is a state dir
	[[ ! -d "${_HOME}/state/player" ]] && mkdir "${_HOME}/state/player"
	# check if state indicates active player
	if [[ -e "${_HOME}/state/player/playing" ]]; then
		# get the monitor pid and stop it
		if [[ -e "${_HOME}/state/player/monitor" ]]; then
			_monitor_pid=$(cat "${_HOME}/state/player/monitor")
			kill "${_monitor_pid}"
			rm "${_HOME}/state/player/monitor"
		fi
		# already playing, get pid and kill player and coproc
		_playerPID=$(basename "${_HOME}/state/player/pid"/*)
		_coprocPID=$(basename "${_HOME}/state/player/coproc"/*)
		_debug "player pid is '${_playerPID}'"
		_debug "coproc pid is '${_coprocPID}'"
		kill ${_playerPID} 2>/dev/null
		kill ${_coprocPID} 2>/dev/null
		# reset player state
		rm -rf "${_HOME}/state/player/pid"
		rm -rf "${_HOME}/state/player/coproc"
		rm -rf "${_HOME}/state/player/playing"
	else
		_debug "no active player detected"
	fi
	# determine file type stupidly
	if [ -f "${_HOME}/audio/${_key}.m4a" ]; then
		_audio="${_HOME}/audio/${_key}.m4a"
	elif [ -f "${_HOME}/audio/${_key}.mp3" ]; then
		_audio="${_HOME}/audio/${_key}.mp3"
	elif [ -f "${_HOME}/audio/${_key}.wav" ]; then
		_audio="${_HOME}/audio/${_key}.wav"
	else
		_debug "${FUNCNAME[0]}: unknown media type for '${_key}'"
		return
	fi
	_debug "got the file type '${_audio}'"
	# run as coproc and set state
	coproc FFPLAY { ffplay -autoexit \
	 	-nodisp "${_audio}" \
		>/dev/null 2>&1 &
		_coproc_playerPID=$!;
		mkdir -p "${_HOME}/state/player/playing/${_key}";
		mkdir -p "${_HOME}/state/player/pid";
		mkdir -p "${_HOME}/state/player/pid/${_coproc_playerPID}";
		# notes, running ffplay with nohup would allow it to play beyond 
	}
	mkdir -p "${_HOME}/state/player/coproc";
	mkdir -p "${_HOME}/state/player/coproc/${FFPLAY_PID}";
	# wait for ffplay pid to show up
	_debug "waiting on ffplay pid..."
	while [[ ! -n $(find "${_HOME}/state/player/pid" -maxdepth 1 -type d -empty -print -quit) ]]; do
		sleep 0.5
	done
	# get the pid
	_monitor_pid=$(basename "${_HOME}/state/player/pid"/*)
	_debug "got ffplay pid..."
	_debug "start ffplay monitor..."
	# run the pid monitor function in the background
	_monitorPID "${_monitor_pid}" &
	#TODO experiment with using nohup for this process...to clean up
	# note the monitor job so we can stop it if _play is called again
	echo $! > "${_HOME}/state/player/monitor"
	_debug "_play function done."
}
export -f _play

_editProof() {
	# $1 is the _key in transcripts/ and catalog/
	local _path="${_HOME}/transcripts/${1}/${1}.txt"
	# cp the file to proofs (formatted nicely)
	cat "${_path}" | tr '\n' ' ' | fold -s -w 66 > "${_HOME}/proofs/${1}.txt"
	vim "${_HOME}/proofs/${1}.txt"
	#TODO now commit this
}
export -f _editProof


#TODO
# disable screen locking during recording
# gsettings get org.gnome.desktop.screensaver lock-enabled
# i think it might be disrupting?

# run the dictate window
_shell() {
	local _micSTATE
	local _ffmpegSTATE
	local _ffmpegPID
	local _whisperSTATE
	local _whisperPID
	local _importSTATE
	local _importPID
	local _recordingState
	local _recording_pid=""
	local _transcriptionState="waiting"
	local _transcription_pid=""
	# states: waiting, recording, paused
	_cStat() {
		[[ "${1}" =~ ^(recording) ]] && { tput blink; tput setaf 7; tput setab 1; }
		[[ "${1}" =~ ^(waiting) ]] && tput setaf 3
		[[ "${1}" =~ ^(idle) ]] && tput setaf 3
		[[ "${1}" =~ ^(paused) ]] && { tput blink; tput setaf 7; tput setab 1; }
		[[ "${1}" =~ ^(unknown) ]] && { tput blink; tput setaf 2; }
		[[ "${1}" =~ ^(importing) ]] && { tput blink; tput setaf 3; }
		[[ "${1}" =~ ^(transcribing) ]] && { tput blink; tput setaf 4; }
		echo -n "${1}"
		tput sgr0
	}
	_getKey() {
		# generate unique unix-time key and record (mkdir) in catalog
		local _key=$(date +%s)
		# don't give out the same key twice
		if [ -e "${_HOME}/catalog/${_key}" ]; then
			sleep 1
			# try again after a sleep (recursive)
			_getKey
		else
			# enter key into catalog
			mkdir "${_HOME}/catalog/${_key}"
			# print the key
			echo ${_key}
		fi
	}
	_catalogNew() {
		# add $1 to catalog unless it exists, otherwise return 1
		local _entry=$1
		[[ -d "${_HOME}/catalog/${_entry}" ]] && { _warn "catalog entry '${_entry}' exists"; return 1; }
		mkdir "${_HOME}/catalog/${_entry}"
	}
	_catalogAdd() {
		local _key=$1
		local _type=$2
		local _value=${3:-}
		[[ -d "${_HOME}/catalog/${_key}" ]] || { _warn "no such key '${_key}' in catalog"; return 1; }
		echo "${_value}" > "${_HOME}/catalog/${_key}/${_type}"
	}
	_record() {
		# do not record if recording is active
		[[ -e "${_HOME}/state/mic/recording" ]] && { _warn "recording in progress"; return; }
		# change mic state from idle to transitioning
		[[ -d "${_HOME}/state/mic/idle" ]] && rmdir "${_HOME}/state/mic/idle"
		mkdir -p "${_HOME}/state/mic/transitioning"
		# set output format to wav (cpu vs space)
		local oFmt="wav"
		# get key and define file name
		local _key=$(_getKey)
		local _file="${_key}.${oFmt}"
		# start ffmpeg recording
		ffmpeg -loglevel warning \
			-progress "${_HOME}/log/${_key}-ffmpeg.progress" \
			-hide_banner \
			-f alsa \
			-i default \
			-sample_rate 44100 \
			"${_HOME}/mic/${_file}" \
		 	>"${_HOME}/log/${_key}-ffmpeg.log" 2>&1 &
		# get the pid of the ffmpeg process (so we can signal it later)
		_ffmpegPID=$!
		# make sure this process is running
		if [ -d "/proc/${_ffmpegPID}" ]; then
			# system reports this is so, so change state
			mv "${_HOME}/state/mic/transitioning" "${_HOME}/state/mic/recording" 
			mkdir -p "${_HOME}/state/mic/pid/${_ffmpegPID}"
			mkdir -p "${_HOME}/state/mic/file/${_file}"
			mkdir -p "${_HOME}/state/mic/progressfile/${_key}-ffmpeg.progress"
			mkdir -p "${_HOME}/state/mic/logfile/${_key}-ffmpeg.log"
		else
			# some problem with ffmpeg occurred...change state to unknown
			mv "${_HOME}/state/mic/transitioning" "${_HOME}/state/mic/unknown"
			_debug "ffmpeg process for ${_key} did not start successfully; pid=${_ffmpegPID}"
		fi
	}
	_abort() {
		# check for recording in progress
		[[ -e "${_HOME}/state/mic/recording" ]] || { _warn "nothing to abort"; return; }
		# check for the pid dir in which the pid is stored as a dir
		[[ -e "${_HOME}/state/mic/pid" ]] || { _warn "no pid found; problem"; return; }
		# get the ffmpeg pid and filename from state dir
		ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
		# get the key
		key=${ffmpegFILE%%.*}
		# send INT signal to ffmpeg
		kill -SIGINT ${ffmpegPID}
		# remove pid info from state dir
		rm -rf "${_HOME}/state/mic/pid/"
		# change mic state
		mv "${_HOME}/state/mic/recording" "${_HOME}/state/mic/idle"
		# remove state file info
		rm -rf "${_HOME}/state/mic/file"
		# remove media file
		rm "${_HOME}/mic/${ffmpegFILE}"
		# remove logs
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/logfile"/*)"
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/progressfile"/*)"
		# remove log pointers
		rm -rf "${_HOME}/state/mic/progressfile"
		rm -rf "${_HOME}/state/mic/logfile"
		# update catalog
		rmdir "${_HOME}/catalog/${key}"
	}
	_save() {
		# check for recording in progress
		[[ -e "${_HOME}/state/mic/recording" ]] || { _warn "not recording"; return; }
		# check for the pid dir in which the pid is stored as a dir
		[[ -e "${_HOME}/state/mic/pid" ]] || { _warn "no pid found; problem"; return; }
		# get the ffmpeg pid and filename from state dir
		ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
		# get the key
		key=${ffmpegFILE%%.*}
		# send INT signal to ffmpeg
		kill -SIGINT ${ffmpegPID}
		# remove pid info from state dir
		rm -rf "${_HOME}/state/mic/pid/"
		# change mic state
		mv "${_HOME}/state/mic/recording" "${_HOME}/state/mic/idle"
		# remove state file info
		rm -rf "${_HOME}/state/mic/file"
		# move media file to queue
		mv "${_HOME}/mic/${ffmpegFILE}" "${_HOME}/queue/${ffmpegFILE}"
		# remove logs
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/logfile"/*)"
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/progressfile"/*)"
		# remove log pointers
		rm -rf "${_HOME}/state/mic/progressfile"
		rm -rf "${_HOME}/state/mic/logfile"
	}
	_browse() {
		# browse the transcripts
		# if there aren't any, don't bother
		[[ $(ls -A ${_HOME}/transcripts/) ]] || { _warn "no transcripts available"; return; }
		# call the picker function (fzf wrapper)
		_namePicker _chosen "ls ${_HOME}/catalog" _previewEntry "transcripts" "? for help"
	}
	_import() {
		# use _finder (from library) to identify directory with media files
		# STRICT requirement...no sanity checks on file imports yet
		# some sanity checking is in place, but not enough
		_dir=$(_finder)
		[[ -z "${_dir}" ]] && { _warn "fzf returned empty string from _finder"; return; }
		# count files
		_count=0
		for file in "${_dir}"/*; do
			if [ -f "${file}" ]; then
				# ignore everything but mp3, m4a, wav
				[[ ( "${file}" == *.mp3 || "${file}" == *.m4a || "${file}" == *.wav ) ]] || break
				((_count++))
			fi
		done
		[[ ${_count} = 0 ]] && { _warn "no valid media files found"; return; }
		_goAhead=false
		until $_goAhead; do
			read -rsn1 -p $(_ask "import ${_count} files from '${_dir}'? [y/n/?] ") _yn
			echo
			[[ ${_yn} = "n" ]] && { _warn "import aborted"; return; }
			[[ ${_yn} = "?" ]] && { _info "list of proposed import follows"; \
				_filecount=0
				printf "o=============================================================o\n"
				printf "%-4s %-30s %-10s %-6s\n" "index" "name" "size" "duration"
				printf "o-------------------------------------------------------------o\n"
				for file in "${_dir}"/*; do
					if [ -d "${file}" ]; then
						#_warn "ignoring directory ${file}"
						printf " %-4s %-30s %-10s\n" '-' "${file}" "ignoring nested directory"
					elif [ -f "${file}" ]; then
						# ignore everything but mp3, m4a, wav
						[[ ( "${file}" == *.mp3 || "${file}" == *.m4a || "${file}" == *.wav ) ]] || break
						((_filecount++))
						_name=$(basename ${file})
						_size=$(du -h "${file}" | awk '{print $1}')
						_duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${file}")
						if [[ ${_duration%%.*} -lt 60 ]]; then
						 	_duration="${_duration%%.*} seconds"
						else
							seconds=${_duration%%.*}
							minutes=$((seconds / 60))
							remaining_seconds=$((seconds % 60))
							_duration="${minutes}:${remaining_seconds}"
						fi
						printf " %-4s %-30s %-10s %-10s\n" ${_filecount} ${_name} ${_size} ${_duration}
					else
						_warn "'${file}' is neither file nor directory"
					fi
				done
				printf "o=============================================================o\n"
			}
			[[ ${_yn} = "y" ]] && _goAhead=true
		done
		for _file in ${_dir}/*; do
			# only process files
			[[ -f "${_file}" ]] || continue
			# ignore files that are not known media files (mp3,m4a,wav)
			[[ ( "${_file}" == *.mp3 || "${_file}" == *.m4a || "${_file}" == *.wav ) ]] || _warn "$_file not allowed"
			# get the unixtime from the "creation_time" 
			c_time=$(ffprobe -v error -show_entries stream_tags=creation_time -of default=noprint_wrappers=1:nokey=1 "${_file}")
			c_unix=$(date -d "${c_time}" +%s)
			suffix=${_file##*.}
			# next check that there is no conflict in catalog/
			# if so, increment _key by one and check again, until a unique key is
			# obtained
			# once the unique key is found
			# mkdir in catalog with the key
			_getKeyImport() {
				# custom _getkey function exclusive to _import
				# pass desired key as $1
				# prints that key (if no conflict)
				# otherwise prints the next free key in time
				# generate unique unix-time key and record (mkdir) in catalog
				local _key=$1
				# don't give out the same key twice
				if [ -e "${_HOME}/catalog/${_key}" ]; then
					# increment and try again
					((_key++))
					# try again after a sleep (recursive)
					_debug "_getKeyImport is gone recursive"
					_getKeyImport ${_key}
				else
					## enter key into catalog
					#mkdir "${_HOME}/catalog/${_key}"
					# print the key
					echo ${_key}
				fi
			}
			_key=$(_getKeyImport ${c_unix})
			# update the catalog with metadata and add the file to the queue
			if [[ ${_key} = ${c_unix} ]]; then
			 	_debug "got new matching key '${_key}' from '${c_unix}'"
				_debug "adding new key '${_key}' to catalog"
				_catalogNew "${_key}"
				_catalogAdd "${_key}" "import"
				_catalogAdd "${_key}" "original_name" "$(basename ${_file})" || { _error "great failure"; return 1; }
				_catalogAdd "${_key}" "audio_file" "${_key}.${suffix}"
				# extract metadata from each media file into catalog
				ffprobe -v error -print_format flat -show_format -show_streams "${_file}" > "${_HOME}/catalog/${_key}/file_metadata.txt"
				cp "${_file}" "${_HOME}/queue/${_key}.${suffix}"
			else
				_warn "'${c_unix}' conflict, got incremented '${_key}'"
				_import_filename=$(basename "${_file}")
				_catalog_filename=$(cat "${_HOME}/catalog/${c_unix}/original_name" || echo "")
				if [[ ${_import_filename} = ${_catalog_filename} ]]; then
					_warn "duplicate file detected...ignoring"
				else
					# the above isn't very robust, but import the file anyway
					_catalogNew "${_key}"
					_catalogAdd "${_key}" "import"
					_catalogAdd "${_key}" "original_name" "$(basename ${_file})" || { _error "great failure"; return 1; }
					_catalogAdd "${_key}" "audio_file" "${_key}.${suffix}"
					# extract metadata from each media file into catalog
					ffprobe -v error -print_format flat -show_format -show_streams "${_file}" > "${_HOME}/catalog/${_key}/file_metadata.txt"
					cp "${_file}" "${_HOME}/queue/${_key}.${suffix}"
				fi
			fi
		done
	}

	_showFileSize() {
			ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
			if [[ -e "${_HOME}/mic/${ffmpegFILE}" ]]; then
				echo "$(ls -l "${_HOME}/mic/${ffmpegFILE}" | awk '{print $5}')"
			else
				echo "n/a"
			fi
	}
	_showFileName() {
			ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
			if [[ -e "${_HOME}/mic/${ffmpegFILE}" ]]; then
				echo "${ffmpegFILE}"
			else
				echo "none"
			fi
	}
	_checkQueue() {
		[[ -e "${_HOME}/state/whisper/transcribing" ]] && return
		# if file exists in queue, process it
		if [ -n "$(ls ${_HOME}/queue 2>/dev/null)" ]; then
			mkdir -p "${_HOME}/state/whisper/transcribing"
			# get the oldest file
			_file=$(ls "${_HOME}/queue/" | head -1)
			# set its full path
			_path="${_HOME}/queue/${_file}"
			# get the key
			_key=${_file%%.*}
			# run whisper as a coprocess
			# suppress_tokens expects a comma separated list of token ids
			# eg 0=!  ,=11  .=13  ?=30
			coproc WHISPER { whisper "${_path}" \
				--verbose False \
				--task transcribe \
				--language en \
				--model medium.en \
				--suppress_tokens '' \
				--output_dir "${_HOME}/transcripts/${_key}/." \
				--output_format all \
				--word_timestamps True \
				--max_line_width 60 \
				> "${_HOME}/log/whisper.log" 2>&1 || mkdir "${_HOME}/state/whisper/failed";
				mv "${_path}" "${_HOME}/audio/${_file}";
				rmdir "${_HOME}/state/whisper/transcribing";
		 		rm -rf "${_HOME}/state/whisper/coproc";	
				# make recursive to empty the queue (but serially)
				_checkQueue
			}
			# note the coprocess pid in state
			mkdir -p "${_HOME}/state/whisper/coproc/${WHISPER_PID}"
		else
			#_debug "no files in queue"
			true
		fi
	}
	_getState() {
		if [[ -e "${_HOME}/state/mic/recording" ]]; then
			_recordingState="recording"
			_recording_ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		elif [[ -e "${_HOME}/state/mic/idle" ]]; then
			_recordingState="idle"
			_recording_ffmpegPID=''
		else
			_recordingState="idle"
			_recording_ffmpegPID=''
		fi
		if [[ -e "${_HOME}/state/whisper/transcribing" ]]; then
			_transcribingState="transcribing"
			_transcribing_coprocPID=$(basename "${_HOME}/state/whisper/coproc"/*)
		else
			_transcribingState="idle"
			_transcribing_coprocPID=''
		fi
	}
	_printScreen() {
		quenum=$(ls "${_HOME}/queue" | wc -l)
		transnum=$(ls "${_HOME}/transcripts" | wc -l)
		proofnum=$(ls "${_HOME}/proofs" | wc -l)
		audnum=$(ls "${_HOME}/audio" | wc -l)
		micstate=$(_cStat ${_recordingState})
		whispstate=$(_cStat ${_transcribingState})
		ffmpegpid=${_recording_ffmpegPID:-none}
		transpid=${_transcribing_coprocPID:-none}
		whisppid=${_transcribing_whisperPID:-none}
		space=$(du -sh "${_HOME}" | awk '{print $1}')
		#clear
		printf "=====\033[1mDICTATE MACHINE\033[0m--------Μνήμων--(%s)-------pid:%10d==============o\n" $_NAME $$
		printf "\n"
		printf " %-10s %-20s %30s %s\n" "mic state:" $micstate "whisper state:" $whispstate
		printf "  %-10s %-20s %17s %s\n" "ffmpeg pid:" $ffmpegpid "coproc pid:" $transpid 
		printf "  %-10s %-20s %17s %s \n" "media:" $(_showFileName) "whisper pid:" $whisppid
		printf "  size: %s\n" $(_showFileSize) 
		printf "\no==============================================================================o\n"
		printf "  %s(%s)     queue: %s     transcripts: %s    proofed: %s\n" $audnum $space $quenum $transnum $proofnum
		printf "o------------------------------------------------------------------------------o\n"  
		printf '
 r) record                          [begins recording from mic]
 a) abort recording                 [deletes current recording]
 s) stop and transcribe             [saves current recording and begins transcription]
 b) browse transcriptions           [browse transcripts for proofing]
 m) move proofs                     [not implemented...push to?]
 i) import audio files              [import audio files]
 q) quit

  token words recognized: quote, unquote, hash, underscore, dash
	metadata commands, eg, "hash g dash 1" => #g-1
	                   eg, "hash oc dash put" => #oc-put

'

	}

	# trying to open a monitor to the recording and view ffmpeg stats ?
  #looksee: '$(cat <&"${RECORDING[0]}" | grep ^total_size*)'
  #looksee: '$(read -r output <&"${RECORDING[0]}"; echo $output | grep ^total_size*)'
	#look: $(_watchCOPROC <&$"${RECORDING[0]}")

	# main loop for menu screen
	_getState
	_printScreen
	while read -r -s -n1 -p"$(_ask 'enter selection') " _selection; do
		echo
		case ${_selection} in
			t)
				_inspect || :
				;;
			r)
				_record || :
				;;
			a)
				_abort || :
				;;
			s)
				_save || :
				;;
			b)
				_browse || :
				;;
			i)
				# import
				_import || :

				#_dir=$(_finder)
				#for _file in ${_dir}/*; do
				#	# get the unixtime
				#	c_time=$(ffprobe -v error -show_entries stream_tags=creation_time -of default=noprint_wrappers=1:nokey=1 "${_file}")
				#	c_unix=$(date -d "${c_time}" +%s)
				#	suffix=${_file##*.}
				#	cp "${_file}" "${_HOME}/queue/${c_unix}.${suffix}"
				#done
				;;
			I)
				# first draft import
				[[ ${_recordingState:-} != "waiting" ]] && continue
				[[ ${_transcribingState:-} = "transcribing" ]] && continue
				#local _keepAudioFiles=false
				[ ! -d "${_HOME}/import" ] && mkdir "${_HOME}/import"
				echo "importing" > ${_HOME}/import/.state
				_dir=$(_finder)
				_debug "import files from ${_dir}"
				_fileList=()
				for _file in ${_dir}/*.m4a; do
					_fileList+=("${_file}")
				done
				_debug "$(declare -p _fileList)"
				_debug "found ${#_fileList[@]} files"
				_ask "enter name for import job "
				read _importName
				[ -z "${_importName}" ] && { _warn "import aborted; name needed"; rm ${_HOME}/import/.state; continue; }
				[ -d "${_HOME}/import/${_importName}" ] && { _warn "name conflict"; rm ${_HOME}/import/.state; continue; }
				mkdir -p "${_HOME}/import/${_importName}"
				# extract creation_time and copy as <unixtime.filetype> into import dir
				for _importFile in ${_fileList[@]}; do
					file_type=${_importFile##*.}
					c_time=$(ffprobe -v error -show_entries stream_tags=creation_time -of default=noprint_wrappers=1:nokey=1 "${_importFile}")
					c_unix=$(date -d "${c_time}" +%s)
					duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${_importFile}")
					echo "${_importFile} ${c_unix}" "${duration}" "${file_type}"
					cp "${_importFile}" "${_HOME}/import/${_importName}/${c_unix}.${file_type}"
				done
				# extract metadata from each media file
				for importedFile in "${_HOME}/import/${_importName}"/*; do
					ffprobe -v error -print_format flat -show_format -show_streams "${importedFile}" > "${importedFile}_metadata.txt"
				done
				# build the list for whisper cli
				_whisperList=()
				for _f in ${_HOME}/import/${_importName}/*.${file_type}; do
					_whisperList+=("${_f}")
				done
				# begin the whisper job
				coproc WHISPER { whisper --language en --verbose False --model medium.en --suppress_tokens '' \
					-o "${_HOME}/transcripts/." -f txt ${_whisperList[@]} 2>&1 >/dev/null; \
					rm ${_HOME}/import/.state; rm ${_HOME}/import/.transcribing_*; }
				_debug "whisper: _coproc_pid=${WHISPER_PID}"
				_debug "WHISPER stdout is ${WHISPER[0]}"
				_debug "WHISPER stdin is ${WHISPER[1]}"
				echo ${WHISPER_PID} > "${_HOME}/import/.transcribing_coprocPID"
				echo ${WHISPER[0]} > "${_HOME}/import/.transcribing_coprocSTDOUT"
				echo ${WHISPER[1]} > "${_HOME}/import/.transcribing_coprocSTDIN"
				_transcription_pid=$(ps --no-headers -o pid --ppid ${WHISPER_PID})
				_transcription_pid=$(_trimString ${_transcription_pid})
				echo ${_transcription_pid} > "${_HOME}/import/.transcribing_whisperPID"
				#whisper --language en --verbose False --model medium.en --suppress_tokens '' \
				#	-o "${_HOME}/transcripts/." -f txt ${_whisperList[@]} 2>&1 >/dev/null
				;;
				# import workflow
				# OPTIONS...keep audio file (vs discard)
				# use finder to locate a directory with audio files ready to import
				# count, itemize, measure each one
				# create state files with this catalog info
				# - file path
				# - file type
				# - file size
				# - file order
				# check with user the data and order is correct (maybe not)
				# ask user for import name (like source in germ)
				# create mktemp /tmp/dir workspace
				# for each file
				# get a unique <unixtime> key
				# copy file to /tmp/ as <unixtime>.<filetype>
				# extract the file metadata
				# ffprobe -print_format json -show_format -show_streams -hide_banner -i 1.m4a
				# save it as /import/<file>
				# NOTE: audio file metadata from iphone includes:
				# - creation_time
				# - duration
				# - title (user can change file name in iphone)
				# - filename
				# - encoder (includes iphone's name)
				# 
			q)
				if [[ ${_recordingState} = "recording" ]]; then
					_warn "recording live now"
					read -rsn1 -p "$(_ask 'really quit now? [yn] ')" _yn
					echo
					[[ ${_yn} = "y" ]] && return || continue
				else
					return 0
				fi
				;;
		esac
		_getState
		_checkQueue
		_printScreen
	done
}

	#_doRecord() {
	#	local oFmt="wav"
	#	local _key=$(_getKey)
	#	local _file="${_key}.${oFmt}"
	#	[[ -e "${_HOME}/state/mic/recording" ]] && { _warn "recording in progress"; return; }
	#	ffmpeg -loglevel warning \
	#		-progress "${_HOME}/log/${_key}-ffmpeg.progress" \
	#		-hide_banner \
	#		-f alsa \
	#	 	-i default \
	#	 	-sample_rate 44100 \
	#	 	"${_HOME}/mic/${_file}" \
	#		>"${_HOME}/log/${_key}-ffmpeg.log" 2>&1 &
	#	_ffmpegPID=$!
	#	mkdir -p "${_HOME}/state/mic/recording"
	#	mkdir -p "${_HOME}/state/mic/pid/${_ffmpegPID}"
	#}
	#_doTranscribe() {
	#	local _file=$1
	#	local model="medium.en"
	#	local _queue="${_HOME}/queue"
	#	local _path="${_queue}/${_file}"
	#	# suppress_tokens expects a comma separated list of token ids
	#	# eg 0=!  ,=11  .=13  ?=30
	#	whisper "${_path}" --language en --verbose False --model medium.en --suppress_tokens '' \
	#	 	-o "${_HOME}/transcripts/." -f txt 2>&1 >"${_HOME}/log/${_key}-whisper.log"
	#	#rm "${_path}"
	#	[ ! -d "${_HOME}/audio" ] && mkdir "${_HOME}/audio"
	#	mv "${_path}" "${_HOME}/audio/${_file}"
	#	}
main() {
	# read all the positional parameters
  _getOpts "${@}"
  # setup the environment after processing all command line parameters
  _setEnv
  # validate the environment (external tools required)
  _checkExternalTools || { _error "cannot run until these problems are resolved"; return 1; }
  # check for the working directory
  _checkHome || { _error "cannot run without a working environment"; return 1;  }
  # enter custom shell if no arguments
  [ -z "${_subCommand:-}" ] && _shell
  # otherwise, pass the commands to the called "command"
  [[ -n "${_subCommand:-}" ]] && _debug "now calling the eval to run '${_subCommand:-}'"
  [[ -n "${_subCommand:-}" ]] && eval _"${_subCommand}" || :
}
main "${@}"
