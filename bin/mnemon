#!/usr/bin/env bash
# file: mnemon
# source: https://github.com/periplume/notelos.git
# author: jason@bloom.us
# description: dictate and transcription machine

#TODO after proofing, reformat...remove multple spaces
# NO, the problem is the viewer...which is removing the CR

# STRICT SHELL
set -o errexit 
set -o nounset
set -o pipefail
IFS=$'\n\t'

###########################
# PREREQUISITES
###########################
 
# required external commands
_requiredCommands=(git tig fzf ffmpeg whisper)

###########################
# LIBRARY
###########################

# source library commands and set up log/console
# use the library file from the same directory if possible
[[ -e "$(dirname $0)/notelos-lib.sh" ]] \
	&& source "$(dirname $0)/notelos-lib.sh" \
	|| source notelos-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

# default initial debugging and logging settings
# note: command line parameters can modify these
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=true

# instantiate the log/mesg functions with defaults (these will be re-initialized
# after reading positional parameters)
_fLOG

####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF
usage: nmemon [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit
 -x      force standalone mode

alternate env settings:
 -a <name>  set the nmemon dir name to <name>
 -p <path>  set alternate base path

commands:
EOF
_printCommands
}

_printCommands() {
	cat <<  EOF
 new                 record and transcribe a new thing   
 import              fetch external recordings and transcribe
 create              create a new nmemon git database
 inspect             run tig on the nmemon git bare repo
 search              interactive search
 browse              read through the transcriptions
EOF
}

_printInfo () {
  cat << EOF
nmemon records and transcribes spoken english to written text
EOF
}

####################################
# PARAMETER PROCESSING
####################################

_getOpts () {
	# preserve the initial positional parameters
	export _fullCommand="${@}"
	_debug "full command is '${_fullCommand}'"
	local OPTIND
	# do not allow names for notelos or self to be names of commands
	_isCommand() {
		local _allowed=true
		local _commandList
		_commandList=$(_printCommands | cut -f2 -d' ')
		for _command in ${_commandList}; do
      [[ "${_command}" = "${1}" ]] && _allowed=false 
    done
    [[ ${_allowed} = "true" ]] || return 1
  }
	while getopts ":hsdlxva:p:" flag ; do
		case ${flag} in 
			h)
				_printInfo; _printUsage; exit 0
				;;
			a)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_isCommand "${OPTARG}" || { _error "'${OPTARG}' is not allowed (it is a command)"; exit 1; }
				_NAME=${OPTARG}
				_warn "using alt name '${_NAME}'"
				;;
			p)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is NOT a flag ($OPTARG)"; exit 1; }
				_BASE=${OPTARG}
				_warn "using alt path '${_BASE}'"
				;;
 	    s)
				_debug "${FUNCNAME[0]}: enabling silent mode with flag -$flag"
 	      _SILENT=true
				;;
			d)
				_debug "${FUNCNAME[0]}: enabled debug mode with flag -$flag"
				_DEBUG=true
				;;
			l)
				_debug "${FUNCNAME[0]}: enabled log mode with flag -$flag"
				_LOG=true
				;;
			x)
        _debug "${FUNCNAME[0]}: running in standalone mode with -$flag"
        _MODE=standalone
        ;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -${OPTARG}"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1)); OPTIND=1
	# preserve the full subcommand with its parameters
	export _subCommandParams="${@}"
	# look for the subcommand and check for its options
	while ((${#})); do
		case ${1} in
			help)
				_printInfo; _printUsage; exit 0
				;;
			new)
				_subCommand=$1; shift
				return
				;;
			import)
				_subCommand=$1; shift
				return
				;;
			create)
				_subCommand=$1; shift
				return
				;;
			inspect)
				_subCommand=$1; shift
				return
				;;
			search)
				_subCommand=$1
				return
				;;
			browse)
				_subCommand=$1
				return
				;;
			*)
				_error "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
  # get the name and absolute path of the calling script
  _selfNAME=$(basename "${BASH_SOURCE[0]}")
  _selfABSOLUTE=$(readlink -f "${BASH_SOURCE[0]}")
  _selfBASE=$(dirname "${_selfABSOLUTE}")
  _selfCALL=${0}
  _selfPWD=$(pwd)
	# determine mode (notelos-integrated or standalone)
	[[ -n "${_notelosHOME+x}" && ${_MODE:-} != "standalone" ]] && _MODE=integrated || _MODE=standalone
	# note: the -x switch overrides the global _notelosHOME var 
	# integrated mode only happens when global var _notelosHOME is available
	# set up the working environment
	if [[ ${_MODE} = "integrated" ]]; then
		# set up integrated mode
		_MASTER="${_notelosNAME}"
		_BASE="${_notelosHOME}"
		_NAME="${_NAME:-${_selfNAME}}"
		_HOME="${_BASE}/${_NAME}"
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/.log/${_NAME}.log"
		# inherit these (from notelos)
		_DEBUG=${_notelosDEBUG}
		_LOG=${_notelosLOG}
		_SILENT=${_notelosSILENT}
		_USERNAME=${_notelosUSERNAME}
		_USEREMAIL=${_notelosUSEREMAIL}
		_EDITOR=_notelosEdit
	else
		# set up standalone mode
		_MASTER=self
		_BASE="${_BASE:-$HOME}"
		_NAME="${_NAME:-${_selfNAME}}"
		_HOME=${_BASE}/${_NAME}
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/${_NAME}.log"
		# inherit these
		_DEBUG=${_DEBUG:-false}
		_LOG=${_LOG:-false}
		_SILENT=${_SILENT:-false}
		_USERNAME=$(whoami)
		_USEREMAIL="unknown"
		_EDITOR=${EDITOR:-nano}
	fi
  [[ -f "${_LOGFILE:-}" ]] && _LOGGING=true || _LOGGING=false
	_debug "$(declare -p _MODE)"
	_debug "$(declare -p _MASTER)"
	_debug "$(declare -p _NAME)"
	_debug "$(declare -p _BASE)"
	_debug "$(declare -p _HOME)"
	_debug "$(declare -p _USERNAME)"
	_debug "$(declare -p _USEREMAIL)"
	_debug "$(declare -p _GITDIR)"
	_debug "$(declare -p _LOGFILE)"
	_debug "$(declare -p _DEBUG)"
	_debug "$(declare -p _SILENT)"
	_debug "$(declare -p _LOG)"
	_debug "$(declare -p _LOGGING)"
	# TODO stop the export from notelos subordinates (eg mnemon) in order to allow
	# them to call other subordinates and not confuse them with these generic
	# values
	#export _MODE
	#export _MASTER
	#export _NAME
	#export _BASE
	export _HOME
	export _EDITOR
	#export _USERNAME
	#export _USEREMAIL
	#export _GITDIR
	#export _LOGFILE
	#export _DEBUG
	#export _SILENT
	#export _LOG
	#export _LOGGING
	# need to see if NOT exporting these values will impact mnemon itself
	# yes, we rely on $_HOME for all fzf-related stuff.  important then not to
	# inherit _HOME
	# yes we use _EDITOR as well, but i can think of no conflict with it
	# in fact, it should be set from _notelosEDITOR
}

_checkExternalTools() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			: #_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}

_checkHome() {
  # check if the home dir exists
  # check if it is a mnemon-created git
  # return 1 if missing or not git
  # mind condition: if subcommand is create
	[[ ! -d "${_BASE}" && ${_MODE} = "notelos" ]] && { _error "notelos base not found"; exit 1; }
	[[ -d "${_BASE}" ]] || { _error "base '${_BASE}' does not exist"; exit 1; }
	local _base="${_BASE}"
	local _dirName="${_NAME}"
	local _dirPath="${_HOME}"
	local _git_desc="${_dirPath}/.git/description"
  if [ -d "${_dirPath}" ]; then
    if [ -f "${_git_desc}" ]; then
      # the git description file exists, lets check it for our marker
      read -r _desc < "${_git_desc}"
      if [[ ${_desc} == ${_MASTER}:${_NAME}:${_USERNAME}* ]]; then
        # if repo does exist, return 0
        _debug "${_git_desc} = ${_desc}"
				return
      else
        # if repo does not exist, warn and exit
        _error "${_dirPath} exists and is NOT a notelos-created repo"
        return 1
      fi
    else
      _error "${_dirPath} exists and is NOT a git repo"
      _error "move existing ${_dirPath} before proceeding"
      return 1
    fi
  else
    # dir does not exist
    _warn "'${_dirPath}' does not exist"
    read -rsn1 -p "$(_ask 'create repo now? [y/n]')" _yn
    echo
    [[ ${_yn} != "y" ]] && { _warn "cannot run without a repo"; return 1;  }
    _create || { _error "could not create ${_dirName} repo"; return 1; }
    return
  fi
}

############################
# CREATE
############################

_create() {
	# do not overwrite an existing anything
	[[ -d "${_HOME}" ]] && { _error "'${_HOME}' exists"; return 1; }
	[ ! -d "${_HOME}" ] && mkdir "${_HOME}"
	git init -q -b main "${_HOME}"
  git -C "${_HOME}" config user.name "${_USERNAME}"
  git -C "${_HOME}" config user.email "${_USEREMAIL}"
	# make the nmemon skeleton workflow dirs
	mkdir "${_HOME}/mic"					# the live recording
	mkdir "${_HOME}/queue"				# the queue of audio files
	mkdir "${_HOME}/transcripts"	# whisper output
	mkdir "${_HOME}/proofs"				# human proofed...can push
	mkdir "${_HOME}/audio"				# audio files corresponding to transcripts
	mkdir "${_HOME}/state"				# where state is maintained
	mkdir "${_HOME}/log"					# where logs go
	mkdir "${_HOME}/catalog"			# the master catalog of recordings
	# ignore recordings and import
	echo "mic/" > "${_HOME}/.gitignore"
	echo "queue/" >> "${_HOME}/.gitignore"
	echo "audio/" >> "${_HOME}/.gitignore"
	# add gitignore and make first commit
  git -C "${_HOME}" add .gitignore
  git -C "${_HOME}" commit -q -m "[genesis] ${_NAME} created by ${_USERNAME}"
  #git -C "${_HOME}" --git-dir="${_GITDIR}" add .gitignore
  #git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[genesis] ${_NAME} created by ${_USERNAME}"
	# put the installed signature in git description file
  _gitInitial=$(git -C "${_HOME}" rev-parse --short --verify main)
  _time=$(date +%s)
  printf "${_MASTER}:${_NAME}:${_USERNAME}:${_time}:${_gitInitial}\n" > "${_HOME}/.git/description"
}

##################################
# INSPECT
##################################

_inspect() {
	tig -C${_HOME}
}

# usage:
# _fzfBrowse _newName   _getSourceList _validateNamePreview "prompt"    "special notes"
# (function)  (nameref)     (fzf feed)      (fzf preview)     fxf prompt  (fzf header)    

# _browse calls this function as:
# _fzfBrowse _chosen "ls ${_HOME}/catalog" _previewEntry "all" "? for help"
_fzfBrowse () {
	# $1 = nameref for return value
	# $2 = input function (prints the list of existing whatever)
	# $3 = validation function for fzf preview window (in which $1=query $2=selection)
	# $4 = prompt string
	# $5 = optional special instructions
	local -n _return=$1
	local _input=$2
	local _preview=$3
	local _prompt=$4
	export _instructions="${5:-existing above, guidance right >}"
	_transHeader() {
		# add a second line to the header with context-specific info in yellow
		# $1 string message to insert
		printf "%s\n[\033[38;5;11m%s\033[0m]" "${_instructions}" "${1}"
	}
	_showHelp() {
		printf '
 +-----------------------------------------------------------+
 |  mnemon proofing and grouping  |  hit "/" to close help   |
 +---------------------+-------------------------------------+

 main navigation
 - alt-P   page up         - alt-H   half page up
 - alt-p   page down       - alt-h   half page down

 preview navigation
 - ctrl-[up|down] arrow scrolls the preview window
 - ctrl-j previews the json output (txt is default)

 audio player
 - ctrl-p plays the audio in a new window (changes focus)
 - ctrl-o stops the playing audio

 group naming
 - ctrl-g   select the current working group name
 - ctrl-a   add selected key to group (shown in prompt)
 - ctrl-r   remove selected from group
 - +/=      view group / view all

for each transcript there are 3 proofing actions

  delete  alt-d  (removes the audio and transcript permanently)
  accept  alt-a  (moves it to the /proofs directory as is)
  edit    alt-e  (opens an editor and saves to proofs/ dir)

keep a clean work space'
	}
	# export functions to fzf (child)
	export -f _showHelp
	export -f _transHeader
	# set up the ripgrep prefix
	_rgPrefix="rg --color-always --smart-case "
	_searchPath="${_HOME}/transcripts/*/*.txt"
	while true; do
		_newName=$(fzf \
			--multi \
			--disabled \
			--no-mouse \
			--ansi \
			--tac \
			--print-query \
			--exact \
			--info="default" \
			--prompt="${_prompt}>" \
			--header="${_instructions}" \
			--bind="start:reload(${_input})" \
			--bind="?:change-preview(_showHelp)" \
			--bind="/:change-preview(${_preview} {q} {})" \
			--bind="alt-a:transform-header(_transHeader 'accepted')+execute(_approveProof {})+reload(${_input})" \
			--bind="alt-d:transform-header(_transHeader 'deleted')+execute(_deleteEntry {})+reload(${_input})" \
			--bind="alt-e:execute(_editProof {} </dev/tty >/dev/tty)" \
			--bind="alt-P:page-up" \
			--bind="alt-p:page-down" \
			--bind="alt-H:half-page-up" \
			--bind="alt-h:half-page-down" \
			--bind="ctrl-g:execute(_selectGroup)" \
			--bind="ctrl-g:+transform-prompt(_updatePrompt)" \
			--bind="ctrl-g:+reload(_listNames)" \
			--bind="ctrl-g:+transform-header(_transHeader '= to view all')" \
			--bind="+:transform-header(_transHeader '= to view all')" \
			--bind="+:+reload(_listNames)" \
			--bind="=:transform-header(_transHeader '+ to view group')" \
			--bind="=:+reload(${_input})" \
			--bind="ctrl-a:transform-header(_transHeader 'add {}')" \
			--bind="ctrl-a:+execute-silent(_addToGroup {})" \
			--bind="ctrl-a:+refresh-preview+down+transform-prompt(_updatePrompt)" \
			--bind="ctrl-r:transform-header(_transHeader 'rm {}')" \
			--bind="ctrl-r:+execute-silent(_rmFromGroup {})" \
			--bind="ctrl-r:+refresh-preview+up+transform-prompt(_updatePrompt)" \
			--bind="ctrl-p:transform-header(_transHeader 'ctrl-o: stop')+execute-silent(_play {}&)+refresh-preview" \
			--bind="ctrl-o:transform-header(_transHeader 'stopped')+execute-silent(_stopPlayer)+refresh-preview" \
			--bind="ctrl-j:transform-header(_transHeader 'ctrl-t txt')+change-preview(${_preview} {q} {} json)" \
			--bind="ctrl-t:transform-header(_transHeader 'ctrl-p to play')+change-preview(${_preview} {q} {})" \
			--bind="change:reload(_search {q})" \
			--bind="alt-j:transform(_transJohnson)" \
			--bind="esc:abort" \
			--bind="ctrl-c:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-q:transform-header(_transHeader 'ESC to abort')" \
			--bind="backward-eof:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-z:transform-header(_transHeader 'no ctrl-z')" \
			--preview="${_preview} {q} {} txt" \
			--preview-window=80%,wrap,~7,border-double
		);
		# we expect the first line to be the query
		# and the second line to be the selection (no multi yet)
		query=$(echo "${_newName}" | head -n1)
		selection=$(echo "${_newName}" | tail -n1)
		selection=$(echo "${_newName}" | tail +2)
		_debug "${FUNCNAME[0]} full return is '${_newName}'"
		_debug "${FUNCNAME[0]} query is '${query}'"
		_debug "${FUNCNAME[0]} selection is '${selection}'"
		# we return both, separated by colon
		_return="${query}:${selection}"
		break
		# TODO now with multi-select...we need to be smarter about the return
	done
}
# discarded fzf directives (aborted experiments)
		#	--bind="ctrl-s:transform-header(_transHeader 'search with rg')" \
		#	--bind="ctrl-s:+change-prompt(search:)" \
		#	--bind="ctrl-s:+reload(rg --color=always --line-number --smart-case --no-heading {q} $_searchPath)" \


_transJohnson() {
	#echo "change-prompt(johnson:)+transform-header(_transHeader 'john')"
	echo -n "change-prompt(johnson:)"
	echo -n "+transform-header(_transHeader 'john')"
	echo
}
export -f _transJohnson

_search() {
	# this function returns a list of keys whose transcripts match the pattern
	# used by rg ($1, ie the query typed into fzf during _browse), and this list
	# of keys is used by fzf to populate the main list...then the whole file (and
	# metadata) is displayed in the fzf preview window using the _previewEntry
	# function, which also highlights the query term as well as show tags (#TAG,
	# ie hash sign followed by alphanum and ended with space)
	#
	# arg1 = the search term
	#
	# first get the list of keys in the active view (either "all" or filtered by group)
	_keyList=$(_listNames)
	# check if $1 is empty, in which case, just return the full key list
	[[ -z "$1" ]] && { echo "${_keyList}"; return; }
	# next search the whole shebang for the match (smarter would be search with
	# filter)
	_fullList=$(rg --files-with-matches --smart-case $1 ${_HOME}/transcripts/*/*.txt)
	#
	_allKeys=$(echo "${_fullList}" | xargs -n 1 basename -s .txt)
	# finally compare the list of keys in the active view and the list that rg
	# returned, and only show those that match (yes this is inefficient)
	comm -12 <(echo "${_allKeys}" | sort) <(echo "${_keyList}" | sort)
}
export -f _search
##TODO huge bug here...if the proof exists...we need to swap the path from transcript to proof...going to 
# get really messy
# create new subdir called current
# symbolic link key.txt to either proof/key.txt or transcript.txt
# otherwise rethink the workflow idea...and let the transcript always be the
# only one

# TODO ctrl-a and ctrl-r should not act on group all

#TODO use query to search transcripts; colorize the search term
# ctrl-a and ctrl-r UNTESTED

_getCurrentGroup() {
	# read state for the current group name
	local _currentGroup
	if [ -e "${_HOME}/state/browser/group" ]; then
		_currentGroup=$(find "${_HOME}/state/browser/group" -maxdepth 1 -type d -empty -print -quit)
		_currentGroup=$(basename "${_currentGroup}")
	else
		_currentGroup="all"
	fi
	echo "${_currentGroup}"
}
export -f _getCurrentGroup

_setGroup() {
	# change state to new group name
	local _newGroup="$1"
	local _currentGroup
	# updates group name in state dir
	if [[ -e "${_HOME}/state/browser/group" ]]; then
		_currentGroup=$(_getCurrentGroup)
		rmdir "${_HOME}/state/browser/group/${_currentGroup}"
	fi
	mkdir -p "${_HOME}/state/browser/group/${_newGroup}"
}
export -f _setGroup

_updatePrompt() {
	# used by transform-prompt
	# append the signifier
	local _prompt
	name=$(_getCurrentGroup)
	if [[ ${name} = "all" ]]; then
		_prompt="all>"
	else
		count=$(ls "${_HOME}/names/${name}" | wc -l)
		_prompt="${name} [${count}] >"
	fi
	echo "${_prompt}"
}
export -f _updatePrompt

_listNames() {
	local name
	# list only the keys in the active group (unless empty, then list all)
	name=$(_getCurrentGroup)
	if [ ${name} = "all" ]; then
		# if name is 'all' then list full catalog
		ls ${_HOME}/catalog
	else
		if [ -z "$(find "${_HOME}/names/${name}" -mindepth 1 -maxdepth 1)" ]; then
			# empty group, list all
			ls ${_HOME}/catalog
		else
			ls ${_HOME}/names/${name}
		fi
	fi
}
export -f _listNames

_selectGroup() {
	# function called by _fzfBrowse to select existing or create a new group and
	# make it the active group (indicated in prompt as 'group>')
	# make the names dir if it does not already exist
	# no args
	[[ -d "${_HOME}/names" ]] || mkdir "${_HOME}/names"
	# use the _namePicker fzf wrapper function to choose a new group
	_namePicker _chosen "ls ${_HOME}/names" _validateName "names" "? for help"
	# if nothing was chosen, use the default
	[[ ${_chosen} = ":" ]] && { echo $(_getCurrentGroup); return; }
	# unwrap the fzf return string and figure out what was intended
	_selection=${_chosen#*:}
	_query=${_chosen%%:*}
	# if query is empty then we only have selection
	if [[ -z ${_query} ]]; then
	 	_nameSelected=${_selection}
	# if query and selection are the same, easy
	elif [[ ${_query} == ${_selection} ]]; then
	 	_nameSelected=${_query}
	# if query and selection are not the same...use query
	elif [[ ${_query} != ${_selection} ]]; then
		_nameSelected=${_query}
	fi
	# check if new or existing
	if _doesNameExist "${_nameSelected}"; then
		# existing
		true
	else
		# validate name with _isNameValid
		if _isNameValid "${_nameSelected}"; then
			mkdir "${_HOME}/names/${_nameSelected}"
		else
			# invalid name, just return with current
			echo $(_getCurrentGroup)
			return
		fi
	fi
	# finally update state with the new group name
	_setGroup "${_nameSelected}"
}
export -f _selectGroup

#TODO
# fold functions into _fzfBrowse
# functions
# create a group name
# switch to a group name
# add/remove selected to/from current group name
#
# manipulation of group names:	_nameGroup
# options
# select a group to be the active group
# select a group for single or multi selected mnemons to be added
# create a new group
#
# manipulation of mnemons:			_fzfBrowse
# operations on single (or multiple) mnemons
# delete/approve/edit (proof)
# add/remove selected (single or multi) to a group (new or existing)




# additionally, we can play the audio at faster (or slower) speeds with
# ffplay -af "atempo=1.5" 


#TODO challenge to unify the main viewer (_browse) with the group manipulation
# _fzfBrowse and _namePicker

_validateName() {
	# function used within fzf preview window to assist in the selection of a
	# name
	# fzf preview passes:
	# arg 1 is query
	# arg 2 is the current group name
	# arg 3 is the selected name
	local _maxLength=25
	local _minLength=1
	local _newSourceName
	local lengthStatus
	local avail
	local allowedChars="n/a"
	local lead="n/a"
	local last="n/a"
	local repeat="n/a"
	local acceptable="NO"
	_cStat() {
		# arg 1 = key word
		# print the key word in a set color
		[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
		[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
		[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
		echo -n "${1}"
		tput sgr0 
	}
	# export to fzf for --preview
	export -f _cStat
	# validate the name first
	if [[ ${#1} -lt ${_minLength} ]]; then
		lengthStatus="TOO SHORT"
		avail="n/a"
	elif [[ ${#1} -gt ${_maxLength} ]]; then
		lengthStatus="TOO LONG"
		avail="n/a"
	else
		lengthStatus="OK"
		# check if its new
		[[ -e "${_HOME}/names/${1}" ]] && { avail="NO"; acceptable="NO"; } || \
			{ avail="YES"; acceptable="YES"; }
	fi
	[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
	[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }
	# print the validation info into the fzf preview window
	echo "----VALID NAME?  $(_cStat ${acceptable}) --------------"
	[[ -z "${1}" ]] && echo "waiting for input..." || echo "name: '${1}'"
	printf "length [%.2d]: %31s\n" ${#1} "$(_cStat "${lengthStatus}")"
	printf "unique: %36s\n" "$(_cStat "${avail}")"
	printf "character set allowed: %21s\n" "$(_cStat "${allowedChars}")"
	printf "first ['%s'] allowed: %23s\n" "${1:0:1}" "$(_cStat "${lead}")"
	printf "last ['%s'] allowed: %24s\n" "${1:(-1)}" "$(_cStat "${last}")"
	printf "no non-alpha/num repeats: %18s\n" "$(_cStat "${repeat}")"
	echo
	echo "-----------RULES------------------"
	echo "the name must be unique"
	echo "max length is ${_maxLength}, min is ${_minLength}"
	echo "lower case and numbers only"
	echo "non alpha-numeric characters allowed:"
	echo " - dash (-)"
	echo " - underscore (_)"
	echo " - dot (.)"
	echo " ^ these cannot be first or last"
	echo " ^ cannot be repeated (eg --)"
	echo
	echo "-----------STATUS-----------------"
	if [ -z "${1}" ]; then
		# query is empty...show selected
		file_count=$(find "${_HOME}/names/${3}" -type f | wc -l)
		echo "found ${file_count} entries in the group '${3}'"
	else
		# query is not empty, show query
		if [ -e "${_HOME}/names/${1}" ]; then
			file_count=$(find "${_HOME}/names/${1}" -type f | wc -l)
			echo "found ${file_count} entries in the group '${1}'"
		else
			echo "group '${1}' does not exist"
		fi
	fi
}
# export above function to fzf for --preview
export -f _validateName

_showName() {
	# preview window displaying the list of keys in the name
	ls "${_HOME}/names/${1}"
}
export -f _showName

_showGroup() {
	# arg 1 = key
	# print the group the key is added to
	# otherwise return empty string
	result=$(find "${_HOME}/names" -type f -name "${1}" -print -quit)
	if [ -n "${result}" ]; then
		group="${result#"${_HOME}/names/"}"
		group="${group%/"${1}"}"
		echo "${group}"
	else
		echo ""
	fi
	# ugly but it works
}
export -f _showGroup

_addToGroup() {
	# add $1 key to current group
	# only allow each key to be added to one group
	local _key=$1
	local _group=$(_getCurrentGroup)
	# ignore actions on group 'all'
	[[ ${_group} = "all" ]] && return
	if [[ -z $(_showGroup ${1}) ]]; then
		# key is not in any group
		touch "${_HOME}/names/${_group}/${_key}"
	fi
}
export -f _addToGroup

_rmFromGroup() {
	# rm $1 key from current group
	local _key=$1
	local _group=$(_getCurrentGroup)
	rm "${_HOME}/names/${_group}/${_key}"
}
export -f _rmFromGroup

_doesNameExist() {
	[[ -d "${_HOME}/names/${1}" ]]
}
export -f _doesNameExist

_isNameValid() {
	local _maxLength=25
	local _minLength=1
	# arg 1 = source name
	if [[ "${1}" =~ ^([[:lower:]|[:upper:]|[:digit:]]|[-_.]){${_minLength},${_maxLength}}$ ]]; then
		[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] || return 1
		[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] || return 1
		[[ "${1}" =~ ([.]|[-]|[_]){2} ]] && return 1
		if _doesNameExist "${1}"; then
			_warn "'${1}' is not new"
			return 1
		else
			return 0
		fi
	else
		_warn "'${1}' is not allowed, try again"
		_info "rules: a-z A-Z 0-9 _ - . allowed; no spaces allowed"
		_info "rules: max length ${_maxLength} characters, min is ${_minLength}"
		return 1
	fi
}
export -f _isNameValid

# usage:
# _namePicker _newName   _getSourceList _validateNamePreview "prompt"    "special notes"
# (function)  (nameref)     (fzf feed)      (fzf preview)     fxf prompt  (fzf header)    
_namePicker () {
	# $1 = nameref for return value
	# $2 = input function (prints the list of existing whatever)
	# $3 = validation function for fzf preview window (in which $1=query $2=selection)
	# $4 = prompt string
	# $5 = optional special instructions
	local -n _return=$1
	local _input=$2
	local _preview=$3
	local _prompt=$4
	export _instructions="${5:-existing above, guidance right >}"
	_transHeader() {
		# add a second line to the header with context-specific info in yellow
		# $1 string message to insert
		printf "%s\n[\033[38;5;11m%s\033[0m]" "${_instructions}" "${1}"
	}
	_showHelp() {
		printf '
 +------------------------------------------------+
 |  mnemon naming      |  hit "/" to close help   |
 +---------------------+--------------------------+

 first, choose a new name to create a new group
 or choose and existing to modify a group
 the ACTIVE group will then be shown in the prompt:
 group>

 to add an item to the selected group
 ctrl-a

 to remove an item, use
 ctrl-r

 items can only be added to ONE group

 to delete a group, use ctrl-delete

have fun...these are empty pointer files'
	}
	export -f _showHelp
	export -f _transHeader
	while true; do
		_newName=$(fzf \
			--no-multi \
			--no-mouse \
			--ansi \
			--keep-right \
			--print-query \
			--exact \
			--info="hidden" \
			--prompt="${_prompt}>" \
			--header="${_instructions}" \
			--bind="start:reload(${_input})" \
			--bind="?:change-preview(_showHelp)" \
			--bind="/:change-preview(${_preview} ${_prompt} {})" \
			--bind="ctrl-a:transform-header(_transHeader 'add {}')+execute-silent(_addToGroup {} ${_prompt})+refresh-preview+up" \
			--bind="ctrl-r:transform-header(_transHeader 'rm {}')+execute-silent(_rmFromGroup {} ${_prompt})+refresh-preview+up" \
			--bind="ctrl-delete:transform-header(_transHeader 'deleted')+execute-silent(rmdir "${_HOME}/names/${_prompt}")+reload(${_input})" \
			--bind="ctrl-c:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-q:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-z:transform-header(_transHeader 'no ctrl-z')" \
			--bind="backward-eof:transform-header(_transHeader 'ESC to abort')" \
			--bind="tab:replace-query" \
			--bind="esc:abort" \
			--preview="${_preview} {q} ${_prompt} {}" \
			--preview-window=80%,wrap,~5,border-double
		);
		query=$(echo "${_newName}" | head -n1)
		selection=$(echo "${_newName}" | tail -n1)
		_debug "${FUNCNAME[0]} query is '${query}'"
		_debug "${FUNCNAME[0]} selection is '${selection}'"
		_return="${query}:${selection}"
		break
	done
}
export -f _namePicker

#TODO add a feature to _browse (_fzfBrowse)
# toggle fzf view between
# --tac and --notac
# turns out this is important

#TODO add to _import
# add to catalog the import time, the whisper transcription duration
#
# note, importing whatsapp m4a recordings does not yield the metadata that the
# voice memo app does (esp the create time)
# whatsapp encodes the creation time (i think) into the filename
# eg AUDIO-2022-10-12-06-58-40.m4a
# translates to "delivered" on oct 12, 2022 at 6:58:40 AM
# so to properly tag the voice recordings from whatsapp, i would need to
# identify the file name pattern and get a key based on that hueristic
# everything becomes more messy as you go

_getMediaFile() {
	# print the media file name
	# only looks in audio/ where media is placed after the transcript job completes
	# $1 = key
	if [ -f "${_HOME}/audio/${_key}.m4a" ]; then
		_audio="${_HOME}/audio/${_key}.m4a"
	elif [ -f "${_HOME}/audio/${_key}.mp3" ]; then
		_audio="${_HOME}/audio/${_key}.mp3"
	elif [ -f "${_HOME}/audio/${_key}.wav" ]; then
		_audio="${_HOME}/audio/${_key}.wav"
	else
		# notice that _debug doesn't get color here in the preview window
		# not exactly as designed
		_debug "${FUNCNAME[0]}: unknown media type for '${_key}'"
		[[ -d "${_HOME}/catalog/${_key}" ]] && _catalog=true
		[[ -d "${_HOME}/transcriptions/${_key}" ]] && _transcrpt=true
		# check for active transcription job with this key
		# add key to transcription pipeline (like import)
		# check media type and file size
		# measure how long transcription takes and record that
		# develop an "estimated time" algorithm which assigns a value to this based
		# on the historical (on this system...session...etc)
		return
	fi
	echo "$(basename ${_audio})"
}
export -f _getMediaFile

_deleteEntry() {
	local _key=$1
	local _file=$(_getMediaFile ${_key})
	rm "${_HOME}/audio/${_file}"
	rm -rf "${_HOME}/transcripts/${_key}"
	rm -rf "${_HOME}/catalog/${_key}"
}
export -f _deleteEntry

_previewEntry() {
	local _query=${1:-}
	local _type=${3:-txt}
	local _key=$2
	local _file
	local _duration
	local _isPlaying
	if [ -z "${2}" ]; then
		# no key...ie no match
		echo "no matching key"
		echo "query (as arg1) is '${_query}'"
		echo "group (from _getCurrentGroup) is $(_getCurrentGroup)"
		echo "arg1: ${1}"
		echo "arg2: ${2}"
		echo "arg3: ${3}"
		return
	else
		# get the audio file name
		_file=$(_getMediaFile ${_key})
	fi
	if [[ -z ${_file} ]]; then
		# there is no found file in audio/ but it may be in queue
	 	echo "nothing yet (probably transcribing now)"
		[[ -e "${_HOME}/queue/${_key}.wav" ]] && echo "wav file is in the queue"
		[[ -e "${_HOME}/queue/${_key}.m4a" ]] && echo "m4a file is in the queue"
		[[ -e "${_HOME}/catalog/${_key}" ]] && echo "key '${_key}' is in the calalog"
		echo "query (as arg1) is '${_query}'"
		echo "group (from _getCurrentGroup) is $(_getCurrentGroup)"
		echo "arg1: ${1}"
		echo "arg2: ${2}"
		echo "arg3: ${3}"
		return
	fi
	# get the duration from the media file with ffprobe
	_ffprobe_duration=$(ffprobe -v error -sexagesimal -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${_HOME}/audio/${_file}")
	# trim it down
	IFS=':' read -r hours minutes seconds _ <<< "${_ffprobe_duration}"
	# Remove leading zeros from hours and minutes if present
	hours=${hours#0}
	minutes=${minutes#0}
	# Print the formatted time
	if [[ -n "$hours" ]]; then
		_duration=$(echo "${hours}:${minutes}:${seconds%.*}")
	elif [[ "$minutes" == "0" ]]; then
		_duration=$(echo "${seconds%.*} seconds")
	else
		_duration=$(echo "${minutes}:${seconds%.*}")
	fi
	# check if this key is playing or not
	if [[ -d "${_HOME}/state/player/playing" ]]; then
		_playingNow=$(basename "${_HOME}/state/player/playing"/*)
		if [[ ${_playingNow} = "${_key}" ]]; then
			# colorize _isPlaying to magenta blinking "playing"
			_isPlaying=$'\x1b[38;5;5;5mplaying\x1b[0m'
		fi
	fi
	# get (and trim) the original name (if it exists)
	if [[ -e "${_HOME}/catalog/${_key}/original_name" ]]; then
		_originalName=$(cat "${_HOME}/catalog/${_key}/original_name")
		_originalName=${_originalName%.*}
	else
		_originalName="recorded on $HOSTNAME"
	fi
	# check if key is added to a group
	_group=$(_showGroup ${_key})
	printf '  +--%-31s----------+\n' "$(date -d @${_key})"
	printf '  |  media:    %-23s%-7s |\n' "${_file}" "${_isPlaying}"
	printf '  |  name:     %-30s |\n' "${_originalName}"
	printf '  |  group:    %-30s |\n' "${_group}"
	printf '  |  search:   %-30s |\n' "${_query}"
	printf '  |  duration: %-30s |\n' "${_duration}"
	if [ ${_type} = "txt" ]; then
		# reformat the txt into a single paragraph that fits the preview window
		# figure out the preview window width, which is 80% cols
		_termcols=$(tput cols)
		_previewcols=$((_termcols * 85 / 100))
		if [ $_previewcols -gt 70 ]; then
			_previewcols=70
		fi
		# highlight tags in green
		_tag='\x1b[1;32m' ; _rst='\x1b[0m'
		# highlight search term with yellow
		_search='\x1b[1;43m'
		# display the proofed version if it exists
		if [ -e "${_HOME}/proofs/${_key}.txt" ]; then
			_proofed=true
			local _path="${_HOME}/proofs/${_key}.txt"
		else
			_proofed=false
			local _path="${_HOME}/transcripts/${_key}/${_key}.txt"
		fi
		# grab the word count of the txt for display
		_wordCount=$(wc -w "${_path}" | cut -f1 -d' ')
		[[ ${_proofed} = "true" ]] && _contentState=$'\033[38;5;2m proofed \033[0m' || _contentState=$'\x1b[38;5;3munproofed\x1b[0m' 
		printf '  +---[ %-4s ]--[ %-10s ]----[ %-5s ]----+\n\n' "${3:-txt}" "${_contentState}" "${_wordCount}"
		#cat "${_path}" | tr '\n' ' ' | fold -s -w ${_previewcols} | sed -E "s/#([[:alnum:]-]+)/${_tag}#\1${_rst}/g"
		#TODO reformat more elegantly...preserve bare new lines
		if [[ -z "${_query}" ]]; then
			cat "${_path}" | fmt -w ${_previewcols} | sed -E "s/#([[:alnum:]-]+)/${_tag}#\1${_rst}/g"
		else
			# very dirty means of highlighting the query in the text (only when there
			# is a query)
			cat "${_path}" | fmt -w ${_previewcols} | sed -E "s/#([[:alnum:]-]+)/${_tag}#\1${_rst}/g" | sed -E "s/${_query}/${_search}&${_rst}/Ig"
		fi
		#
	elif [ ${_type} = "json" ]; then
		printf '  +------[ %-4s ]-----------------------------+\n\n' "${_type}"
		cat "${_HOME}/transcripts/${2}/${2}.json" | jq -C
	fi
}
export -f _previewEntry

_stopPlayer() {
	if [[ -e "${_HOME}/state/player/playing" ]]; then
		# get the monitor pid and stop it
		if [[ -e "${_HOME}/state/player/monitor" ]]; then
			_monitor_pid=$(cat "${_HOME}/state/player/monitor")
			kill "${_monitor_pid}"
			rm "${_HOME}/state/player/monitor"
		fi
		# already playing, get pid and kill player and coproc
		_playerPID=$(basename "${_HOME}/state/player/pid"/*)
		_coprocPID=$(basename "${_HOME}/state/player/coproc"/*)
		_debug "player pid is '${_playerPID}'"
		_debug "coproc pid is '${_coprocPID}'"
		kill ${_playerPID} 2>/dev/null
		kill ${_coprocPID} 2>/dev/null
		# reset player state
		rm -rf "${_HOME}/state/player/pid"
		rm -rf "${_HOME}/state/player/coproc"
		rm -rf "${_HOME}/state/player/playing"
	else
		_debug "nothing to stop according to state"
	fi
}
export -f _stopPlayer

_play() {
	_monitorPID() {
		# wait for the pid to be gone, then clear up the state
		local _pid=$1
		while kill -0 "${_pid}" 2>/dev/null; do
			# ffplayer pid is active
			sleep 1
		done
		# ffplayer pid no longer active, clear state
		rm -rf "${_HOME}/state/player/coproc"
		rm -rf "${_HOME}/state/player/pid"
		rm -rf "${_HOME}/state/player/playing"
		# clean up after itself
		rm "${_HOME}/state/player/monitor"
	}
	local _key=${1}
	_debug "play called for '${1}'"
	# make sure there is a state dir
	[[ ! -d "${_HOME}/state/player" ]] && mkdir "${_HOME}/state/player"
	# check if state indicates active player
	if [[ -e "${_HOME}/state/player/playing" ]]; then
		# get the monitor pid and stop it
		if [[ -e "${_HOME}/state/player/monitor" ]]; then
			_monitor_pid=$(cat "${_HOME}/state/player/monitor")
			kill "${_monitor_pid}"
			rm "${_HOME}/state/player/monitor"
		fi
		# already playing, get pid and kill player and coproc
		_playerPID=$(basename "${_HOME}/state/player/pid"/*)
		_coprocPID=$(basename "${_HOME}/state/player/coproc"/*)
		_debug "player pid is '${_playerPID}'"
		_debug "coproc pid is '${_coprocPID}'"
		kill ${_playerPID} 2>/dev/null
		kill ${_coprocPID} 2>/dev/null
		# reset player state
		rm -rf "${_HOME}/state/player/pid"
		rm -rf "${_HOME}/state/player/coproc"
		rm -rf "${_HOME}/state/player/playing"
	else
		_debug "no active player detected"
	fi
	# determine file type stupidly
	if [ -f "${_HOME}/audio/${_key}.m4a" ]; then
		_audio="${_HOME}/audio/${_key}.m4a"
	elif [ -f "${_HOME}/audio/${_key}.mp3" ]; then
		_audio="${_HOME}/audio/${_key}.mp3"
	elif [ -f "${_HOME}/audio/${_key}.wav" ]; then
		_audio="${_HOME}/audio/${_key}.wav"
	else
		_debug "${FUNCNAME[0]}: unknown media type for '${_key}'"
		return
	fi
	_debug "got the file type '${_audio}'"
	# run as coproc and set state
	#coproc FFPLAY { ffplay -autoexit "${_audio}" >/dev/null 2>&1 &
	coproc { ffplay -hide_banner -autoexit -loglevel quiet -x 500 -y 200 -top 0 -left 0 -showmode 1 \
		"${_audio}" >/dev/null 2>&1 &
		_coproc_playerPID=$!;
		mkdir -p "${_HOME}/state/player/playing/${_key}";
		mkdir -p "${_HOME}/state/player/pid";
		mkdir -p "${_HOME}/state/player/pid/${_coproc_playerPID}";
		# notes, running ffplay with nohup would allow it to play beyond 
	}
	mkdir -p "${_HOME}/state/player/coproc";
	mkdir -p "${_HOME}/state/player/coproc/${FFPLAY_PID}";
	# wait for ffplay pid to show up
	_debug "waiting on ffplay pid..."
	while [[ ! -n $(find "${_HOME}/state/player/pid" -maxdepth 1 -type d -empty -print -quit) ]]; do
		sleep 0.5
	done
	# get the pid
	_monitor_pid=$(basename "${_HOME}/state/player/pid"/*)
	_debug "got ffplay pid..."
	_debug "start ffplay monitor..."
	# run the pid monitor function in the background
	_monitorPID "${_monitor_pid}" &
	# register the monitor pid into the state dir
	echo $! > "${_HOME}/state/player/monitor"
	_debug "_play function done."
}
export -f _play

# ffplay manipulation
# right/left arrows seek forward/back 10 seconds (-seek_interval)
# atempo for slower/faster playback



#NOTE that ffplay, while it can be controlled with keystrokes when it is in the foreground,
# for example, p for pause, etc, it does not listen to stdin, so we cannot bg
# the process and connect stdin to a named pipe in order to send the control
# commands from another process.  so, the "stop" mechanism we use through the
# pid is the only way to accomplish the external control of ffplay while it
# plays in the background.  too bad there isn't a more fine-grained means of
# controlling ffplay behavior.  brute force is sometimes the only way.  the only
# way to add pause, speed-up, functions would be to track the play time
# externally and then restart at a specific point in the recording, ie restart
# with parameters to mimic the pause, speed-up etc features.  too much effort,
# although anything is possible.

_editProof() {
	# $1 is the _key in transcripts/ and catalog/
	local _path="${_HOME}/transcripts/${1}/${1}.txt"
	local _file_timestamp_before
	local _file_timestamp_after
	if [[ -e "${_HOME}/proofs/${1}.txt" ]]; then
		_warn "proof already exists"
		# no need to copy anything
	else
		# first time editing
		# cp the file to proofs (formatted nicely)
		cat "${_path}" | tr '\n' ' ' | fold -s -w 66 > "${_HOME}/proofs/${1}.txt"
	fi
	_file_timestamp_before=$(stat -c %Y "${_HOME}/proofs/${1}.txt")
	${_EDITOR} "${_HOME}/proofs/${1}.txt"
	_file_timestamp_after=$(stat -c %Y "${_HOME}/proofs/${1}.txt")
	if [ "${_file_timestamp_before}" -ne "${_file_timestamp_after}" ]; then
		# file changed
  	git -C "${_HOME}" add "${_HOME}/proofs/${1}.txt"
  	git -C "${_HOME}" commit -q -m "[edit] proof of ${1} saved"
  	#git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/proofs/${1}.txt"
  	#git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[edit] proof of ${1} saved"
	else
		_warn "proof ${1}.txt did not change"
	fi
}
export -f _editProof

_approveProof() {
	# $1 is the key
	local _path="${_HOME}/transcripts/${1}/${1}.txt"
	[[ -e "${_HOME}/proofs/${1}.txt" ]] && { _warn "proof already exists"; return; }
	# cp the file to proofs (formatted nicely)
	cat "${_path}" | tr '\n' ' ' | fold -s -w 66 > "${_HOME}/proofs/${1}.txt"
  git -C "${_HOME}" add "${_HOME}/proofs/${1}.txt"
  git -C "${_HOME}" commit -q -m "[approve] proof of ${1} saved"
  #git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/proofs/${1}.txt"
  #git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[approve] proof of ${1} saved"
}
export -f _approveProof

# run the dictate window
_shell() {
	local _micSTATE
	local _ffmpegSTATE
	local _ffmpegPID
	local _whisperSTATE
	local _whisperPID
	local _importSTATE
	local _importPID
	local _recordingState
	local _recording_pid=""
	local _transcriptionState="waiting"
	local _transcription_pid=""
	# colorize states: waiting, recording, paused
	_cStat() {
		# TODO remove tput usage here
		[[ "${1}" =~ ^(recording) ]] && { tput blink; tput setaf 7; tput setab 1; }
		[[ "${1}" =~ ^(waiting) ]] && tput setaf 3
		[[ "${1}" =~ ^(idle) ]] && tput setaf 3
		[[ "${1}" =~ ^(paused) ]] && { tput blink; tput setaf 7; tput setab 1; }
		[[ "${1}" =~ ^(unknown) ]] && { tput blink; tput setaf 2; }
		[[ "${1}" =~ ^(importing) ]] && { tput blink; tput setaf 3; }
		[[ "${1}" =~ ^(transcribing) ]] && { tput blink; tput setaf 4; }
		# iphone green attached; yellow detached
		[[ "${1}" =~ ^(attached) ]] && { tput setaf 2; }
		[[ "${1}" =~ ^(detached) ]] && { tput setaf 3; }
		# iphone mount state
		[[ "${1}" =~ ^(mounted) ]] && { tput setaf 2; }
		[[ "${1}" =~ ^(unmounted) ]] && { tput setaf 3; }
		echo -n "${1}"
		tput sgr0
	}
	_getKey() {
		# generate unique unix-time key and record (mkdir) in catalog
		local _key=$(date +%s)
		# don't give out the same key twice
		if [ -e "${_HOME}/catalog/${_key}" ]; then
			sleep 1
			# try again after a sleep (recursive)
			_getKey
		else
			# enter key into catalog
			mkdir "${_HOME}/catalog/${_key}"
			# print the key
			echo ${_key}
		fi
	}
	_catalogNew() {
		# add $1 to catalog unless it exists, otherwise return 1
		local _entry=$1
		[[ -d "${_HOME}/catalog/${_entry}" ]] && { _warn "catalog entry '${_entry}' exists"; return 1; }
		mkdir "${_HOME}/catalog/${_entry}"
	}
	_catalogAdd() {
		local _key=$1
		local _type=$2
		local _value=${3:-}
		[[ -d "${_HOME}/catalog/${_key}" ]] || { _warn "no such key '${_key}' in catalog"; return 1; }
		echo "${_value}" > "${_HOME}/catalog/${_key}/${_type}"
	}
	_record() {
		# do not record if recording is active
		[[ -e "${_HOME}/state/mic/recording" ]] && { _warn "recording in progress"; return; }
		# change mic state from idle to transitioning
		[[ -d "${_HOME}/state/mic/idle" ]] && rmdir "${_HOME}/state/mic/idle"
		mkdir -p "${_HOME}/state/mic/transitioning"
		# set output format to wav (cpu vs space)
		local oFmt="wav"
		# get key and define file name
		local _key=$(_getKey)
		local _file="${_key}.${oFmt}"
		# start ffmpeg recording
		ffmpeg -loglevel warning \
			-progress "${_HOME}/log/${_key}-ffmpeg.progress" \
			-hide_banner \
			-f alsa \
			-i default \
			-sample_rate 44100 \
			"${_HOME}/mic/${_file}" \
		 	>"${_HOME}/log/${_key}-ffmpeg.log" 2>&1 &
		# get the pid of the ffmpeg process (so we can signal it later)
		_ffmpegPID=$!
		# make sure this process is running
		if [ -d "/proc/${_ffmpegPID}" ]; then
			# system reports this is so, so change state
			mv "${_HOME}/state/mic/transitioning" "${_HOME}/state/mic/recording" 
			mkdir -p "${_HOME}/state/mic/pid/${_ffmpegPID}"
			mkdir -p "${_HOME}/state/mic/file/${_file}"
			mkdir -p "${_HOME}/state/mic/progressfile/${_key}-ffmpeg.progress"
			mkdir -p "${_HOME}/state/mic/logfile/${_key}-ffmpeg.log"
		else
			# some problem with ffmpeg occurred...change state to unknown
			mv "${_HOME}/state/mic/transitioning" "${_HOME}/state/mic/unknown"
			_debug "ffmpeg process for ${_key} did not start successfully; pid=${_ffmpegPID}"
		fi
	}
	_abort() {
		# check for recording in progress
		[[ -e "${_HOME}/state/mic/recording" ]] || { _warn "nothing to abort"; return; }
		# check for the pid dir in which the pid is stored as a dir
		[[ -e "${_HOME}/state/mic/pid" ]] || { _warn "no pid found; problem"; return; }
		# get the ffmpeg pid and filename from state dir
		ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
		# get the key
		key=${ffmpegFILE%%.*}
		# send INT signal to ffmpeg
		kill -SIGINT ${ffmpegPID}
		# remove pid info from state dir
		rm -rf "${_HOME}/state/mic/pid/"
		# change mic state
		mv "${_HOME}/state/mic/recording" "${_HOME}/state/mic/idle"
		# remove state file info
		rm -rf "${_HOME}/state/mic/file"
		# remove media file
		rm "${_HOME}/mic/${ffmpegFILE}"
		# remove logs
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/logfile"/*)"
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/progressfile"/*)"
		# remove log pointers
		rm -rf "${_HOME}/state/mic/progressfile"
		rm -rf "${_HOME}/state/mic/logfile"
		# update catalog
		rmdir "${_HOME}/catalog/${key}"
	}
	_save() {
		# check for recording in progress
		[[ -e "${_HOME}/state/mic/recording" ]] || { _warn "not recording"; return; }
		# check for the pid dir in which the pid is stored as a dir
		[[ -e "${_HOME}/state/mic/pid" ]] || { _warn "no pid found; problem"; return; }
		# get the ffmpeg pid and filename from state dir
		ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
		# get the key
		key=${ffmpegFILE%%.*}
		# send INT signal to ffmpeg
		kill -SIGINT ${ffmpegPID}
		# remove pid info from state dir
		rm -rf "${_HOME}/state/mic/pid/"
		# change mic state
		mv "${_HOME}/state/mic/recording" "${_HOME}/state/mic/idle"
		# remove state file info
		rm -rf "${_HOME}/state/mic/file"
		# move media file to queue
		mv "${_HOME}/mic/${ffmpegFILE}" "${_HOME}/queue/${ffmpegFILE}"
		# remove logs
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/logfile"/*)"
		rm "${_HOME}/log/$(basename "${_HOME}/state/mic/progressfile"/*)"
		# remove log pointers
		rm -rf "${_HOME}/state/mic/progressfile"
		rm -rf "${_HOME}/state/mic/logfile"
	}

	_name() {
		# a funky function...sadly
		# name transcript groups and manage keys in the named group
		[[ -d "${_HOME}/names" ]] || mkdir "${_HOME}/names"
		# use _namePicker to select name conforming to naming convention
		_namePicker _chosen "ls ${_HOME}/names" _validateName "names" "? for help"
		[[ ${_chosen} = ":" ]] && { _warn "nothing to do"; return; }
		_selection=${_chosen#*:}
		_query=${_chosen%%:*}
		_info "got query='${_query}' and selection='${_selection}' from '${_chosen}'"
		# if query is empty then we only have selection
		if [[ -z ${_query} ]]; then
		 	_nameSelected=${_selection}
			_debug "using selection because query is empty"
		# if query and selection are the same, easy
		elif [[ ${_query} == ${_selection} ]]; then
		 	_nameSelected=${_query}
			_debug "using query because selection is the same"
		# if query and selection are not the same...use query
		elif [[ ${_query} != ${_selection} ]]; then
			_nameSelected=${_query}
			_debug "using query because selection is not the same"
		fi
		# check if new or existing
		if _doesNameExist "${_nameSelected}"; then
			# existing
			true
		else
			# validate name with _isNameValid
			if _isNameValid "${_nameSelected}"; then
				mkdir "${_HOME}/names/${_nameSelected}"
			else
				_warn "invalid name '${_nameSelected}'"
				return
			fi
		fi
		# now use namepicker again to add/remove keys to/from the selected name
		# fzf uses ctrl-a and ctrl-r to add and remove the selected key
		#_namePicker _chosen "ls ${_HOME}/catalog" _showName "${_nameSelected}" "? for help"
		_namePicker _chosen "ls ${_HOME}/catalog" _previewEntry "${_nameSelected}" "? for help"
		#TODO commit
		#TODO this should be one function with one fzf call...all the operations can be
		# functionized, and use can stay in fzf...more work...but it works now
	}
	

	_push() {
		# use _namePicker to select name conforming to naming convention
		_namePicker _chosen "ls ${_HOME}/names" _validateName "select group" "? for help"
		[[ ${_chosen} = ":" ]] && { _warn "nothing to do"; return; }
		_selection=${_chosen#*:}
		_query=${_chosen%%:*}
		_info "got query='${_query}' and selection='${_selection}' from '${_chosen}'"
		# if query is empty then we only have selection
		if [[ -z ${_query} ]]; then
		 	_nameSelected=${_selection}
			_debug "using selection because query is empty"
		# if query and selection are the same, easy
		elif [[ ${_query} == ${_selection} ]]; then
		 	_nameSelected=${_query}
			_debug "using query because selection is the same"
		# if query and selection are not the same...use query
		elif [[ ${_query} != ${_selection} ]]; then
			_nameSelected=${_query}
			_debug "using query because selection is not the same"
		fi
		# check if new or existing
		if ! _doesNameExist "${_nameSelected}"; then
			_warn "cannot push invalid name '${_nameSelected}'"
			return 1
		fi
		# existing
		_debug "push '${_nameSelected}'"
		read -r -p "$(_ask 'push to what? ')" _pushDestination
		if [[ ${_pushDestination} = "epistle" ]]; then
			read -r -p "$(_ask 'epistle to whom? ')" _epistleRecipient
			for key in $(ls "${_HOME}/names/${_nameSelected}"); do
				if [[ -e "${_HOME}/proofs/${key}.txt" ]]; then
					printf "\n"
					cat "${_HOME}/proofs/${key}.txt" | tr '\n' ' ' | fold -s -w 66
					printf "\n"
				else
					printf "\n"
					cat "${_HOME}/transcripts/${key}/${key}.txt" | tr '\n' ' ' | fold -s -w 66
					printf "\n"
				fi
			#done | _notelosHOME="${_BASE}" "${_BASE}/.bin/epistle" -d -a epistle -p "${_BASE}" new -i -t "${_epistleRecipient}"
			# pipe it all into one document
			done | "${_BASE}/.bin/epistle" new -i -t "${_epistleRecipient}"
			# TODO
			# this is exposing a major problem
			# when we call epistle from mnemon, all the standard _notelosHOME etc are
			# mucked up...thus all the hoops to get epistle to run
			# however the above -hardcoded- solution actually works
			# this thing is a mess
			# this is fixed now...export only _HOME, which is never set based on
			# existing _HOME
		# for germ, we pipe each one as a new germ into designated source
		elif [[ ${_pushDestination} = "germ" ]]; then
			read -r -p "$(_ask 'which germ source? ')" _germSource
			for key in $(ls "${_HOME}/names/${_nameSelected}"); do
				if [[ -e "${_HOME}/proofs/${key}.txt" ]]; then
					cat "${_HOME}/proofs/${key}.txt" | tr '\n' ' ' | fold -s -w 66 | "${_BASE}/.bin/germ" add -i -s "${_germSource}"
				else
					cat "${_HOME}/transcripts/${key}/${key}.txt" | tr '\n' ' ' | fold -s -w 66 | "${_BASE}/.bin/germ" add -i -s "${_germSource}"
				fi
			done
		else
			echo "no solution for that yet"
		fi
		#TODO think through the push process more
	}

	_browse() {
		# the main browser
		# browse the transcripts
		# if there aren't any, don't bother
		[[ $(ls -A ${_HOME}/transcripts/) ]] || { _warn "no transcripts available"; return; }
		# create state
		[[ ! -d "${_HOME}/state/browser" ]] && mkdir "${_HOME}/state/browser"
		# clean up state first
		if [ -n "$(find "${_HOME}/state/browser/group" -mindepth 1 -maxdepth 1)" ]; then
			# not empty
			rmdir "${_HOME}/state/browser/group/$(_getCurrentGroup)"
		fi
		# set initial group to all
		mkdir -p "${_HOME}/state/browser/group/all"
		# call the fzf browser wrapper function
		_fzfBrowse _chosen "ls ${_HOME}/catalog" _previewEntry "all" "? for help"
		# the selected key is $_chosen
		if [[ -z "${_chosen}" ]]; then
			# nothing selected...carry on
			true
		else
			_debug "TODO offer menu on action on selection list that is: $_chosen"
		fi
		# clean up state
		[ -e $"{_HOME}/state/browser/group/*" ] && rmdir "${_HOME}/state/browser/group/*"
	}

	_findPhone() {
		# depends on libimobiledevice
		if ! hash idevice_id 2>/dev/null; then
			_error "${FUNCNAME}: idevice_id not found"
			_warn "install the libimobiledevice tools for iphone direct access"
			return 1
		fi
		if [ -d "${_HOME}/state/iphone/attached" ]; then
			_info "ATTACHED DEVICE"
		else
			_info "no attached device"
		fi
		_info "looking for iphone now"
		_ideviceList=$(idevice_id -l 2>&1)
		_ideviceListExitCode=$?
		if [ $_ideviceListExitCode != 0 ]; then
			# no phone visible, evidently
			_debug "'idevice_id -l' returned error: ${_ideviceList} ($_ideviceListExitCode)"
			_error "no iphone visible"
			[ -d "${_HOME}/state/iphone/attached" ] && rmdir "${_HOME}/state/iphone/attached"
			mkdir -p "${_HOME}/state/iphone/missing"
			return 1
		else
			_info "we may have a device to attach"
			_info "found device '$_ideviceList'"
			mkdir -p "${_HOME}/state/iphone/attached"
			mkdir -p "${_HOME}/state/iphone/id/${_ideviceList}"
			mkdir -p "${_HOME}/state/iphone/name/$(idevicename)"
			_deviceClass=$(ideviceinfo | grep ^DeviceClass | cut -f2 -d' ')
			mkdir -p "${_HOME}/state/iphone/class/${_deviceClass}"
			_deviceNumber=$(ideviceinfo | grep ^PhoneNumber)
			_deviceNumber="${_deviceNumber#*: }"
			mkdir -p "${_HOME}/state/iphone/number/${_deviceNumber}"
			mkdir -p "${_HOME}/state/iphone/mount"
			# now mount ONLY the "mnemon" folder in Firefox
			# a hacky little way of moving voice memos from the app to an accessible
			# dir
			ifuse --documents org.mozilla.ios.Firefox "${_HOME}/state/iphone/mount"
			if [ $? = 0 ]; then
				_info "mounted $(idevicename)"
				mkdir -p "${_HOME}/state/iphone/mounted"
			else
				_warn "ifuse mount of $(idevicename) failed"
			fi
			return 0
		fi
	}
	_unmountPhone() {
		fusermount -u "${_HOME}/state/iphone/mount"
		rmdir "${_HOME}/state/iphone/mounted"
	}	
	_import() {
		# use _finder (from library) to identify directory with media files
		_dir=$(_finder)
		[[ -z "${_dir}" ]] && { _warn "fzf returned empty string from _finder"; return; }
		# count files
		_count=0
		for file in "${_dir}"/*; do
			if [ -f "${file}" ]; then
				# ignore everything but mp3, m4a, wav
				[[ ( "${file}" == *.mp3 || "${file}" == *.m4a || "${file}" == *.wav ) ]] || break
				((_count++))
			fi
		done
		[[ ${_count} = 0 ]] && { _warn "no valid media files found"; return; }
		_goAhead=false
		until $_goAhead; do
			read -rsn1 -p $(_ask "import ${_count} files from '${_dir}'? [y/n/?] ") _yn
			echo
			[[ ${_yn} = "n" ]] && { _warn "import aborted"; return; }
			[[ ${_yn} = "?" ]] && { _info "list of proposed import follows"; \
				_filecount=0
				printf "o=============================================================o\n"
				printf "%-4s %-30s %-10s %-6s\n" "index" "name" "size" "duration"
				printf "o-------------------------------------------------------------o\n"
				for file in "${_dir}"/*; do
					if [ -d "${file}" ]; then
						#_warn "ignoring directory ${file}"
						printf " %-4s %-30s %-10s\n" '-' "${file}" "ignoring nested directory"
					elif [ -f "${file}" ]; then
						# ignore everything but mp3, m4a, wav
						[[ ( "${file}" == *.mp3 || "${file}" == *.m4a || "${file}" == *.wav ) ]] || break
						((_filecount++))
						_name=$(basename ${file})
						_size=$(du -h "${file}" | awk '{print $1}')
						_duration=$(ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${file}")
						if [[ ${_duration%%.*} -lt 60 ]]; then
						 	_duration="${_duration%%.*} seconds"
						else
							seconds=${_duration%%.*}
							minutes=$((seconds / 60))
							remaining_seconds=$((seconds % 60))
							_duration="${minutes}:${remaining_seconds}"
						fi
						printf " %-4s %-30s %-10s %-10s\n" ${_filecount} ${_name} ${_size} ${_duration}
					else
						_warn "'${file}' is neither file nor directory"
					fi
				done
				printf "o=============================================================o\n"
			}
			[[ ${_yn} = "y" ]] && _goAhead=true
		done
		for _file in ${_dir}/*; do
			# only process files
			[[ -f "${_file}" ]] || continue
			# ignore files that are not known media files (mp3,m4a,wav)
			[[ ( "${_file}" == *.mp3 || "${_file}" == *.m4a || "${_file}" == *.wav ) ]] || _warn "$_file not allowed"
			# get the unixtime from the "creation_time" 
			c_time=$(ffprobe -v error -show_entries stream_tags=creation_time -of default=noprint_wrappers=1:nokey=1 "${_file}")
			c_unix=$(date -d "${c_time}" +%s)
			suffix=${_file##*.}
			# get a key and enter into catalog
			_getKeyImport() {
				# custom _getkey function exclusive to _import
				# pass desired key as $1
				# prints that key (if no conflict)
				# otherwise prints the next free key in time
				local _key=$1
				# don't give out the same key twice
				if [ -e "${_HOME}/catalog/${_key}" ]; then
					# increment and try again
					((_key++))
					# try again after a sleep (recursive)
					_getKeyImport ${_key}
				else
					# print the key
					echo ${_key}
				fi
			}
			_key=$(_getKeyImport ${c_unix})
			# update the catalog with metadata and add the file to the queue
			if [[ ${_key} = ${c_unix} ]]; then
			 	_debug "got new matching key '${_key}' from '${c_unix}'"
				_debug "adding new key '${_key}' to catalog"
				_catalogNew "${_key}"
				_catalogAdd "${_key}" "import"
				_catalogAdd "${_key}" "original_name" "$(basename ${_file})" || { _error "great failure"; return 1; }
				_catalogAdd "${_key}" "audio_file" "${_key}.${suffix}"
				# extract metadata from each media file into catalog
				ffprobe -v error -print_format flat -show_format -show_streams "${_file}" > "${_HOME}/catalog/${_key}/file_metadata.txt"
				cp "${_file}" "${_HOME}/queue/${_key}.${suffix}"
			else
				_warn "'${c_unix}' conflict, got incremented '${_key}'"
				_import_filename=$(basename "${_file}")
				_catalog_filename=$(cat "${_HOME}/catalog/${c_unix}/original_name" || echo "")
				if [[ ${_import_filename} = ${_catalog_filename} ]]; then
					_warn "duplicate file detected...ignoring"
				else
					# the above isn't very robust, but import the file anyway
					_catalogNew "${_key}"
					_catalogAdd "${_key}" "import"
					_catalogAdd "${_key}" "original_name" "$(basename ${_file})" || { _error "great failure"; return 1; }
					_catalogAdd "${_key}" "audio_file" "${_key}.${suffix}"
					# extract metadata from each media file into catalog
					ffprobe -v error -print_format flat -show_format -show_streams "${_file}" > "${_HOME}/catalog/${_key}/file_metadata.txt"
					cp "${_file}" "${_HOME}/queue/${_key}.${suffix}"
				fi
			fi
		done
	}

	_showFileSize() {
			ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
			if [[ -e "${_HOME}/mic/${ffmpegFILE}" ]]; then
				echo "$(ls -l "${_HOME}/mic/${ffmpegFILE}" | awk '{print $5}')"
			else
				echo "n/a"
			fi
	}
	_showFileName() {
			ffmpegFILE=$(basename "${_HOME}/state/mic/file"/*)
			if [[ -e "${_HOME}/mic/${ffmpegFILE}" ]]; then
				echo "${ffmpegFILE}"
			else
				echo "none"
			fi
	}
	_checkQueue() {
		[[ -e "${_HOME}/state/whisper/transcribing" ]] && return
		# if file exists in queue, process it
		if [ -n "$(ls ${_HOME}/queue 2>/dev/null)" ]; then
			mkdir -p "${_HOME}/state/whisper/transcribing"
			# get the oldest file
			_file=$(ls "${_HOME}/queue/" | head -1)
			# set its full path
			_path="${_HOME}/queue/${_file}"
			# get the key
			_key=${_file%%.*}
			#
			# TODO
			# update the state dir with data
			# start time
			# file type
			# source
			# file size
			#
			# run whisper as a coprocess
			# suppress_tokens expects a comma separated list of token ids
			# eg 0=!  ,=11  .=13  ?=30
			# the default is -1, setting this to '' or 0 seems to work best with
			# punctuation and catching the "hash Oh See dash put" to render #OC-put
			coproc WHISPER { whisper "${_path}" \
				--verbose False \
				--task transcribe \
				--language en \
				--model medium.en \
				--suppress_tokens '' \
				--output_dir "${_HOME}/transcripts/${_key}/." \
				--output_format all \
				--word_timestamps True \
				--max_line_width 60 \
				> "${_HOME}/log/whisper.log" 2>&1 || mkdir "${_HOME}/state/whisper/failed";
				mv "${_path}" "${_HOME}/audio/${_file}";
				rmdir "${_HOME}/state/whisper/transcribing";
		 		rm -rf "${_HOME}/state/whisper/coproc";	
				# add the resulting transcripts to git
  			git -C "${_HOME}" add "${_HOME}/transcripts/${_key}/*"
  			git -C "${_HOME}" commit -q -m "[whisper] transcripts for ${_key} saved"
				# make recursive to empty the queue (serially)
				_checkQueue
			}
			# note the coprocess pid in state
			mkdir -p "${_HOME}/state/whisper/coproc/${WHISPER_PID}"
		else
			#_debug "no files in queue"
			true
		fi
	}
	# TODO when whisper does not have enough memory it just dies
	# prints to stderr (or out?) Killed
	# exits with 137
	# must catch this and right the boat...currently its a hot mess of failure
	# this is bash or the kernel sending SIGINT (kill -9) to the whisper process
	# due to OOM (out of memory) ie linux overcommit coming due
	# to catch this we might need trap...
	_getState() {
		if [[ -e "${_HOME}/state/mic/recording" ]]; then
			_recordingState="recording"
			_recording_ffmpegPID=$(basename "${_HOME}/state/mic/pid"/*)
		elif [[ -e "${_HOME}/state/mic/idle" ]]; then
			_recordingState="idle"
			_recording_ffmpegPID=''
		else
			_recordingState="idle"
			_recording_ffmpegPID=''
		fi
		if [[ -e "${_HOME}/state/whisper/transcribing" ]]; then
			_transcribingState="transcribing"
			_transcribing_coprocPID=$(basename "${_HOME}/state/whisper/coproc"/*)
		else
			_transcribingState="idle"
			_transcribing_coprocPID=''
		fi
		if [[ -e "${_HOME}/state/iphone/attached" ]]; then
			_phoneState="attached"
		else
			_phoneState="detached"
		fi
		if [[ -e "${_HOME}/state/iphone/mounted" ]]; then
			_mountState="mounted"
		else
			_mountState="unmounted"
		fi
	}
	_printScreen() {
		quenum=$(ls "${_HOME}/queue" | wc -l)
		transnum=$(ls "${_HOME}/transcripts" | wc -l)
		proofnum=$(ls "${_HOME}/proofs" | wc -l)
		audnum=$(ls "${_HOME}/audio" | wc -l)
		micstate=$(_cStat ${_recordingState})
		whispstate=$(_cStat ${_transcribingState})
		mountstate=$(_cStat ${_mountState})
		iphonestate=$(_cStat ${_phoneState})
		# iphone may have been unplugged...check if so
		if [ -z "${iphonestate}" ]; then
			iphonename=null
		else
			if [ -d "${_HOME}/state/iphone/name" ]; then
				iphonename=$(basename $(find "${_HOME}/state/iphone/name" -mindepth 1 -maxdepth 1 -type d))
			else
				iphonename=nono
			fi
		fi
		ffmpegpid=${_recording_ffmpegPID:-none}
		transpid=${_transcribing_coprocPID:-none}
		whisppid=${_transcribing_whisperPID:-none}
		space=$(du -sh "${_HOME}" | awk '{print $1}')
		if [[ ! ${_DEBUG} = "true" ]]; then
			clear
		fi
		printf "=====\033[1mDICTATE MACHINE\033[0m----------(%s)-------pid:%10d==============o\n" $_NAME $$
		printf "\n"
		printf " %-4s %-20s %18s %-23s %16s %s\n" 'mic:' $micstate 'whisper:' $whispstate 'iphone:' $iphonestate
		printf "  %-10s %-12s %7s %-18s %s\n" "ffmpeg pid:" $ffmpegpid "coproc pid:" $transpid $iphonename
		printf "  %-6s %-48s %s\n" "media:" $(_showFileName) $mountstate
		printf "  size: %s\n" $(_showFileSize) 
		printf "\no==============================================================================o\n"
		printf "  %s(%s)     queue: %s     transcripts: %s    proofed: %s\n" $audnum $space $quenum $transnum $proofnum
		printf "o------------------------------------------------------------------------------o\n"  
		printf '
 r) record                          [begins recording from mic]
 a) abort recording                 [aborts and deletes current recording]
 s) stop and transcribe             [saves current recording and transcribes]
 b) browse                          [browse transcripts for proofing]
 n) name proofs                     [create names and assign proofs into]
 p) push                            [push group to germ or epistle]
 i) import                          [import audio files from local filesystem]
 m) mount  u) unmount               [mount and unmount attached iphone]
 t) tig                             [inspect repo with tig]
 q) quit

  token words recognized: quote, unquote, hash, underscore, dash
	metadata commands, eg, "hash g dash 1"     =>  #g-1
	                   eg, "hash oc dash put"  =>  #oc-put

'
	}
	# main loop for menu screen
	_getState
	_printScreen
	while read -r -s -n1 -p"$(_ask 'enter selection') " _selection; do
		echo
		case ${_selection} in
			t)
				_inspect || :
				;;
			n)
				_name || :
				;;
			m)
				_findPhone || :
				;;
			u)
				_unmountPhone || :
				;;
			r)
				# disable screen locking during recording and keep the screen from going
				# blank from inactivity
				_idledelay=$(gsettings get org.gnome.desktop.session idle-delay | cut -d' ' -f2)
				_lockenabled=$(gsettings get org.gnome.desktop.screensaver lock-enabled)
				gsettings set org.gnome.desktop.screensaver lock-enabled false
				gsettings set org.gnome.desktop.session idle-delay 0
				_record || :
				;;
			a)
				# restore desktop locking and screen blanking
				gsettings set org.gnome.desktop.screensaver lock-enabled ${_lockenabled:-false}
				gsettings set org.gnome.desktop.session idle-delay ${_idledelay:-600}
				_abort || :
				;;
			s)
				# restore desktop locking and screen blanking
				gsettings set org.gnome.desktop.screensaver lock-enabled ${_lockenabled:-false}
				gsettings set org.gnome.desktop.session idle-delay ${_idledelay:-600}
				_save || :
				;;
			b)
				_browse || :
				;;
			p)
				_push || :
				;;
			i)
				_import || :
				;;
			q)
				if [[ ${_recordingState} = "recording" ]]; then
					_warn "recording live now"
					read -rsn1 -p "$(_ask 'really quit now? [yn] ')" _yn
					echo
					if [[ ${_yn} = "y" ]]; then
						# restore desktop locking and screen blanking
						gsettings set org.gnome.desktop.screensaver lock-enabled ${_lockenabled:-false}
						gsettings set org.gnome.desktop.session idle-delay ${_idledelay:-600}
					 	return
						# note this does not terminate the record session...it remains live
						# and will "reconnect" by restarting mnemon
					else
						continue
					fi
				else
					return 0
				fi
				;;
		esac
		_getState
		_checkQueue
		_printScreen
	done
}

main() {
	# read all the positional parameters
  _getOpts "${@}"
  # setup the environment after processing all command line parameters
  _setEnv
  # validate the environment (external tools required)
  _checkExternalTools || { _error "cannot run until these problems are resolved"; return 1; }
  # check for the working directory
  _checkHome || { _error "cannot run without a working environment"; return 1;  }
  # enter custom shell if no arguments
  [ -z "${_subCommand:-}" ] && _shell
  # otherwise, pass the commands to the called "command"
  [[ -n "${_subCommand:-}" ]] && _debug "now calling the eval to run '${_subCommand:-}'"
  [[ -n "${_subCommand:-}" ]] && eval _"${_subCommand}" || :
}
main "${@}"
