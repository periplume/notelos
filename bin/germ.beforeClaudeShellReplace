#!/usr/bin/env bash
# file: germ
# source: https://github.com/periplume/notelos.git
# author: jason@bloom.us
# description: note taking tool

# STRICT SHELL
set -o errexit 
set -o nounset
set -o pipefail
IFS=$'\n\t'

###########################
# PREREQUISITES
###########################
 
# required external commands
_requiredCommands=(git tig fzf)

###########################
# LIBRARY
###########################

# source library commands and set up log/console
# use the library file from the same directory if possible
[[ -e "$(dirname $0)/notelos-lib.sh" ]] \
	&& source "$(dirname $0)/notelos-lib.sh" \
	|| source notelos-lib.sh

###########################
# LOGGING AND CONSOLE
###########################

# default initial debugging and logging settings
# note: command line parameters can modify these
# script debug toggle (set to true to enable default global debugging)
_DEBUG=false
# silent mode for scripting (supresses all output)
_SILENT=false
# logging facility
_LOG=false

# instantiate the log/mesg functions with defaults (these will be re-initialized
# after reading positional parameters)
_fLOG

####################################
# HELPER FUNCTIONS
####################################

_printUsage () {
  cat << EOF
usage: germ [OPTIONS] <command> [OPTIONS]

options:
 -h      print this usage info
 -l      log commands and debug info to log file
 -d      print debug info to stdout and/or log
 -s      suppress all stdout/stderr
 -v      print version number and exit
 -x      force standalone mode

alternate env settings:
 -a <name>  set the germ dir name to <name>
 -p <path>  set alternate base path

commands:
EOF
_printCommands
}

_printCommands() {
	cat <<  EOF
 add                 add a new germ entry to the database
 edit                edit an existing germ entry
 create              create a new germ git database
 inspect             run tig on the germ git bare repo
 search              interactive search
 browse              read through the current source entities
 source              add and manipulate source
 pdf                 produce a pdf from notebook
EOF
}

_printInfo () {
  cat << EOF
germ takes simple notes and adds them to a git repo
EOF
}

####################################
# PARAMETER PROCESSING
####################################

_getOpts () {
	# preserve the initial positional parameters
	export _fullCommand="${@}"
	_debug "full command is '${_fullCommand}'"
	local OPTIND
	# do not allow names for notelos or self to be names of germ commands
	_isCommand() {
		local _allowed=true
		local _commandList
		_commandList=$(_printCommands | cut -f2 -d' ')
		for _command in ${_commandList}; do
      [[ "${_command}" = "${1}" ]] && _allowed=false 
    done
    [[ ${_allowed} = "true" ]] || return 1
  }
	while getopts ":hsdlxva:p:" flag ; do
		case ${flag} in 
			h)
				_printInfo; _printUsage; exit 0
				;;
			a)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is    NOT a flag ($OPTARG)"; exit 1; }
				_isCommand "${OPTARG}" || { _error "'${OPTARG}' is not allowed (it is a command)"; exit 1; }
				_NAME=${OPTARG}
				_warn "using alt name '${_NAME}'"
				;;
			p)
				[[ "${OPTARG}" == -* ]] && { _error "option '-${flag}' requires an argument that is    NOT a flag ($OPTARG)"; exit 1; }
				_BASE=${OPTARG}
				_warn "using alt path '${_BASE}'"
				;;
 	    s)
				_debug "${FUNCNAME[0]}: enabling silent mode with flag -$flag"
 	      _SILENT=true
				;;
			d)
				_debug "${FUNCNAME[0]}: enabled debug mode with flag -$flag"
				_DEBUG=true
				;;
			l)
				_debug "${FUNCNAME[0]}: enabled log mode with flag -$flag"
				_LOG=true
				;;
			x)
        _debug "${FUNCNAME[0]}: running in standalone mode with -$flag"
        _MODE=standalone
        ;;
			v)
				_info "${green}verion${reset}: beta"; exit 0
				;;
			?)
				_error "invalid global option: -${OPTARG}"; exit 1
				;;
		esac
	done
	shift $((OPTIND - 1)); OPTIND=1
	# preserve the full subcommand with its parameters
	export _subCommandParams="${@}"
	# look for the subcommand and check for its options
	while ((${#})); do
		case ${1} in
			help)
				_printInfo; _printUsage; exit 0
				;;
			add)
				_subCommand=$1; shift
				while getopts ":ibs:" flag; do
					case ${flag} in
						i)
							# inline add (no editor invoked)
							_debug "enabled inline mode"
							_inline=true
							_inlineString="${_subCommandParams#*add -i*}"
							_debug "inline string: '${_inlineString}'"
							;;
						b)
							# bulk add disables commit...this is a hack to allow bulk input
							# without commiting each one...behavior is not correct imo
							_debug "bulk add operation"
							_bulk=true
							;;
						s)
							# specify the source notebook for the add
							_debug "source specified '${OPTARG}'"
							_addTO="${OPTARG}"
							;;
						?)
				 			_error "${FUNCNAME}: unknown flag -${OPTARG}"; exit 1
							;;
					esac
				done
				return
				;;
			edit)
				_subCommand=$1; shift
				return
				;;
			create)
				_subCommand=$1; shift
				return
				;;
			inspect)
				_subCommand=$1; shift
				return
				;;
			status)
				_subCommand=$1
				return
				;;
			source)
				_subCommand=$1
				return
				;;
			pdf)
				_subCommand=$1
				return
				;;
			*)
				_error "${FUNCNAME}: '${1}' is not a subcommand"
				return 1
				;;
		esac
		shift
	done
}

_setEnv() {
  # get the name and absolute path of the calling script
  _selfNAME=$(basename "${BASH_SOURCE[0]}")
  _selfABSOLUTE=$(readlink -f "${BASH_SOURCE[0]}")
  _selfBASE=$(dirname "${_selfABSOLUTE}")
  _selfCALL=${0}
  _selfPWD=$(pwd)
	# determine mode (notelos-integrated or standalone)
	[[ -n "${_notelosHOME+x}" && ${_MODE:-} != "standalone" ]] && _MODE=integrated || _MODE=standalone
	# note: the -x switch overrides the global _notelosHOME var 
	# set up the working environment
	if [[ ${_MODE} = "integrated" ]]; then
		# set up integrated mode
		_MASTER="${_notelosNAME}"
		_BASE="${_notelosHOME}"
		_NAME="${_NAME:-germ}"
		_HOME="${_BASE}/${_NAME}"
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/.log/${_NAME}.log"
		# inherit these (from notelos)
		_DEBUG=${_notelosDEBUG}
		_LOG=${_notelosLOG}
		_SILENT=${_notelosSILENT}
		_USERNAME=${_notelosUSERNAME}
		_USERFULLNAME=${_notelosUSERFULLNAME}
		_USEREMAIL=${_notelosUSEREMAIL}
		_EDITOR=_notelosEdit
	else
		# set up standalone mode
		_MASTER=self
		_BASE="${_BASE:-$HOME}"
		_NAME="${_NAME:-germ}"
		_HOME=${_BASE}/${_NAME}
		_GITDIR="${_HOME}/.git"
		_LOGFILE="${_BASE}/${_NAME}.log"
		# inherit these
		_DEBUG=${_DEBUG:-false}
		_LOG=${_LOG:-false}
		_SILENT=${_SILENT:-false}
		_USERNAME=$(whoami)
		_USERFULLNAME="unknown"
		_USEREMAIL="unknown"
		_EDITOR=${EDITOR:-nano}
	fi
  [[ -f "${_LOGFILE:-}" ]] && _LOGGING=true || _LOGGING=false
	_debug "$(declare -p _MODE)"
	_debug "$(declare -p _MASTER)"
	_debug "$(declare -p _NAME)"
	_debug "$(declare -p _BASE)"
	_debug "$(declare -p _HOME)"
	_debug "$(declare -p _USERNAME)"
	_debug "$(declare -p _USERFULLNAME)"
	_debug "$(declare -p _USEREMAIL)"
	_debug "$(declare -p _GITDIR)"
	_debug "$(declare -p _LOGFILE)"
	_debug "$(declare -p _DEBUG)"
	_debug "$(declare -p _SILENT)"
	_debug "$(declare -p _LOG)"
	_debug "$(declare -p _LOGGING)"
	export _HOME
}

_checkExternalTools() {
	# check for required tools, report accordingly
	local _sufficient=true
	for _required in "${_requiredCommands[@]}"; do
		if ! hash "${_required}" 2>/dev/null; then
			_warn "${FUNCNAME}: ${_required} not found"
			_sufficient=false
		else
			: #_debug "${FUNCNAME}: ${_required} found"
		fi
	done
	[ ${_sufficient} = true ] && return 0 || return 1
}

_checkHome() {
  # check if the home dir exists
  # check if it is a germ-created git
  # return 1 if missing or not git
  # mind condition: if subcommand is create
	[[ ! -d "${_BASE}" && ${_MODE} = "notelos" ]] && { _error "notelos base not found"; exit 1; }
	[[ -d "${_BASE}" ]] || { _error "base '${_BASE}' does not exist"; exit 1; }
	local _base="${_BASE}"
	local _dirName="${_NAME}"
	local _dirPath="${_HOME}"
	local _git_desc="${_dirPath}/.git/description"
  if [ -d "${_dirPath}" ]; then
    if [ -f "${_git_desc}" ]; then
      # the git description file exists, lets check it for our marker
      read -r _desc < "${_git_desc}"
			if [[ ${_desc} == ${_MASTER}:${_NAME}:${_USERNAME}* ]]; then
        # if repo does exist, return 0
        _debug "${_git_desc} = ${_desc}"
				return
      else
        # if repo does not exist, warn and exit
        _error "${_dirPath} exists and is NOT a studio-created repo"
        return 1
      fi
    else
      _error "${_dirPath} exists and is NOT a git repo"
      _error "move existing ${_dirPath} before proceeding"
      return 1
    fi
  else
    # dir does not exist
    _warn "'${_dirPath}' does not exist"
    read -rsn1 -p "$(_ask 'create repo now? [y/n]')" _yn
    echo
    [[ ${_yn} != "y" ]] && { _warn "cannot run without a repo"; return 1;  }
    _create || { _error "could not create ${_dirName} repo"; return 1; }
    return
  fi
}

############################
# CREATE
############################

_create() {
	# do not overwrite an existing anything
	[[ -d "${_HOME}" ]] && { _error "'${_HOME}' exists"; return 1; }
	[ ! -d "${_HOME}" ] && mkdir "${_HOME}"
	git init -q -b main "${_HOME}"
  git -C "${_HOME}" config user.name "${_USERNAME}"
  git -C "${_HOME}" config user.email "${_USEREMAIL}"
	# make the default notebook (aka "source")
	mkdir "${_HOME}/default"
	echo "default source (notebook, project, etc)" > "${_HOME}/default/.description"
	echo "default" > "${_HOME}/.current"
	echo ".current" > "${_HOME}/.gitignore"
	echo ".${_NAME}_history" >> "${_HOME}/.gitignore"
  git -C "${_HOME}" --git-dir="${_GITDIR}" add .gitignore
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/default/.description" 
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[genesis] ${_NAME} created by ${_USERNAME}"
	# put the installed signature in git description file
  _gitInitial=$(git -C "${_HOME}" rev-parse --short --verify main)
  _time=$(date +%s)
  printf "${_MASTER}:${_NAME}:${_USERNAME}:${_time}:${_gitInitial}\n" >      "${_HOME}/.git/description"
}

##################################
# INSPECT
##################################

_inspect() {
	tig -C${_GITDIR}
}

##################################
# ADD
##################################

_add() {
	# add a new entry
	local _currentSource=$(_getSource)
	local _commitMsg
	# determine if the source notebook has been declared in positional parameters
	if [[ -z ${_addTO:-} ]]; then
		# it was not specified, therefore use "current"
		_useSource=${_currentSource}
	else
		_useSource=${_addTO}
	fi
	# determine the destination for the file to write
	local _dir="${_HOME}/${_useSource}"
	local _key=$(_getNewKey)
	local _file="${_dir}/${_key}"
	# check for piped standard input
	if [ ${_inline:-null} = "true" ]; then
		# note that pipe input takes priority over message appended to 'add -i'
		if [ -p /dev/stdin ]; then
			cat < /dev/stdin > "${_file}"
		else
			[ -z "${_inlineString}" ] && { _error "${FUNCNAME}: 'add -i' cannot contain an empty message"; return 1; }
			echo "$(_trimString ${_inlineString})" > "${_file}"
		fi
	else
		# catch pipe in without -i
		[ -p /dev/stdin ] && { _error "use 'add -i' for pipe input"; return 1; }
		# maybe we don't need the -i?
		# now just use the editor as usual
		${_EDITOR} "${_file}"
	fi
	[[ -e "${_file}" ]] || return
	_commitMsg=$(_buildCommitMsg "$(cat "${_file}")")
	_doCommit "${_useSource}/${_key}" "[add to ${_useSource}] ${_commitMsg}"
}

_trimString() {
	# Usage: trim_string "   example   string    "
	# source https://github.com/dylanaraps/pure-bash-bible
	: "${1#"${1%%[![:space:]]*}"}"
	: "${_%"${_##*[![:space:]]}"}"
	printf '%s\n' "$_"
}

_getNewKey() {
	# print the key (unixseconds.nano)
	echo "$(date +%s.%N)"
}

_buildCommitMsg() {
	# arg 1 = string [required]
	# read string (the whole blob) line by line
	# construct git commit message string (combining lines until max exceeded)
	# truncate if necessary and append with "..."
	# total character count <=75
	# print string or return 1
	local _maxLength=60
	local _commitMsgString=
	local _lines
	# empty string not allowed
	[ -z "${1:-}" ] && return 1
	# count lines
	l="${1//[!$'\n']/}"
	_lines=$((${#l} + 1))
	# process multi-line entries
	while read -r line; do
		# single line entry, set and break
		if [ ${_lines} = 1 ]; then
			_commitMsgString="${1}"
			break
		fi
		words=($line)
		# one word lines
		if [[ ${#words[@]} = 1 ]]; then
			# if the commit message string is empty
			if [[ -z "${_commitMsgString}" ]]; then
				_commitMsgString+="${line%% *}:"
			elif [[ ${_commitMsgString:(-1)} = ":" ]]; then
				_commitMsgString+=" ${line%% *}"
			else
				_commitMsgString+="; ${line%% *}"
			fi
		# empty lines
		elif [[ ${#words[@]} = 0 ]]; then
			true
		# multi-word lines
		else
			if [[ ${_commitMsgString:(-1)} = ":" ]]; then
				# first line after first-word+colon
				_commitMsgString+=" ${line}"
			elif [[ -z "${_commitMsgString}" ]]; then
				# first slot in empty commit message string
				_commitMsgString+="${line}:"
			else
				# insert semi-colon to designate new line
				_commitMsgString+="; ${line}"
			fi	
		fi
		# once we have exceeded the maxLength...stop processing
		if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
			break
		fi
	done < <(printf '%s\n' "${1}")
	# truncate if necessary, appending elipsis to indicate truncation
	if [[ ${#_commitMsgString} -ge ${_maxLength} ]]; then
		_commitMsgString="${_commitMsgString:0:${_maxLength}}..."
	fi
	# this should never occur...
	[ -z "${_commitMsgString}" ] && return 1
	# return the final string...with echo (should be using the indirect variable
	# here
	echo "${_commitMsgString}"
}

_doCommit() {
	_newFile="${1}"
	_commitMsg="${2}"
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_newFile}"  
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "${_commitMsg}"
}	

_isIndexClean() {
	git -C "${_HOME}" --git-dir="${_GITDIR}" diff-index --quiet --cached main 2>&1 >/dev/null || return 1
}

################
# SOURCE
################

_getSource() {
	# print the current SOURCE
	! _isSourceSet && { echo "default"; return; }
	cat "${_HOME}/.current"
}
export -f _getSource

_isSourceSet() {
	# return 0 if true
	# return 1 if false
	[[ -e "${_HOME}/.current" ]]
}
export -f _isSourceSet

_doesSourceExist() {
	# return 0 if true (yes)
	# return 1 if false (no)
	[[ -d "${_HOME}/${1}" ]]
}
export -f _doesSourceExist

_setSource() {
	# arg 1 = new source
	# check if source is set, if so, remove
	# then set to new
	[ -z "${1:-}" ] && return 1
	_isSourceSet && echo "${1}" > "${_HOME}/.current"
	export _currentSource=${1}
}

_saveSource() {
	# arg 1 = source name
	# arg 2 = source description
	mkdir "${_HOME}/$1"
	echo "${2}" > "${_HOME}/$1/.description"
}

_getSourceList() {
	ls "${_HOME}"
}
export -f _getSourceList

_printSourceEntities() {
	# arg 1 = source
	ls "${_HOME}/${1}"
}
export -f _printSourceEntities

_getSourceCount() {
	# arg 1 = source
	local _count=0
	_count=$(_printSourceEntities ${1} | wc -l)
	echo "$_count"
}
export -f _getSourceCount

_validateSourceName(){
	# function used within fzf preview window to assist in the selection of a
	# source name
	local _maxLength=25
	local _minLength=1
	local _newSourceName
	local lengthStatus
	local avail
	local allowedChars="n/a"
	local lead="n/a"
	local last="n/a"
	local repeat="n/a"
	local acceptable="NO"
	_cStat() {
		# arg 1 = key word
		# print the key word in a set color
		[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
		[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
		[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
		echo -n "${1}"
		tput sgr0 
	}
	# export to fzf for --preview
	export -f _cStat
	# validate the name first
	if [[ ${#1} -lt ${_minLength} ]]; then
		lengthStatus="TOO SHORT"
		avail="n/a"
	elif [[ ${#1} -gt ${_maxLength} ]]; then
		lengthStatus="TOO LONG"
		avail="n/a"
	else
		lengthStatus="OK"
		 _doesSourceExist "${1}" && { avail="NO"; acceptable="NO"; } || { avail="YES"; acceptable="YES"; }
	fi
	[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
	[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }
	# print the validation info into the fzf preview window	
	echo "----VALID NAME?  $(_cStat ${acceptable}) --------------"
	[[ -z "${1}" ]] && echo "waiting for input..." || echo "name: '${1}'"
	printf "length [%.2d]: %31s\n" ${#1} "$(_cStat "${lengthStatus}")"
	printf "unique: %36s\n" "$(_cStat "${avail}")"
	printf "character set allowed: %21s\n" "$(_cStat "${allowedChars}")"
	printf "first ['%s'] allowed: %23s\n" "${1:0:1}" "$(_cStat "${lead}")"
	printf "last ['%s'] allowed: %24s\n" "${1:(-1)}" "$(_cStat "${last}")"
	printf "no non-alpha/num repeats: %18s\n" "$(_cStat "${repeat}")"
	echo "-----------RULES------------------"
	echo "the name must be unique"
	echo "max length is ${_maxLength}, min is ${_minLength}"
	echo "lower case and numbers only"
	echo "non alpha-numeric characters allowed:"
	echo " - dash (-)"
	echo " - underscore (_)"
	echo " - dot (.)"
	echo " ^ these cannot be first or last"
	echo " ^ cannot be repeated (eg --)"
	echo
	echo "------SELECTED SOURCE DESCRIPTION-----------"
	[[ -z "${2}" ]] && echo "free" || cat "${_HOME}/${2}/.description"
}
# export above function to fzf for --preview
export -f _validateSourceName

_validateIndexName(){
	# function used within fzf preview window to assist in the selection of a
	# index name
	local _maxLength=25
	local _minLength=1
	local _newSourceName
	local lengthStatus
	local avail
	local allowedChars="n/a"
	local lead="n/a"
	local last="n/a"
	local repeat="n/a"
	local acceptable="NO"
	_cStat() {
		# arg 1 = key word
		# print the key word in a set color
		[[ "${1}" =~ ^(YES|OK) ]] && tput setaf 2
		[[ "${1}" =~ ^(NO|TOO) ]] && tput setaf 1
		[[ "${1}" =~ ^(n/a) ]] && tput setaf 3
		echo -n "${1}"
		tput sgr0 
	}
	# export to fzf for --preview
	export -f _cStat
	# validate the name first
	if [[ ${#1} -lt ${_minLength} ]]; then
		lengthStatus="TOO SHORT"
		avail="n/a"
	elif [[ ${#1} -gt ${_maxLength} ]]; then
		lengthStatus="TOO LONG"
		avail="n/a"
	else
		lengthStatus="OK"
		 _doesSourceExist "${1}" && { avail="NO"; acceptable="NO"; } || { avail="YES"; acceptable="YES"; }
	fi
	[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] && lead="YES" || { lead="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] && last="YES" || { last="NO" ; acceptable="NO" ; }
	[[ "${1}" =~ ^([[:lower:]|[:digit:]]|[-_.])*$ ]] && allowedChars="YES" || { allowedChars="NO" ; acceptable="NO" ; }
	[[ ! "${1}" =~ ([.]|[-]|[_]){2} ]] && repeat="YES" || { repeat="NO" ; acceptable="NO" ; }
	# print the validation info into the fzf preview window	
	echo "----VALID NAME?  $(_cStat ${acceptable}) --------------"
	[[ -z "${1}" ]] && echo "waiting for input..." || echo "name: '${1}'"
	printf "length [%.2d]: %31s\n" ${#1} "$(_cStat "${lengthStatus}")"
	printf "unique: %36s\n" "$(_cStat "${avail}")"
	printf "character set allowed: %21s\n" "$(_cStat "${allowedChars}")"
	printf "first ['%s'] allowed: %23s\n" "${1:0:1}" "$(_cStat "${lead}")"
	printf "last ['%s'] allowed: %24s\n" "${1:(-1)}" "$(_cStat "${last}")"
	printf "no non-alpha/num repeats: %18s\n" "$(_cStat "${repeat}")"
	echo "-----------RULES------------------"
	echo "the name must be unique"
	echo "max length is ${_maxLength}, min is ${_minLength}"
	echo "lower case and numbers only"
	echo "non alpha-numeric characters allowed:"
	echo " - dash (-)"
	echo " - underscore (_)"
	echo " - dot (.)"
	echo " ^ these cannot be first or last"
	echo " ^ cannot be repeated (eg --)"
	echo
	echo "------SELECTED INDEX CONTENTS-----------"
	[[ -z "${2}" ]] && echo "free" || tree -C "${_HOME}/${_currentSource}/.index/${2}"
}
# export above function to fzf for --preview
export -f _validateIndexName

# new unified fzf browser function
_fzfBrowser () {
	# all germ functions call this function
	# the following arguments set the initial context
	# $1 = nameref for return value
	# $2 = input function (prints the list of existing whatever)
	# $3 = validation function for fzf preview window (in which $1=query $2=selection)
	# $4 = initial prompt string or function
	# $5 = optional special instructions
	local -n _return=$1
	local _input=$2
	local _preview=$3
	local _prompt=$4
	export _instructions="${5:-existing above, guidance right >}"

	_setPrompt() {
  	# Set the FZF prompt dynamically based on the current source and index
  	local _currentSource=$(_getSource) # Get the current source
  	local _indexFile="${_HOME}/${_currentSource}/.current" # Path to the .current file
  	local _prompt
	
  	if [[ -f "${_indexFile}" ]]; then
    	# if .current file exists, read the current index name
    	local _currentIndex
    	_currentIndex=$(cat "${_indexFile}")
    	_prompt="${_currentSource}[${_currentIndex}]"
  	else
			# if no .current file, set the default prompt
    	_prompt="${_currentSource}"
		fi

		echo "${_prompt}>" # Output the prompt string
	}
	export -f _setPrompt

	# Determine the prompt
	if declare -F "${_prompt}" >/dev/null; then
		# If $4 is a function name, call it to get the prompt
		_prompt=$(${_prompt})
	fi

	# helper functions for fzf transformations
	_transHeader() {
		# add a second line to the header with context-specific info in yellow
		# $1 = string message to insert (as yellow text within brackets)
		printf "%s\n[\033[38;5;11m%s\033[0m]" "${_instructions}" "${1}"
	}
	export -f _transHeader

	# preview help window	
	_showHelp() {
		printf '
 +-------------------------+---------------------------------+
 |       germ help         |     hit "/" to close help       |
 +-------------------------+---------------------------------+

 main navigation
 - alt-P   page up         - alt-H   half page up
 - alt-p   page down       - alt-h   half page down

 preview navigation
 - ctrl-[up|down] arrow scrolls the preview window
 - ctrl-j previews the json output (txt is default)

 create index
 - ctrl-i  create a new index
 - ctrl-u  read the notebook without index

'
	}
	# export functions to fzf (child)
	export -f _showHelp

	# run the fzf loop, building the fzf command with an array
	while true; do
		# basic fzf defaults
		FZF_COMMAND=()
		FZF_COMMAND+=(--no-multi)				# limits to single selection
		FZF_COMMAND+=(--no-mouse)				# prevents mouse interaction
		FZF_COMMAND+=(--ansi)						# enables ansi color code processing
		FZF_COMMAND+=(--print-query)		# prints the query term as the first line
		FZF_COMMAND+=(--exact)					# enables exact-match
		#FZF_COMMAND+=(--info="hidden")	# hides the finder details

		# prompt and instructions and initial list input
		FZF_COMMAND+=(--header="${_instructions}")			# sets the instruction line
		FZF_COMMAND+=(--bind="start:reload(${_input})")	# loads using given _input function ($2)
		FZF_COMMAND+=(--bind="start:+transform-prompt(_setPrompt)")	# sets prompt

		# catch common keys and notify accordingly
		FZF_COMMAND+=(--bind="ctrl-c:transform-header(_transHeader 'ESC to abort')")
		FZF_COMMAND+=(--bind="ctrl-q:transform-header(_transHeader 'ESC to abort')")
		FZF_COMMAND+=(--bind="ctrl-z:transform-header(_transHeader 'no ctrl-z')")
		FZF_COMMAND+=(--bind="backward-eof:transform-header(_transHeader 'ESC to abort')")

		# key bindings for index creation
		FZF_COMMAND+=(--bind="ctrl-i:execute(_createIndex)")
		FZF_COMMAND+=(--bind="ctrl-i:+transform-prompt(_setPrompt)")
		FZF_COMMAND+=(--bind="ctrl-i:+reload(${_input})")
		FZF_COMMAND+=(--bind="ctrl-u:execute(_readRaw)")
		FZF_COMMAND+=(--bind="ctrl-u:+reload(${_input})")
		FZF_COMMAND+=(--bind="ctrl-u:+transform-prompt(_setPrompt)")

		# add selected file to index (simple append)
		FZF_COMMAND+=(--bind="alt-a:execute(_addToIndex {})")
		FZF_COMMAND+=(--bind="alt-a:+reload(${_input})")

		# the exit / abort command is ESC
		FZF_COMMAND+=(--bind="esc:abort")

		# main help (toggles preview)
		FZF_COMMAND+=(--bind="?:change-preview(_showHelp)")
		FZF_COMMAND+=(--bind="/:change-preview(${_preview} {q} {})")

		# the preview window
		FZF_COMMAND+=(--preview="${_preview} {q} {}")
		FZF_COMMAND+=(--preview-window=75%,wrap)

		# navigation shortcuts
		FZF_COMMAND+=(--bind="alt-P:page-up")
		FZF_COMMAND+=(--bind="alt-p:page-down")
		FZF_COMMAND+=(--bind="alt-H:half-page-up")
		FZF_COMMAND+=(--bind="alt-h:half-page-down")
	
		# assign the fzf results to _selection (what was "selected")
		_FZF_selection=$(fzf "${FZF_COMMAND[@]}")

		# split out the query string into $query
		query=$(echo "${_FZF_selection}" | head -n1)

		# assign the selection to $selection (note no MULTI SELECT yet)
		selection=$(echo "${_FZF_selection}" | tail -n1)
		_debug "query is '${query}'"
		_debug "selection is '${selection}'"

		# finally, return the two values into the nameref _return
		_return="${query}:${selection}"
		break
	done
}
export -f _fzfBrowser

_listEntities () {
	# generate an index-aware list for fzf
  local _currentSource=$(_getSource)
	local _sourceDir="${_HOME}/${_currentSource}"
	local _currentIndex="${_HOME}/${_currentSource}/.current"
  local _indexedFiles=()
  local _nonIndexedFiles=()

	# check for the current index
	if [ -f "${_currentIndex}" ]; then
		local _currentIndexName=$(cat "${_currentIndex}")
		local _currentIndexDir="${_HOME}/${_currentSource}/.index/${_currentIndexName}"
	fi

	# Ensure the active index directory exists
	if [[ -d "${_currentIndexDir}" ]]; then
		# Read the symbolic links in the active index directory
		while IFS= read -r -d '' link; do
			local _linkName=$(basename "${link}")
			local _originalFile=$(readlink "${link}")
			#_indexedFiles+=("${_linkName} -> $(basename "${_originalFile}")")
			_indexedFiles+=(".index/${_currentIndexName}/${_linkName}")
		done < <(find "${_currentIndexDir}" -mindepth 1 -maxdepth 1 -type l -print0)
	fi

	# Get the list of non-indexed files
	local _allFiles
	_allFiles=$(ls "${_HOME}/${_currentSource}")
	for _file in ${_allFiles}; do
		# Check if the file is already indexed
		if [[ ! " ${_indexedFiles[*]} " =~ " ${_file} " ]]; then
			_nonIndexedFiles+=("${_file}")
		fi
	done

	# sort the indexed files
	_indexedFiles=($(printf '%s\n' "${_indexedFiles[@]}" | sort -n))
	# sort the non-indexed files
	_nonIndexedFiles=($(printf '%s\n' "${_nonIndexedFiles[@]}" | sort -n))

	# Output the combined list: indexed files first, then non-indexed files
	for _indexed in "${_indexedFiles[@]}"; do
		echo "${_indexed}"
	done
	for _nonIndexed in "${_nonIndexedFiles[@]}"; do
		echo "${_nonIndexed}"
	done
}
export -f _listEntities

_createIndex() {
  # create or select an index for the current source
  local _currentSource=$(_getSource)
	local _sourceDir="${_HOME}/${_currentSource}"
  local _indexDir="${_HOME}/${_currentSource}/.index"
  local _indexName
  local _indexPath

  # Ensure the .index directory exists
  [[ -d "${_indexDir}" ]] || mkdir -p "${_indexDir}"

  # Use _fzfBrowser to create an index name
  _fzfBrowser _indexName _listIndexes _validateIndexName "name>" "create or select index"

	# abort if fzf returns null
	[[ ${_indexName} = ":" ]] && { _warn "index creation aborted"; return; }
	
	# fzfBrowser returns "query:selection", so trim to selection only
	_indexName=${_indexName#*:}

  # Validate the selected or entered index name
  if ! _isSourceNameValid "${_indexName}"; then
    _warn "invalid index name: '${_indexName}'"
    return 1
  fi

  # create the new index directory if it doesn't exist
  _indexPath="${_indexDir}/${_indexName}"
  if [[ ! -d "${_indexPath}" ]]; then
    mkdir -p "${_indexPath}"
    _info "index '${_indexName}' created successfully"
  else
    _info "index '${_indexName}' already exists"
  fi

	# set the current view to the index
	echo ${_indexName} > "${_sourceDir}/.current"

}
export -f _createIndex

_readRaw () {
	# remove the .current file and read the raw list
  local _currentSource=$(_getSource)
	local _sourceDir="${_HOME}/${_currentSource}"
	rm "${_sourceDir}/.current"
}
export -f _readRaw

_listIndexes() {
  # List all indexes for the current source
  local _source=$(_getSource)
  local _indexDir="${_HOME}/${_source}/.index"

  # Check if the .index directory exists
  if [[ -d "${_indexDir}" ]]; then
    # List all directories inside .index
    find "${_indexDir}" -mindepth 1 -maxdepth 1 -type d -exec basename {} \;
  else
    # If .index does not exist, return an empty list
    return
  fi
}
export -f _listIndexes

_addToIndex() {
  # Add a file to the current index
  # $1 = selected file
	local _currentSource=$(_getSource)
	local _currentIndex="${_HOME}/${_currentSource}/.current"

	# check for the current index
	if [ -f "${_currentIndex}" ]; then
		local _currentIndexName=$(cat "${_currentIndex}")
		local _currentIndexDir="${_HOME}/${_currentSource}/.index/${_currentIndexName}"
	else
		return 1
	fi

  # Determine the next available number for the symbolic link
  local _nextIndex
  _lastIndex=$(find "${_currentIndexDir}" -mindepth 1 -maxdepth 1 -type l -exec basename {} \; | sort -n | tail -1)
  _nextIndex=$((_lastIndex + 1))

  # Create the symbolic link
  local _sourceFile="${_HOME}/${_currentSource}/${1}"
  local _linkPath="${_currentIndexDir}/${_nextIndex}"
  if [[ -f "${_sourceFile}" ]]; then
		# the link must be relative to allow for renaming
		ln -s "$(realpath --relative-to="${_currentIndexDir}" "${_sourceFile}")" "${_linkPath}"
    _info "added '${1}' to index '${_currentIndexName}' as entry '${_nextIndex}'"
  else
    _error "file '${1}' does not exist"
    return 1
  fi

}
export -f _addToIndex

# usage:
# _namePicker _newName   _getSourceList _validateNamePreview "prompt"    "special notes"
# (function)  (nameref)     (fzf feed)      (fzf preview)     fxf prompt  (fzf header)    
_namePicker () {
	# $1 = nameref for return value
	# $2 = input function (prints the list of existing whatever)
	# $3 = validation function for fzf preview window (in which $1=query $2=selection)
	# $4 = prompt string
	# $5 = optional special instructions
	# basically an fzf wrapper for name selection to be used globally
	# single level only and single selection
	local -n _return=$1
	local _input=$2
	local _preview=$3
	local _prompt=$4
	export _instructions="${5:-existing above, guidance right >}"
	_transHeader() {
		# add a second line to the header with context-specific info in yellow
		# $1 string message to insert
		printf "%s\n[\033[38;5;11m%s\033[0m]" "${_instructions}" "${1}"
	}
	export -f _transHeader
	while true; do
		_newName=$(fzf \
			--no-multi \
			--no-mouse \
			--ansi \
			--print-query \
			--exact \
			--info="hidden" \
			--prompt="${_prompt}>" \
			--header="${_instructions}" \
			--bind="start:reload(${_input})" \
			--bind="ctrl-c:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-q:transform-header(_transHeader 'ESC to abort')" \
			--bind="ctrl-z:transform-header(_transHeader 'no ctrl-z')" \
			--bind="backward-eof:transform-header(_transHeader 'ESC to abort')" \
			--bind="tab:replace-query+first" \
			--bind="esc:abort" \
			--preview="${_preview} {q} {}" \
			--preview-window=80%,wrap
		);
		query=$(echo "${_newName}" | head -n1)
		selection=$(echo "${_newName}" | tail -n1)
		#_debug "query is '${query}'"
		#_debug "selection is '${selection}'"
		_return="${query}:${selection}"
		break
	done
}

_getSourceDetails() {
	local _newSourceName=$1
	[[ ${_newSourceName} = $(_getSource) ]] && return
	echo -e $(_ask "enter a description for '${_newSourceName}' ?=help q=abort")
	while read -r -e -p "$(_ask ": ")" _newSourceDescription; do
		case "${_newSourceDescription}" in
			help|h|\?)
				_info "enter a description for '${_newSourceName}'"
				_info "example: little green notebook 12 Jan 2023" 
				_info "example: lecture notes from chem 202"
				_info "note: the description can be changed later"
				_info "    : multiple lines can be added later as well"
				_info "usage: q to abort, h for this help."
				_info "enter a description for '${_newSourceName}'"
				;;
			quit|q)
				_warn "aborting; '${_newSourceName}' not added. try again later"
				return 1
				;;
			*)
				[[ -z ${_newSourceDescription} ]] && { _warn "empty description not allowed"; continue; } 
				[[ ${_newSourceDescription} =~ ^[[:alnum:]] ]] || { _warn "use your words"; continue; }
				break
				;;
		esac
	done
	[[ -z ${_newSourceDescription} ]] && { _warn "empty description not allowed"; return; } 
	while read -r -e -n1 -p "$(_ask "save '${_newSourceName}' as a new source? (y/n)") " _c; do
		case ${_c} in
			y)
				_saveSource "${_newSourceName}" "${_newSourceDescription}"
				break
				;;
			n)
				return 1
				;;
			*)
				continue
				;;
		esac
	done
	while read -r -e -n1 -p "$(_ask "set '${_newSourceName}' as current? (y/n) ") " _d; do
		case ${_d} in
			y)
				_setSource "${_newSourceName}"
				return
				;;
			n)
				return
				;;
			*)
				continue
				;;
		esac
	done
}

_previewSource() {
	# used by fzf during source change...shows description and entity count
	[[ -z ${2} ]] && { echo "source does not exist"; return; }
	echo "source: $2"
	echo "entries: $(_getSourceCount $2)"
	echo
	echo "----DESCRIPTION-------------------"
	cat "${_HOME}/${2}/.description"
}
export -f _previewSource

_previewEntry() {
	# used by fzf during edit to display the germ 
	#echo "query    : $1"
	#echo "selection: $2"
	#echo "----entity contents below---------"
	if [[ -z "${2}" ]]; then
		echo "no such entity"
	else
		cat "${_HOME}/${_currentSource}/${2}"
	fi
}
export -f _previewEntry

_isSourceNameValid() {
	local _maxLength=25
	local _minLength=1
	# arg 1 = source name
	if [[ "${1}" =~ ^([[:lower:]|[:upper:]|[:digit:]]|[-_.]){${_minLength},${_maxLength}}$ ]]; then
		[[ "${1}" =~ ^[[:lower:]|[:digit:]] ]] || return 1
		[[ "${1}" =~ [[:lower:]|[:digit:]]$ ]] || return 1
		[[ "${1}" =~ ([.]|[-]|[_]){2} ]] && return 1
		if _doesSourceExist "${1}"; then
			_warn "'${1}' is not new"
			return 1
		else
			return 0
		fi
	else
		_warn "'${1}' is not allowed, try again"
		_info "rules: a-z A-Z 0-9 _ - . allowed; no spaces allowed"
		_info "rules: max length ${_maxLength} characters, min is ${_minLength}"
		return 1
	fi
}
export -f _isSourceNameValid

_mergeSource() {
	_current=${_currentSource}
	_namePicker _mergeWhat _getSourceList _previewSource "WHAT" "merge into '$_current'" || return
	[[ ${_mergeWhat} = ":" ]] && { _warn "merge aborted"; return; }
	# separate the return
	_query=${_mergeWhat%%:*}
	_selection=${_mergeWhat#*:}
	_debug "query is '${_query}'"
	_debug "selection is '${_selection}'"
	# if query is empty and selection exists, use it 
	[[ -z "${_query}" ]] && _doesSourceExist "${_selection}" \
		&& _what=${_selection}
	# if query is not empty and it matches a source, use that
	if [[ ! -z "${_query}" ]]; then
		if [[ "${_query}" = "${_selection}" ]]; then
			# user did not use arrow to select, use _query
	 		_doesSourceExist "${_query}" && _what=${_query}
		else
			# query and selection do not match...user selected
	 		_doesSourceExist "${_selection}" && _what=${_selection}
		fi
	fi
	# if query is not empty and it does not match a source, use selection
	# if it exists
	if [[ ! -z "${_query}" ]] && ! _doesSourceExist "${_query}"; then
		if _doesSourceExist "${_selection}"; then
		 	_what=${_selection}
		else
			_warn "'${selection}' does not exist; cannot merge from nothing"
			return
		fi
	fi
	[[ ${_what} = ${_current} ]] && { _warn "cannot merge into self"; return; }
	[[ $(_getSourceCount ${_what}) = 0 ]] && { _warn "cannot merge from empty source"; return; }
	read -rsn1 -p $(_ask "merge '${_what}' into '${_current}' ? [y/n]") _yn
 	echo
 		[[ ${_yn} != "y" ]] && { _warn "merge aborted"; return; }
	_debug "now merge '${_what}' into '${_current}'"
	# git mv all 
	git -C "${_HOME}" --git-dir="${_GITDIR}" mv "${_HOME}/${_what}/"* "${_HOME}/${_current}"
	# then remove if not default
	[[ ${_what} != "default" ]] && git -C "${_HOME}" rm -rq "${_HOME}/${_what}"
	# then commit
 	git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] merged ${_what} into ${_current}"
}

_newSource() {
	_namePicker _newSource _getSourceList _validateSourceName "NEW" "choose a new source name" || continue
	# always use the query here
	_newSource=${_newSource%%:*}
	[[ -z "${_newSource}" ]] && { _warn "empty names not allowed"; return; }
	_isSourceNameValid "${_newSource}" || { _error "'${_newSource}' is invalid"; return; }
	_getSourceDetails "${_newSource}" || { _warn "aborted adding new source"; return; }
  git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/${_newSource}/.description"
  git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] added ${_newSource}"
}

_changeSource() {
	_namePicker _changeTo _getSourceList _previewSource	"FILTER" "change to selected" || return
	[[ ${_changeTo} = ":" ]] && { _warn "change source aborted"; return; }
	# separate the return
	_query=${_changeTo%%:*}
	_selection=${_changeTo#*:}
	#_debug "query is '${_query}'"
	#_debug "selection is '${_selection}'"
	# if query is empty and selection exists, do it
	[[ -z "${_query}" ]] && _doesSourceExist "${_selection}" \
		&& { _setSource "${_selection}"; return; }
	# if query is not empty and it matches a source, use that
	if [[ ! -z "${_query}" ]]; then
		if [[ "${_query}" = "${_selection}" ]]; then
			# user did not use arrow to select, use _query
	 		_doesSourceExist "${_query}" && { _setSource "${_query}"; return; }
		else
			# query and selection do not match...user selected
	 		_doesSourceExist "${_selection}" && { _setSource "${_selection}"; return; }
		fi
	fi
	# if query is not empty and it does not match a source, use selection
	# if it exists
	if [[ ! -z "${_query}" ]] && ! _doesSourceExist "${_query}"; then
		if _doesSourceExist "${_selection}"; then
		 	_setSource "${_selection}"; return
		else
			_warn "'${selection}' does not exist; use N to create new source"
			return
		fi
	fi
}

_renameSource() {
	_current=${_currentSource}
	[[ "${_current}" = "default" ]] && { _warn "cannot rename 'default'"; return; }
	_namePicker _newName _getSourceList _validateSourceName "NEW-NAME" "rename '$_current'" || return
	[[ ${_newName} = ":" ]] && { _warn "rename source aborted"; return; }
	# always use the query here
	_newName=${_newName%%:*}
	[[ -z ${_newName:-} ]] && { _warn "empty names not allowed"; return; }
	_isSourceNameValid "${_newName}" || { _error "'${_newName}' is invalid"; return; }
	_doesSourceExist "${_newName}" && { _warn "${_newName} exists"; return; }
 	git -C "${_HOME}" --git-dir="${_GITDIR}" mv "${_HOME}/${_current}" "${_HOME}/${_newName}"
 	git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] renamed ${_current} to ${_newName}"
	_setSource "${_newName}"
}

_edit() {
	# launch picker to select what to edit
	local _current=${_currentSource}
	[[ $(_getSourceCount ${_current}) = 0 ]] && { _warn "'${_current}' is empty"; return; }
	_namePicker _what "_printSourceEntities ${_current}" _previewEntry "${_current}" "chose what to edit" || return
	[[ ${_what} = ":" ]] && { _warn "edit aborted"; return; }
	# always use the selection
	_file=${_what#*:}
	# edit
	${_EDITOR} "${_HOME}/${_current}/${_file}"
	# test for changes
  git -C "${_HOME}" --git-dir="${_GITDIR}" diff --quiet --exit-code "${_HOME}/${_current}/${_file}" && return
	_commitMsgString=$(_buildCommitMsg "$(cat "${_HOME}/${_current}/${_file}")")
	# save file and commit
	_doCommit "${_HOME}/${_current}/${_file}" "[edit in ${_current}] ${_commitMsgString}"
}

_browse() {
	local _current=${_currentSource}
	[[ $(_getSourceCount ${_current}) = 0 ]] && { _warn "'${_current}' is empty"; return; }
	_c=${_currentSource}
	# _fzfBrowser _nameref _listFeed _previewFunc _prompt _instructions
	#_fzfBrowser _w "_printSourceEntities ${_c}" _previewEntry "${_c}" "? for help" || return
#	_fzfBrowser _w "_printSourceEntities ${_c}" _previewEntry _setPrompt "? for help" || return
	_fzfBrowser _w _listEntities _previewEntry _setPrompt "? for help" || return
}

_deleteSource() {
	_state=empty
	_current=${_currentSource}
	[[ "${_current}" = "default" ]] && { _warn "cannot delete 'default'"; return; }
	[[ $(_getSourceCount ${_current}) != 0 ]] && \
		{ _warn "'${_current}' is not empty"; _state=non-empty; }
	read -rsn1 -p $(_ask "delete ${_state} '${_current}' ? [y/n]") _yn
 	echo
 	[[ ${_yn} != "y" ]] && { _warn "delete aborted"; return; }
	git -C "${_HOME}" rm -rq "${_HOME}/${_current}"
 	git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] deleted ${_state} ${_current}"
	_setSource "default"
}

########################
# SEARCH
########################

_search() {
	rg --color=always --line-number --no-heading --smart-case "${*:-}" | fzf \
		--ansi \
		--color "hl:-1:underline,hl+:-1:underline:reverse" \
		--delimiter : \
		--preview 'batcat --color=always {1} --highlight-line {2}' \
		--preview-window 'up,60%,border-bottom,+{2}+3/3,~3'
}

########################
# PDF
########################

_pdf() {
	# produce a nice pdf and save to desktop
	# source notebook provided as $1
	local _source=${1}
	# destination for output file
	local _destination="$HOME/Desktop/"
	# temp working dir
	local _temp=$(mktemp -d)
	# log file
	local _logfile="${_temp}/germ_pdf.log"
	_debug "logging to '$_logfile'"
	# set the output file name
	local _filename="${_source}-$(date +%Y%m%d-%H%M%S)"
	# set the output file full path
	local _output_full_path="${_destination}${_filename}"
	# full commit hash (40 characters)
	full_hash=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-parse HEAD)
	# Short commit hash (typically 7 characters)
	short_hash=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-parse --short HEAD)

	# create a list of files, sorted chronologically by timestamp
	local files=()
		while IFS= read -r -d '' file; do
			files+=("$file")
		done < <(find "${_source}" -maxdepth 1 -type f -regextype posix-extended -regex ".*[0-9]{10}\.[0-9]+" -print0 | sort -z)

	# add trap to remove temporary directory on exit
#	trap 'rm -rf "$_temp"' EXIT

	# gather statistics
	local total_files=${#files[@]}
	local words_per_file=()
	local pages_per_file=()
	
	# calculate words and pages for each file
	for file in "${files[@]}"; do
		words_per_file+=("$(wc -w < "$file")")
		# estimate pages (assuming ~66 lines per page with enscript defaults)
		local file_lines=$(wc -l < "$file")
		pages_per_file+=("$(( (file_lines + 65) / 66 ))")
	done
	
	# create cover page
	local cover_file="${_temp}/cover_page.txt"
	cat > "$cover_file" << EOF

source name: $_source
description: $(cat ${_HOME}/${_currentSource}/.description)
file count: $total_files
draft date: $(date '+%Y-%m-%d %H:%M:%S %Z')
germ git hash: $full_hash


EOF
	
	# enumerate file details into cover page
	printf "%-6s %-21s %-35s %6s %8s %7s\n" "index" "key" "name" "words" "pages" "revs" >> "$cover_file"
	printf -- "------------------------------------------------------------------------------------------\n" >> "$cover_file"
	for i in "${!files[@]}"; do
		local filename=$(basename "${files[i]}")
		local givenname=$(head -1 "${files[i]}")
		local revs=$(git -C "${_HOME}" --git-dir="${_GITDIR}" rev-list --count HEAD -- "${files[i]}")
		printf "%3d. %*s %-21s %-35s %5d %7d %7d\n" \
			$((i+1)) 1 "" "$filename" "$givenname" "${words_per_file[i]}" "${pages_per_file[i]}" "$revs" >> "$cover_file"
	done

	# create cover header
	local _header="${_MASTER}:${_NAME}:${_USERNAME}"
	_header+="|==--DRAFT--=="
	_header+="|${_source} [${short_hash}]"

	# convert cover page to PDF
	enscript -f Courier10 -b"${_header}" -p "${_temp}/cover.pdf" "$cover_file" >> "${_logfile}" 2>&1

	# combine files into a single PDF
	local combined_pdf="${_temp}/text_archive.pdf"
	local temp_pdfs=()
	for i in "${!files[@]}"; do
		local file="${files[i]}"
		local filename=$(basename "$file")

		# create header string for each file
		local _header="${_source}:DRAFT"
		_header+="|$filename"
		_header+="|page $% of $="

		# convert file to PDF
		local file_pdf="${_temp}/file_${i}.pdf"
		enscript -f Courier10 -b"${_header}" -p "$file_pdf" "$file" >> "${_logfile}" 2>&1
		temp_pdfs+=("$file_pdf")
	done

	# combine all PDFs
	gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile="$combined_pdf" \
		"${_temp}/cover.pdf" "${temp_pdfs[@]}"

	# copy final PDF to Desktop
	cp "${combined_pdf}" "${_destination}${_filename}"
	_info "copied file to desktop as '${_filename}'"
}

###############
###### SHELL
###############

_shell() {
	cd "${_HOME}" || { _error "can not enter ${_NAME}"; return 1; }
	# set up shell history business
	HISTFILE="${_HOME}/.${_NAME}_history"
	HISTSIZE=1000
	HISTFILESIZE=10000
	HISTTIMEFORMAT="%s %F %T "
	HISTCONTROL=ignoreboth
	shopt -s histappend
	set -o history
	# here would be the right place to lock the session
	## SESSION-LOCK
	# and keep session timers and counters
	# set the current source
	export _currentSource=$(_getSource)
	# the splash welcome
	_displayWelcome() {
	cat <<HEREDOC
  __  ___  ___   __  __ 
 / _)(  _)(  ,) (  \/  )
( (/\ ) _) )  \  )    ( 
 \__/(___)(_)\_)(_/\/\_)

      type ${green}h${reset} for help
      type ${red}q${reset} to quit

HEREDOC
	}
	# the main menu
	_printMenu() {
		printf '\n'
		printf ':-----germ commands------------------------------------------------------------o\n'
		printf '\n'
		printf '  h   how to use                      == current source: "%s" ==== \n' "${_currentSource}"
		printf '  a   add new note (editor)            C  change source                        .\n'
		printf '  f   fast add (one line, no editor)   N  new source                           .\n'
		printf '  e   edit (within current)            R  rename current                       .\n'
		printf '  b   browse (within current)          M  merge (other into current)           .\n'
		printf '  s   search                           D  delete current                       .\n'
		printf '                                       P  print description                    .\n'
		printf '  p   pdf current to desktop           E  edit description                     .\n'
		printf '                                       S  split (future)                       .\n'
		printf '                                       B  browse all source notebooks          .\n'
		printf '  \n'
		printf '  \n'
		printf '  \n'
		printf '                                         ===========debug etc==============\n'
		printf '  a   add new (editor)                    ctrl-x toggle bash debug (set -x) \n'
		printf '  f   fast add (no editor)                ctrl-b toggle germ debug          \n'
		printf '  e   edit                                0 print env                       \n'
		printf '  b   browse                              ctrl-g git status                 \n'
		printf '  q   quit %s\n' ${_NAME}
		printf '.  *insert msg*                                                                .\n'
	}
	_printGuidance() {
		printf '\n'
		printf ':-----germ usage guide---------------------------------------------------------o\n'
		printf '\n'
		printf ' in the simplest form, there is one "notebook" aka "source"  \n'
		printf '  which is called "default"                                                    .\n'
		printf '   press "a" to add a new note to the current source                           .\n'
		printf '                                                                               .\n'
		printf '                                                                               .\n'
		printf '  to use and manipulate multiple "notebooks" use the source commands           .\n'
		printf '   N creates new notebook names                                                .\n'
		printf '   R renames the current                                                       .\n'
		printf '   M allows one to merge the contents of one source into the current           .\n'
		printf '            it also deletes the now empty other source                         .\n'
		printf '   D deletes the current source (even if it is not empty!)                     .\n'
		printf '  \n'
		printf '  commands operate on the current "source"\n'
		printf '  \n'
		printf '  \n'
		printf '  the default notebook cannot be renamed or removed                            .\n'
		printf '  \n'
		printf '  \n'
		printf '  \n'
		printf '  q   quit %s\n' ${_NAME}
		printf '.  *insert msg*                                                                .\n'
	}
	# the prompt and interpreter
	_mainPrompt() {
		# disallow use of ctrl-c etc
		trap '' SIGQUIT SIGTSTP SIGINT SIGTERM
		_p() {
			local _cs=${_currentSource}
			# set the prompt
			reset=$'\001\e[0m\002'
			_cH=$'\001\e[00;45m\002'		#home
			_cG=$'\001\e[00;7m\002'			#germ
			_cU=$'\001\e[00;32m\002'		#user
			_cS=$'\001\e[00;33m\002'		#source
			_dirty="${green}o${reset}"
			_isIndexClean || _dirty="${red}-${reset}"
			echo -n "${_cH}${_MASTER}${reset}:${_cG}${_NAME}${reset} ${_cU}${_USERNAME}${reset} [${_cS}${_cs}${reset}] ${_dirty} > "
		}
		_displayWelcome
		local __input
		while read -rsn1 -p "$(_p)" __input || true; do
			echo
			case ${__input} in
				\?)
					_printMenu
					;;
				h)
					_printGuidance
					;;
				a)
					_add || :
					;;
				f)
					# fast (editor-free) add
					echo -e $(_ask "add to '${_currentSource}'; ENTER to accept")
					read -r -p "$(_ask ": ")" _newEntry
					[[ -z "${_newEntry}" ]] && continue
					_key=$(_getNewKey)
					_commitMsg=$(_buildCommitMsg "${_newEntry}")
					echo "${_newEntry}" > "${_HOME}/${_currentSource}/${_key}"
					_doCommit "${_HOME}/${_currentSource}/${_key}" "[add to ${_currentSource}] ${_commitMsg}"
					;;
				e)
					_edit || :
					;;
				b)
					_browse || :
					;;
				s)
					_search || :
					;;
				p)
					_pdf "${_currentSource}"
					;;
				C)
					_changeSource || :
					;;
				N)
					_newSource || :
					;;
				R)
					_renameSource || :
					;;
				M)
					_mergeSource || :
					;;
				D)
					_deleteSource || :
					;;
				S)
					_debug "split requires multi-select fzf function"
					;;
				E)
					# edit source description
					${_EDITOR} "${_HOME}/${_currentSource}/.description"
  				git -C "${_HOME}" --git-dir="${_GITDIR}" add "${_HOME}/${_currentSource}/.description"
  				git -C "${_HOME}" --git-dir="${_GITDIR}" commit -q -m "[source] updated '${_currentSource}' description"
					# TODO fix this...when desc is not saved, error 
					;;
				P)
					_info "current source: ${_currentSource}"
					_info "entries       : $(_getSourceCount ${_currentSource})"
					_info "description   : $(cat ${_HOME}/${_currentSource}/.description)"
					_info "entities      : $(_printSourceEntities ${_currentSource})"
					;;
				$'\x18')
					# toggle bash set -x debug with ctrl-x
					[[ $- == *x* ]] && set +x || set -x
					;;
				$'\x02')
					# toggle script _DEBUG with ctrl-B
					[ $_DEBUG = "true" ] && _DEBUG=false || _DEBUG=true
					_debug "debug on"
					;;
				$'\x07')
					# ctrl-g (run git status)
  				git -C "${_HOME}" --git-dir="${_GITDIR}" status
					;;
				0)
					printenv | grep "^_"
					;;
				t)
					_inspect
					;;
				q)
					return
					;;
				$'\e')
					# ignore all escape sequences
					_debug "esc ignored"
					# eat anything there
					read -rsn8 -t .002 _escape || continue
					_debug "esc $_escape"
					;;
				$'\04')
					# read ctrl-d
					_warn "use 'q' to quit"
					;;
			esac
		done
	}
	_mainPrompt
}

main() {
	# read all the poositional parameters
  _getOpts "${@}"
  # setup the environment after processing all command line parameters
  _setEnv
  # validate the environment (external tools required)
  _checkExternalTools || { _error "cannot run until these problems are resolved"; return 1; }
  # check for the working directory
  _checkHome || { _error "cannot run without a working environment"; return 1;  }
	# check health
	# TODO eg check for .swp file from vim crash
	#
  # enter custom shell if no arguments
  [ -z "${_subCommand:-}" ] && _shell
  # otherwise, pass the commands to the called "command"
  [[ -n "${_subCommand:-}" ]] && _debug "now calling the eval to run '${_subCommand:-}'"
  [[ -n "${_subCommand:-}" ]] && eval _"${_subCommand}" || :
}
main "${@}"
